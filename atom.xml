<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[心缘冰河]]></title>
  <subtitle><![CDATA[写出我人生,coding]]></subtitle>
  <link href="//atom.xml" rel="self"/>
  <link href="http://donahue-ldz.github.io/"/>
  <updated>2015-03-27T03:48:21.000Z</updated>
  <id>http://donahue-ldz.github.io/</id>
  
  <author>
    <name><![CDATA[donahue]]></name>
    <email><![CDATA[ldz2012yn@gmail.com]]></email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[ClassLoader学习]]></title>
    <link href="http://donahue-ldz.github.io/2015/03/27/ClassLoader%E5%AD%A6%E4%B9%A0/"/>
    <id>http://donahue-ldz.github.io/2015/03/27/ClassLoader学习/</id>
    <published>2015-03-27T03:39:38.000Z</published>
    <updated>2015-03-27T03:48:21.000Z</updated>
    <content type="html"><![CDATA[<h3 id="ClassLoader作用">ClassLoader作用</h3><blockquote>
<p>ClassLoader负责载入系统的所有Resources（Class，文件，来自网络的字节流等），通过ClassLoader从而将资源载入JVM。<br>ClassLoader主要对类的请求提供服务，当JVM需要某类时，它根据名称向ClassLoader要求这个类，然后由ClassLoader返回这个类的class对象。 </p>
</blockquote>
<p><code>每个class都有一个reference，指向自己的ClassLoader。</code><br>array的ClassLoader就是其元素的ClassLoader，若是基本数据类型，则这个array没有ClassLoader 。 </p>
<hr>
<h3 id="主要方法">主要方法</h3><p>Java1.1及从前版本中，ClassLoader主要方法：<br>Class loadClass( String name, boolean resolve ) ClassLoader.loadClass() 是 ClassLoader 的入口点 。<br><code>defineClass</code> 方法是ClassLoader的主要诀窍。该方法接受由原始字节组成的数组并把它转换成 Class对象。原始数组包含如从文件系统或网络装入的数据。<br><code>findSystemClass</code> 方法从本地文件系统装入文件。它在本地文件系统中寻找类文件，如果存在，就使用 defineClass 将原始字节转换成 Class 对象，以将该文件转换成类。当运行 Java 应用程序时，这是 JVM 正常装入类的缺省机制。  </p>
<p><code>resolveClass</code>可以不完全地（不带解析）装入类，也可以完全地（带解析）装入类。当编写我们自己的 loadClass 时，可以调用 resolveClass，这取决于 loadClass 的 resolve 参数的值 </p>
<p><code>findLoadedClass</code> 充当一个缓存：当请求loadClass装入类时，它调用该方法来查看 ClassLoader是否已装入这个类，这样可以避免重新装入已存在类所造成的麻烦。应首先调用该方法  。</p>
<h3 id="工作过程">工作过程</h3><p>一般load方法过程如下：</p>
<ul>
<li>调用 findLoadedClass 来查看是否存在已装入的类。  </li>
<li>如果没有，那么采用某种特殊的神奇方式来获取原始字节。（通过IO从文件系统，来自网络的字节流等）  </li>
<li><p>如果已有原始字节，调用 defineClass 将它们转换成 Class 对象。<br>如果没有原始字节，然后调用 findSystemClass从本地文件系统获取类。  </p>
</li>
<li><p>如果 resolve 参数是 true，那么调用 resolveClass 解析 Class 对象。<br>如果还没有类，返回 ClassNotFoundException。  </p>
</li>
<li>否则，将类返回给调用程序。  </li>
</ul>
<h3 id="委托模型">委托模型</h3><p>自从JDK1.2以后，ClassLoader做了改进，使用了委托模型，所有系统中的ClassLoader组成一棵树，<font color="red">ClassLoader在载入类库时先让Parent寻找，Parent找不到才自己找</font>。<br>JVM在运行时会产生三个<br><code>ClassLoader，Bootstrap ClassLoader、Extension ClassLoader和App ClassLoader</code>。</p>
<blockquote>
<ul>
<li>Bootstrap ClassLoader是用C++编写的，在Java中看不到它，是null。它用来加载核心类库，就是在lib下的类库</li>
<li>Extension ClassLoader加载lib/ext下的类库</li>
<li>App ClassLoader加载Classpath里的类库</li>
</ul>
</blockquote>
<font color="red">三者的关系为:App ClassLoader的Parent是Extension ClassLoader，而Extension ClassLoader的Parent为Bootstrap ClassLoader。<br>加载一个类时，首先BootStrap进行寻找，找不到再由Extension ClassLoader寻找，最后才是App ClassLoader。</font>  

<h3 id="为什么要委托模型">为什么要委托模型</h3><p>将ClassLoader设计成委托模型的一个重要原因是出于<code>安全考虑</code>，比如在Applet中，如果编写了一个java.lang.String类并具有破坏性。假如不采用这种委托机制，就会将这个具有破坏性的String加载到了用户机器上，导致破坏用户安全。但采用这种委托机制则不会出现这种情况。因为要加载java.lang.String类时，系统最终会由Bootstrap进行加载，这个具有破坏性的String永远没有机会加载。  </p>
<hr>
<p>委托模型还带来了一些问题，在某些情况下会产生混淆，如下是Tomcat的ClassLoader结构图:  </p>
<pre><code>    Bootstrap 
      | 
    System 
      | 
    Common 
      |    
Catalina  Shared 
          |     
       Webapp1  Webapp2 <span class="keyword">...</span> 
</code></pre><p>由 Common 类装入器装入的类决不能（根据名称）直接访问由 Web 应用程序装入的类。使这些类联系在一起的唯一方法是通过使用这两个类集都可见的接口。在这个例子中，就是包含由 Java servlet 实现的 javax.servlet.Servlet。  </p>
<p>如果在lib或者lib/ext等类库有与应用中同样的类，那么应用中的类将无法被载入。通常在jdk新版本出现有类库移动时会出现问题，例如最初我们使用自己的xml解析器，而在jdk1.4中xml解析器变成标准类库，load的优先级也高于我们自己的xml解析器，我们自己的xml解析器永远无法找到，将可能导致我们的应用无法运行。  </p>
<p>相同的类，不同的ClassLoader，将导致ClassCastException异常  </p>
<hr>
<h3 id="线程中的ClassLoader">线程中的ClassLoader</h3><p> 每个运行中的线程都有一个成员<code>contextClassLoader</code>，用来在运行时动态地载入其它类，可以使用方法Thread.currentThread().setContextClassLoader(…);更改当前线程的contextClassLoader，来改变其载入类的行为；也可以通过方法Thread.currentThread().getContextClassLoader()来获得当前线程的ClassLoader。  </p>
<blockquote>
<p>实际上，在Java应用中所有程序都运行在线程里，如果在程序中没有手工设置过ClassLoader，对于一般的java类如下两种方法获得的ClassLoader通常都是同一个。</p>
</blockquote>
<p><code>this.getClass.getClassLoader()</code><br><code>Thread.currentThread().getContextClassLoader()</code></p>
<p>方法一得到的Classloader是静态的，表明类的载入者是谁；<br>方法二得到的Classloader是动态的，谁执行（某个线程），就是那个执行者的Classloader。<br><strong>对于单例模式的类，静态类等，载入一次后，这个实例会被很多程序（线程）调用，对于这些类，载入的Classloader和执行线程的Classloader通常都不同。</strong></p>
<h3 id="Web应用中的ClassLoader">Web应用中的ClassLoader</h3><p>回到上面的例子，在Tomcat里，WebApp的ClassLoader的工作原理有点不同，它先试图自己载入类（在ContextPath/WEB-INF/…中载入类），如果无法载入，再请求父ClassLoader完成。<br>由此可得：<br>对于WEB APP线程，它的contextClassLoader是WebAppClassLoader<br>对于Tomcat Server线程，它的contextClassLoader是CatalinaClassLoader  </p>
<p>获得ClassLoader的几种方法<br>可以通过如下3种方法得到ClassLoader：<br>this.getClass.getClassLoader(); // 使用当前类的ClassLoader<br>Thread.currentThread().getContextClassLoader(); // 使用当前线程的ClassLoader<br>ClassLoader.getSystemClassLoader(); // 使用系统ClassLoader，即系统的入口点所使用的ClassLoader。</p>
<blockquote>
<p>注意，system ClassLoader与根ClassLoader并不一样。JVM下system ClassLoader通常为App ClassLoader  </p>
</blockquote>
<h3 id="自定义ClassLoader">自定义ClassLoader</h3><ul>
<li>安全性<br>类进入JVM之前先经过ClassLoader，所以可以在这边检查是否有正确的数字签名等.  </li>
<li>加密<br>java字节码很容易被反编译，通过定制ClassLoader使得字节码先加密防止别人下载后反编译，这里的ClassLoader相当于一个动态的解码器  </li>
<li>归档<br>可能为了节省网络资源，对自己的代码做一些特殊的归档，然后用定制的ClassLoader来解档  </li>
<li>自展开程序<br>把java应用程序编译成单个可执行类文件，这个文件包含压缩的和加密的类文件数据，同时有一个固定的ClassLoader，当程序运行时它在内存中完全自行解开，无需先安装.  </li>
<li>动态生成<br>可以生成应用其他还未生成类的类，实时创建整个类并可在任何时刻引入JVM  </li>
</ul>
<h3 id="资源载入">资源载入</h3><p>所有资源都通过ClassLoader载入到JVM里，那么在载入资源时当然可以使用ClassLoader，只是对于不同的资源还可以使用一些别的方式载入，例如对于类可以直接new，对于文件可以直接做IO等。</p>
<h4 id="载入类">载入类</h4><p>假设有类A和类B，A在方法method里需要实例化B，可能的方法有3种。<br>对于载入类的情况，用户需要知道B类的完整名字（包括包名，例如”com.rain.B”)</p>
<ul>
<li><p>使用Class静态方法 Class.forName  </p>
<figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class <span class="keyword">cls</span> = Class.forName(<span class="string">"com.rain.B"</span>)<span class="comment">; </span></span><br><span class="line">B b = (B)<span class="keyword">cls</span>.newInstance()<span class="comment">;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用ClassLoader  </p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Step 1. Get ClassLoader */</span> </span><br><span class="line">ClassLoader <span class="keyword">cl</span>; <span class="comment">//具体获得ClassLoader </span></span><br><span class="line"><span class="comment">/* Step 2. Load the class */</span> </span><br><span class="line"><span class="keyword">Class</span> cls = <span class="keyword">cl</span>.loadClass(<span class="string">"com.rain.B"</span>); <span class="comment">// 使用第一步得到的ClassLoader来载入B </span></span><br><span class="line"><span class="comment">/* Step 3. new instance */</span> </span><br><span class="line">B b = (B)cls.newInstance(); <span class="comment">// 有B的类得到一个B的实例</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>直接new<br>  <code>B b = new B();</code> </p>
</li>
</ul>
<h4 id="文件载入">文件载入</h4><p>（例如配置文件等）假设在com.rain.A类里想读取文件夹 /com/rain/config 里的文件sys.properties，读取文件可以通过绝对路径或相对路径，绝对路径很简单，在Windows下以盘号开始，在Unix下以”/“开始<br>对于相对路径，<code>其相对值是相对于ClassLoader的</code>，<strong>因为ClassLoader是一棵树，所以这个相对路径和ClassLoader树上的任何一个ClassLoader相对比较后可以找到文件，那么文件就可以找到，</strong><font color="red">当然，读取文件也使用委托模型。</font>  </p>
<ul>
<li>直接IO  <figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/<span class="keyword">*</span><span class="keyword">*</span> </span><br><span class="line"> <span class="keyword">*</span> 假设当前位置是 <span class="string">"C:/test"</span>，通过执行如下命令来运行A <span class="string">"java com.rain.A"</span> </span><br><span class="line"> <span class="keyword">*</span> 1. 在程序里可以使用绝对路径，Windows下的绝对路径以盘号开始，Unix下以<span class="string">"/"</span>开始 </span><br><span class="line"> <span class="keyword">*</span> 2. 也可以使用相对路径，相对路径前面没有<span class="string">"/"</span> </span><br><span class="line"> <span class="keyword">*</span> 因为我们在 <span class="string">"C:/test"</span> 目录下执行程序，程序入口点是<span class="string">"C:/test"</span>，相对路径就 </span><br><span class="line"> <span class="keyword">*</span> 是 <span class="string">"com/rain/config/sys.properties"</span> </span><br><span class="line"> <span class="keyword">*</span> （例子中，当前程序的ClassLoader是App ClassLoader，system ClassLoader = 当前的 </span><br><span class="line"> <span class="keyword">*</span> 程序的ClassLoader，入口点是<span class="string">"C:/test"</span>） </span><br><span class="line"> <span class="keyword">*</span> 对于ClassLoader树，如果文件在jdk lib下，如果文件在jdk lib/ext下，如果文件在环境变量里， </span><br><span class="line"> <span class="keyword">*</span> 都可以通过相对路径<span class="string">"sys.properties"</span>找到，lib下的文件最先被找到 </span><br><span class="line"> <span class="keyword">*</span>/ </span><br><span class="line">File f = new File(<span class="string">"C:/test/com/rain/config/sys.properties"</span>); // 使用绝对路径 </span><br><span class="line">//File f = new File(<span class="string">"com/rain/config/sys.properties"</span>); // 使用相对路径 </span><br><span class="line">InputStream is = new FileInputStream(f);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>如果是配置文件，可以通过java.util.Properties.load(is)将内容读到Properties里，Properties默认认为is的编码是ISO-8859-1，如果配置文件是非英文的，可能出现乱码问题。 </p>
<ul>
<li>使用ClassLoader  </li>
</ul>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span><br><span class="line"> * 因为有3种方法得到ClassLoader，对应有如下3种方法读取文件 </span><br><span class="line"> * 使用的路径是相对于这个ClassLoader的那个点的相对路径，此处只能使用相对路径 </span><br><span class="line"> */</span> </span><br><span class="line">InputStream <span class="keyword">is</span> = <span class="literal">null</span>; </span><br><span class="line"><span class="keyword">is</span> = <span class="keyword">this</span>.getClass().getClassLoader().getResourceAsStream( </span><br><span class="line">       <span class="string">"com/rain/config/sys.properties"</span>); <span class="comment">//方法1 </span></span><br><span class="line"><span class="comment">//is = Thread.currentThread().getContextClassLoader().getResourceAsStream( </span></span><br><span class="line">       <span class="string">"com/rain/config/sys.properties"</span>); <span class="comment">//方法2 </span></span><br><span class="line"><span class="comment">//is = ClassLoader.getSystemResourceAsStream("com/rain/config/sys.properties"); //方法3</span></span><br></pre></td></tr></table></figure>
<p>如果是配置文件，可以通过java.util.Properties.load(is)将内容读到Properties里，这里要注意编码问题。  </p>
<ul>
<li>使用ResourceBundle  <figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ResourceBundle</span> bundle = ResourceBundle.getBoundle(<span class="string">"com.rain.config.sys"</span>);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>这种用法通常用来载入用户的配置文件，关于ResourceBunlde更详细的用法请参考其他文档<br>总结：有如下3种途径来载入文件  </p>
<pre><code><span class="number">1.</span> 绝对路径 <span class="comment">---&gt; IO </span>
<span class="number">2.</span> 相对路径 <span class="comment">---&gt; IO </span>
            <span class="comment">---&gt; ClassLoader </span>
<span class="number">3.</span> 资源文件 <span class="comment">---&gt; ResourceBundle </span>
</code></pre><h3 id="web应用里载入资源">web应用里载入资源</h3><p>在web应用里当然也可以使用ClassLoader来载入资源，但更常用的情况是使用ServletContex<br>用户程序通常在classes目录下，如果想读取classes目录里的文件，可以使用ClassLoader，如果想读取其他的文件，一般使用ServletContext.getResource()<br>如果使用ServletContext.getResource(path)方法，路径必须以”/“开始，路径被解释成相对于<code>ContextRoot</code>(<strong>web的根路径</strong>)的路径，此处载入文件的方法和ClassLoader不同</p>
<hr>
<h2 id="参考资料">参考资料</h2><p>ClassLoader 详解及用途 ,感谢作者，使得我第一次如此清楚的理解了类加载器机制！<br><a href="http://blog.chinaunix.net/uid-21227800-id-65885.html" target="_blank" rel="external">参考博客</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="ClassLoader作用">ClassLoader作用</h3><blockquote>
<p>ClassLoader负责载入系统的所有Resources（Class，文件，来自网络的字节流等），通过ClassLoader从而将资源载入JVM。<br>Class]]>
    </summary>
    
      <category term="ClassLoader，类加载器" scheme="http://donahue-ldz.github.io/tags/ClassLoader%EF%BC%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/"/>
    
      <category term="spring源码学习" scheme="http://donahue-ldz.github.io/categories/spring%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[NIO Buffer和Channel]]></title>
    <link href="http://donahue-ldz.github.io/2015/03/25/NIO-Buffer%E5%92%8CChannel/"/>
    <id>http://donahue-ldz.github.io/2015/03/25/NIO-Buffer和Channel/</id>
    <published>2015-03-25T14:57:08.000Z</published>
    <updated>2015-03-25T15:10:41.000Z</updated>
    <content type="html"><![CDATA[<p>所有语言运行时系统提供执行I/O较高级别的工具。</p>
<p>在java编程中，标准低版本IO使用流的方式完成I/O操作，所有的I/O都被视为单个的字节流动，称为一个Stream的对象一次移动一个字节。</p>
<p>NIO是在JDK1.4之后出现的一种新的IO，sun官方标榜的nio有如下特性：</p>
<blockquote>
<ul>
<li>为所有的原始类型提供（Buffer）缓存支持</li>
<li>字符集编码解决方案（Charset）</li>
<li>Channel : 一个新的原始I/O抽象</li>
<li>支持锁和内存映射文件的文件访问接口</li>
<li>提供多路（non-bloking）非阻塞式的高伸缩性网路I/O</li>
</ul>
</blockquote>
<p>NIO包（java.nio.*）引入了四个关键的抽象数据类型，它们共同解决传统的I/O类中的一些问题。</p>
<ol>
<li>Buffer：它是包含数据且用于读写的线形表结构。其中还提供了一个特殊类用于内存映射文件的I/O操作。<br>2． Charset：它提供Unicode字符串影射到字节序列以及逆影射的操作。<br>3． Channels：包含socket，file和pipe三种管道，它实际上是双向交流的通道。<br>4． Selector：它将多元异步I/O操作集中到一个或多个线程中。</li>
</ol>
<hr>
<p>本文先介绍chanel和buffer(通道和缓冲)</p>
<p><code>缓冲区和通道是NIO中的核心对象</code>，通道Channel是对原IO中流的模拟，所有数据都要通过通道进行传输；Buffer实质上是一个容器对象，发送给通道的所有对象都必须首先放到一个缓冲区中。</p>
<h3 id="Buffer是什么？">Buffer是什么？</h3><p>Bufer是一个对象，它包含要写入或者刚读出的数据。这是NIO与IO的一个重要区别，在面向流的I/O中您将数据直接写入或者将数据直接读到stream中。<br>在 NIO 库中，<code>所有数据都是用缓冲区处理的</code>。在读取数据时，它是直接读到缓冲区中的。在写入数据时，它是写入到缓冲区中的。任何时候访问NIO中的数据，您都是将它放到缓冲区中。</p>
<p><code>缓冲区实质上是一个数组</code>。通常它是一个字节数组，但是也可以使用其他种类的数组。<strong>但是一个缓冲区不仅仅是一个数组。缓冲区提供了对数据的结构化访问，而且还可以跟踪系统的读/写进程</strong>。</p>
<blockquote>
<p>简单的说Buffer是：一块连续的内存块，是NIO数据读或写的中转地。</p>
</blockquote>
<h3 id="Buffer的类图结构">Buffer的类图结构</h3><p><img src="/img/buffer.gif" alt="Alt Buffer类图"></p>
<p>Buffer在JDK中是如何实现的？</p>
<blockquote>
<p>JDK源码可以知道，Buffer类是一个抽象类，其中有五个属性，分别是mark、position、limit、capacity、address。并且可以看到这样一行注释：<br><code>//Invariants:mark&lt;=position&lt;=limit&lt;=capacity</code></p>
</blockquote>
<p>一个 buffer 主要由 position、limit、capacity 三个变量来控制读写的过程。这三个变量在读和写时分别代表的含义如下：<br><code>position    当前写入/读取的单位数据的数量</code><br><code>limit    代表最多能写入/读取多少单位的数据量，默认和capacity一致</code><br><code>capacity    Buffer的容量</code></p>
<p>Buffer抽象类并没有指定Buffer的实现方式，看其子类可以发现，比如ByteBuffer中多出几个属性<br><code>其中有个final byte[]类型的属性，可知Buffer其实是用数组实现的。</code></p>
<h3 id="Buffer中的一些方法？">Buffer中的一些方法？</h3><p>最基本的对应属性操作的方法，在JDK中不是使用set和get方法，查看源码知道要得到当前Buffer的limit值使用<br><code>public final int limit()</code>方法，<br>设定limit的值使用<br><code>public final Buffer limit(int)</code>方法，其它属性有对应的方法。</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用于将写模式转换成读模式</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="function">Buffer <span class="title">flip</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    limit = position;    <span class="comment">//将limit设置为刚才写入的位置</span></span><br><span class="line">    position = <span class="number">0</span>;         <span class="comment">//将position设置为0从头开始读</span></span><br><span class="line">    mark = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//用于清空缓冲区(并不是真正的清除里面的数据)</span></span><br><span class="line"><span class="comment">//准备再次被写入，limit设置为capacity，position设置为0</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> Buffer clear() : </span><br><span class="line"></span><br><span class="line">//源码实现为position=0,mark=-1。目的是为了重复读。</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> Buffer rewind() : </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> remaining() : //一句代码<span class="keyword">return</span> limit – position;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> hasRemaining() : //一句代码<span class="keyword">return</span> limit &gt; position;</span><br></pre></td></tr></table></figure>
<h3 id="ByteBuffer类">ByteBuffer类</h3><p>首先可以看到在ByteBuffer类中多了三个属性，一个byte数组型的，一个int型的offset，还有一个boolean型的isReadOnly，两个构造函数均是Package-private型的。</p>
<p>可以使用一下方法产生一个ByteBuffer对象：</p>
<ul>
<li>(新建一个buffer)：ByteBuffer bbuf = ByteBuffer.allocate(1024);</li>
</ul>
<p>查看源码知道allocate执行这样一句话：<br><code>return new HeapByteBuffer(int capacity, int capacity);</code></p>
<p>而HeapByteBuffer又是ByteBuffer的子类，并且在HeapByteBuffer的构造方法中执行的是这样一个语句：<br><code>super(-1, 0, lim, cap, new byte[cap], 0);</code></p>
<p>也就是说调用的还是ByteBuffer中的构造方法，包范围内使用。这个方法做了如下工作，首先调用Buffer的构造方法，依次初始化mark、position、limit、capacity，然后初始化ByteBuffer的属性byte数组，接着初始offset，这样使用allocate方法就可以构造出一个ByteBuffer对象了。</p>
<ul>
<li>(对一个存在的buffer进行wrap)：ByteBuffer bbuf = ByteBuffer.wrap(new Byte[1024] array, 0, 1024);</li>
</ul>
<p>这个方法比较好用的一点是当这个Byte数组已经存在的话，直接传入这个Byte数组，然后传入起始值和结束值即可。默认wrap实现是初始值传入为0，结束值传入为Byte数组的长度array.length。</p>
<hr>
<p>ByteBuffer类中其它重要方法：</p>
<p>取出:(将数据读入byte数组中)get(byte[] dst) 或者 get(byte[] dst, int offset, int len)<br>（该方法是用来获取当前ByteBuffer中的指定位置的数据并赋值给dst，最终返回当前对象本身。方法实现时第一步检查参数是否合法，调用的是checkBounds静态包范围私有方法。然后检查len是否大于remaining，接着对dst数组循环赋值，最终返回该对象。）</p>
<p>放入(将数组中的内容放在buffer中)put(byte[] src) 或者 put(byte[] src, int offerset, int len)</p>
<p>（该方法和上面的一对get方法类似，功能是将已有的byte数组从0位置开始放入当前的ByteBuffer中，最终返回ByteBuffer本身。）<br>put(ByteBuffer src)</p>
<p>（该方法将src的remaining逐个放入当前ByteBuffer中，最终返回当前ByteBuffer。）<br>除此之外还有类型化的get方法，例如getInt(), getFloat(), getShort()等。</p>
<h3 id="Buffer的更多内容？">Buffer的更多内容？</h3><p>缓冲区分片：slice()方法根据现有的缓冲区创建一种子缓冲区，新的缓冲区与原缓冲区共享部分数据。</p>
<p>只读缓冲区：可以通过调用缓冲区的 asReadOnlyBuffer() 方法，将任何常规缓冲区转换为只读缓冲区，这个方法返回一个与原缓冲区完全相同的缓冲区(并与其共享数据)，只不过它是只读的。只读缓冲区对于保护数据很有用。没有办法将只读缓冲区改变为可写的。</p>
<p>下面例子对缓冲区进行分片，并操作数据：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//产生一个ByteBuffer实例</span></span><br><span class="line">ByteBuffer buffer = ByteBuffer.allocate( <span class="number">10</span> );</span><br><span class="line"></span><br><span class="line"><span class="comment">//对该ByteBuffer实例进行初始化</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;buffer.capacity(); ++i) &#123;</span><br><span class="line">buffer.put( (<span class="keyword">byte</span>)i );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//修改buffer的position（起点）和limit（终点）</span></span><br><span class="line"></span><br><span class="line">buffer.position( <span class="number">3</span> );</span><br><span class="line"></span><br><span class="line">buffer.limit( <span class="number">7</span> );</span><br><span class="line"></span><br><span class="line"><span class="comment">//对缓冲区进行分片</span></span><br><span class="line"></span><br><span class="line">ByteBuffer slice = buffer.slice();</span><br><span class="line"></span><br><span class="line"><span class="comment">//对分片的数据进行操作</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;slice.capacity(); ++i) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">byte</span> b = slice.<span class="keyword">get</span>( i );</span><br><span class="line"></span><br><span class="line">b *= <span class="number">11</span>;</span><br><span class="line"></span><br><span class="line">slice.put( i, b );</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重新定位并输出结果</span></span><br><span class="line"></span><br><span class="line">buffer.position( <span class="number">0</span> );</span><br><span class="line"></span><br><span class="line">buffer.limit( buffer.capacity() );</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (buffer.remaining()&gt;<span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">System.<span class="keyword">out</span>.println( buffer.<span class="keyword">get</span>() );</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>直接或者间接缓冲区：直接缓冲区可以加快I/O的读写速度，使用allocateDirect(int capacity)产生一个直接缓冲区。</p>
<p>内存映射文件(将文件中的部分内容映射到内存中,加快读写)：下面代码将一个 FileChannel (它的全部或者部分)映射到内存</p>
<p>中。将文件的前1024个字节映射到内存中：</p>
<p><code>MappedByteBuffer mbb = fc.map( FileChannel.MapMode.READ_WRITE, 0, 1024 );</code></p>
<h3 id="Channel是什么？">Channel是什么？</h3><p><img src="/img/Channels.gif" alt="Alt Buffer类图"><br>Channel 是一个对象，可以通过它读取和写入数据(直接和底层的IO支持抽象)。拿 NIO 与原来的 I/O 做个比较，通道就像是流。</p>
<p>正如前面提到的，所有数据都通过 Buffer 对象来处理。您永远不会将字节直接写入通道中，相反，您是将数据写入包含一个或者多个字节的缓冲区。同样，您不会直接从通道中读取字节，而是将数据从通道读入缓冲区，再从缓冲区获取这个字节。</p>
<p>简单的说Channel是：数据的源头或者数据的目的地(写入就是目的地,读取就是源头,直接和底层IO交道)，用于向buffer提供数据或者读取buffer数据，并且对I/O提供异步支持。</p>
<h3 id="Channel的类图结构？">Channel的类图结构？</h3><p>java.nio.channels.Channel是一个公共的接口，所有子Channel均实现了该接口<br>在java.nio.channels包中还实现了Channels、FileLock、SelectionKey、Selector、Pipe等比较好用的类。</p>
<p><code>channel包含三种分别是包含socket，file和pipe三种管道，它实际上是双向交流的通道</code>。</p>
<p>Channel在JDK中是如何实现的？</p>
<p>在Channel接口中共定义了两个方法</p>
<p><code>public boolean isOpen();   //Tells whether or not this channel is open</code></p>
<p><code>public void close() throws IOException();     //Close this channel</code></p>
<h4 id="FileChannel">FileChannel</h4><p>使用以下三个方法可以得到一个FileChannel的实例</p>
<blockquote>
<p>FileInputStream.getChannel()<br>FileOutputStream.getChannel()<br>RandomAccessFile.getChannel()</p>
</blockquote>
<p>上面提到Channel是数据的源头或者数据的目的地，用于向buffer提供数据或者从buffer读取数据。那么在实现了该接口的子类中应该有相应的read和write方法。</p>
<p>在FileChannel中有以下方法可以使用：</p>
<blockquote>
<p>public long read(ByteBuffer[] dsts)<br>//Reads a sequence of bytes from this channel into the given buffers.<br>public long write(ByteBuffer[] srcs)<br>//Writes a sequence of bytes to this channel from the given buffers.</p>
</blockquote>
<h4 id="文件锁定">文件锁定</h4><p>FileChannel提供两种方法获得FileLock</p>
<blockquote>
<p>FileLock lock();<br>FileLock lock(long position, long size, boolean size);</p>
</blockquote>
<p>要获取文件的一部分上的锁，您要调用一个打开的 FileChannel 上的 lock() 方法。<code>注意，如果要获取一个排它锁，您必须以写方式打开文件</code>。<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">RandomAccessFile raf = new RandomAccessFile( “filelocks.txt”, “rw” );</span><br><span class="line"></span><br><span class="line">FileChannel fc = raf.getChannel();</span><br><span class="line"></span><br><span class="line">FileLock <span class="operator"><span class="keyword">lock</span> = fc.<span class="keyword">lock</span>( <span class="keyword">start</span>, <span class="keyword">end</span>, <span class="literal">false</span> );</span></span><br><span class="line"></span><br><span class="line">//原始Stream获取channel,然后获取channel的FileLock</span><br><span class="line">//然后操作FileLock的<span class="operator"><span class="keyword">Lock</span>和<span class="keyword">release</span></span><br><span class="line">//在拥有锁之后，您可以执行需要的任何敏感操作，然后再释放锁：</span><br><span class="line"></span><br><span class="line"><span class="keyword">lock</span>.<span class="keyword">release</span>();</span></span><br></pre></td></tr></table></figure></p>
<h4 id="SocketChannel">SocketChannel</h4><p>使用以下两个方法得到一个SocketChannel的实例</p>
<blockquote>
<p>SocketChannel.open();      //打开一个socket channel<br>SocketChannel.open(SocketAddress remote);</p>
</blockquote>
<p>//调用上面的方法，并connect(remote)<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">InetSocketAddress socketAddress = newbInetSocketAddress(“www.baidu.<span class="keyword">com</span>”,<span class="number">80</span>);</span><br><span class="line"></span><br><span class="line">SocketChannel sc = SocketChannel.<span class="keyword">open</span>(socketAddress);</span><br><span class="line"></span><br><span class="line">sc.<span class="keyword">read</span>(<span class="keyword">buffer</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">buffer</span>.flip();</span><br><span class="line"></span><br><span class="line"><span class="keyword">buffer</span>.clear();</span><br><span class="line"></span><br><span class="line">sc.<span class="keyword">write</span>(bufer);</span><br></pre></td></tr></table></figure></p>
<h4 id="DatagramChannel">DatagramChannel</h4><p>与其它的Channel有相同或者相似的方法。</p>
<hr>
<h2 id="参考资料">参考资料</h2><p><a href="https://www.ibm.com/developerworks/java/tutorials/j-nio/" target="_blank" rel="external">Java nio入门教程 IBM开发者园地</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>所有语言运行时系统提供执行I/O较高级别的工具。</p>
<p>在java编程中，标准低版本IO使用流的方式完成I/O操作，所有的I/O都被视为单个的字节流动，称为一个Stream的对象一次移动一个字节。</p>
<p>NIO是在JDK1.4之后出现的一种新的IO，sun官]]>
    </summary>
    
      <category term="Buffer" scheme="http://donahue-ldz.github.io/tags/Buffer/"/>
    
      <category term="Channel" scheme="http://donahue-ldz.github.io/tags/Channel/"/>
    
      <category term="NIO" scheme="http://donahue-ldz.github.io/tags/NIO/"/>
    
      <category term="java" scheme="http://donahue-ldz.github.io/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[spring多事务管理]]></title>
    <link href="http://donahue-ldz.github.io/2015/03/15/spring%E5%A4%9A%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/"/>
    <id>http://donahue-ldz.github.io/2015/03/15/spring多事务管理/</id>
    <published>2015-03-15T02:01:36.000Z</published>
    <updated>2015-03-15T02:16:11.000Z</updated>
    <content type="html"><![CDATA[<p>最近在梳理项目的时候对事务控制进行了梳理，深入了解了spring的事务，结合相关资料整理如下</p>
<hr>
<p>Spring抽象的DAO体系兼容多种数据访问技术，它们各有特色，各有千秋。像Hibernate是非常优秀的ORM实现方案，但对底层SQL的控制不太方便；而iBatis则通过模板化技术让你方便地控制SQL，但没有Hibernate那样高的开发效率；自由度最高的当然是直接使用SpringJDBC了，但它也是底层的，灵活的代价是代码的繁复。很难说哪种数据访问技术是最优秀的，只有在某种特定的场景下才能给出答案。</p>
<blockquote>
<p>所以在一个应用中，往往采用多个数据访问技术：一般是两种，一种采用ORM技术框架，而另一种采用偏JDBC的底层技术，两者珠联璧合，形成联合军种，共同御敌。 </p>
</blockquote>
<p>但是，这种联合军种如何应对事务管理的问题呢？我们知道Spring为每种数据访问技术提供了相应的事务管理器，难道需要分别为它们配置对应的事务管理器吗？它们到底是如何协作和工作的呢？这些层出不穷的问题往往压制了开发人员使用联合军种的想法。<br>其实，在这个问题上，我们低估了Spring事务管理的能力。如果你采用了一个高端ORM技术（Hibernate、JPA、JDO），同时采用一个JDBC技术（Spring JDBC、iBatis），由于前者的会话（Session）是对后者连接（Connection）的封装，Spring会“足够智能地”在同一个事务线程让前者的会话封装后者的连接。所以，我们只要直接采用前者的事务管理器就可以了。</p>
<blockquote>
<p>组合: Hibernate+ Spring JDBC或iBatis<br>事务管理: org.springframework.orm.hibernate3.HibernateTransactionManager</p>
<p>组合: JPA+Spring JDBC或iBatis<br>事务管理: org.springframework.orm.jpa.JpaTransactionManager</p>
<p>组合：JDO+Spring JDBC或iBatis<br>事务管理：org.springframework.orm.jdo.JdoTransactionManager</p>
</blockquote>
<hr>
<p>举例：<br><code>Hibernate+Spring JDBC混合框架的事务管理</code>                </p>
<p>由于一般不会出现同时使用多个ORM框架的情况（如Hibernate+JPA），我们不拟对此命题展开论述，只重点研究ORM框架+JDBC框架的情况。Hibernate+Spring JDBC可能是被使用得最多的组合，本节我们通过实例观察事务管理的运作情况。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Service</span>(<span class="string">"userService"</span>)  </span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">BaseService</span> &#123;</span>  </span><br><span class="line">    <span class="annotation">@Autowired</span>  </span><br><span class="line">    <span class="keyword">private</span> <span class="type">HibernateTemplate</span> hibernateTemplate;  </span><br><span class="line">  </span><br><span class="line">    <span class="annotation">@Autowired</span>  </span><br><span class="line">    <span class="keyword">private</span> <span class="type">ScoreService</span> scoreService;  </span><br><span class="line">  </span><br><span class="line">    public void logon(<span class="type">String</span> userName) &#123;  </span><br><span class="line">         </span><br><span class="line">        <span class="comment">//①通过Hibernate技术访问数据  </span></span><br><span class="line">        <span class="type">System</span>.out.println(<span class="string">"before updateLastLogonTime().."</span>);  </span><br><span class="line">        updateLastLogonTime(userName);  </span><br><span class="line">        <span class="type">System</span>.out.println(<span class="string">"end updateLastLogonTime().."</span>);  </span><br><span class="line">          </span><br><span class="line">        <span class="comment">//②通过JDBC技术访问数据  </span></span><br><span class="line">        <span class="type">System</span>.out.println(<span class="string">"before scoreService.addScore().."</span>);  </span><br><span class="line">        scoreService.addScore(userName, <span class="number">20</span>);  </span><br><span class="line">        <span class="type">System</span>.out.println(<span class="string">"end scoreService.addScore().."</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    public void updateLastLogonTime(<span class="type">String</span> userName) &#123;  </span><br><span class="line">        <span class="type">User</span> user = hibernateTemplate.get(<span class="type">User</span>.<span class="keyword">class</span>,userName);  </span><br><span class="line">        user.setLastLogonTime(<span class="type">System</span>.currentTimeMillis());  </span><br><span class="line">        hibernateTemplate.update(user);  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">//③这句很重要，请看下文的分析  </span></span><br><span class="line">        hibernateTemplate.flush();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>①处，使用Hibernate操作数据<br>②处调用ScoreService#addScore()，该方法内部使用Spring JDBC操作数据。<br>③处，我们显式调用了flush()方法，将Session中的缓存同步到数据库中（即马上向数据库发送一条更新记录的SQL语句）。之所以要显式执行flush()方法，原因是在默认情况下，Hibernate对数据的更改只是记录在一级缓存中，要等到事务提交或显式调用flush()方法时才会将一级缓存中的数据同步到数据库中，而提交事务的操作发生在logon()方法返回前。如果所有针对数据库的更改操作都使用Hibernate，这种数据同步的延迟机制并不会产生任何问题。但是，我们在logon()方法中同时采用了Hibernate和SpringJDBC混合数据访问技术，Spring JDBC无法自动感知Hibernate一级缓存，所以如果不及时调用flush()方法将记录数据更改的一级缓存同步到数据库中，则②处通过SpringJDBC进行数据更改的结果将被Hibernate一级缓存中的更改覆盖掉，因为Hibernate一级缓存要等到logon()方法返回前才同步到数据库！<br>ScoreService使用Spring JDBC数据访问技术，其代码如下所示：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.<span class="type">Autowired</span>;  </span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.core.<span class="type">JdbcTemplate</span>;  </span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.<span class="type">Service</span>;  </span><br><span class="line"><span class="keyword">import</span> org.apache.commons.dbcp.<span class="type">BasicDataSource</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="annotation">@Service</span>(<span class="string">"scoreService"</span>)  </span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">ScoreService</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">BaseService</span>&#123;</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="annotation">@Autowired</span>  </span><br><span class="line">    <span class="keyword">private</span> <span class="type">JdbcTemplate</span> jdbcTemplate;  </span><br><span class="line">  </span><br><span class="line">    public void addScore(<span class="type">String</span> userName, int toAdd) &#123;  </span><br><span class="line">        <span class="type">String</span> sql = <span class="string">"UPDATE t_user u SET u.score = u.score + ? WHERE user_name =?"</span>;  </span><br><span class="line">        jdbcTemplate.update(sql, toAdd, userName);  </span><br><span class="line">        <span class="type">BasicDataSource</span> basicDataSource = (<span class="type">BasicDataSource</span>) jdbcTemplate.getDataSource();  </span><br><span class="line">        <span class="comment">//①查看此处数据库激活的连接数量  </span></span><br><span class="line">        <span class="type">System</span>.out.println(<span class="string">"[scoreUserService.addScore]激活连接数量："</span>  </span><br><span class="line">                         +basicDataSource.getNumActive());  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Spring关键的配置文件代码如下所示：<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--①使用<span class="type">Hibernate</span>事务管理器 --&gt;  </span><br><span class="line">&lt;bean id=<span class="string">"hiberManager"</span>  </span><br><span class="line">      class=<span class="string">"org.springframework.orm.hibernate3.HibernateTransactionManager"</span>  </span><br><span class="line">      p:sessionFactory-<span class="keyword">ref</span>=<span class="string">"sessionFactory"</span>/&gt;  </span><br><span class="line">  </span><br><span class="line">&lt;!--②使<span class="type">UserService</span>及<span class="type">ScoreService</span>的公用方法都拥有事务 --&gt;  </span><br><span class="line">&lt;aop:config proxy-target-class=<span class="string">"true"</span>&gt;  </span><br><span class="line">    &lt;aop:pointcut id=<span class="string">"serviceJdbcMethod"</span>  </span><br><span class="line">                  expression=<span class="string">"within(com.baobaotao.mixdao.BaseService+)"</span>/&gt;  </span><br><span class="line">    &lt;aop:advisor pointcut-<span class="keyword">ref</span>=<span class="string">"serviceJdbcMethod"</span>  </span><br><span class="line">                 advice-<span class="keyword">ref</span>=<span class="string">"hiberAdvice"</span>/&gt;  </span><br><span class="line">&lt;/aop:config&gt;  </span><br><span class="line">&lt;tx:advice id=<span class="string">"hiberAdvice"</span> transaction-manager=<span class="string">"hiberManager"</span>&gt;  </span><br><span class="line">    &lt;tx:attributes&gt;  </span><br><span class="line">        &lt;tx:<span class="keyword">method</span> name=<span class="string">"*"</span>/&gt;  </span><br><span class="line">    &lt;/tx:attributes&gt;  </span><br><span class="line">&lt;/tx:advice&gt;  </span><br><span class="line">  </span><br><span class="line">/beans&gt;</span><br></pre></td></tr></table></figure></p>
<p>启动Spring容器，执行UserService#logon()方法，可以查看到如下的执行日志：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">before userService.logon().. </span><br><span class="line"></span><br><span class="line">①在执行userService.logon()后，Spring开启一个事务 </span><br><span class="line">Creating new transaction with name [com.baobaotao.mixdao.UserService.logon]: PROPAGATION_REQUIRED,ISOLATION_DEFAULT </span><br><span class="line">opened session at timestamp: 13009379637 </span><br><span class="line">Opened new Session [org.hibernate.impl.SessionImpl@c5f468] for Hibernate transaction </span><br><span class="line">… </span><br><span class="line">Exposing Hibernate transaction as JDBC transaction [jdbc:mysql://localhost:3306/sampledb, UserName=root@localhost, MySQL-AB JDBC Driver] </span><br><span class="line">before userService.updateLastLogonTime().. </span><br><span class="line"></span><br><span class="line">②userService.updateLastLogonTime()执行时自动绑定到①处开启的Session中 </span><br><span class="line">Found thread-bound Session for HibernateTemplate </span><br><span class="line">loading entity: [com.baobaotao.User#tom] </span><br><span class="line">about to open PreparedStatement (open PreparedStatements: 0, globally: 0) </span><br><span class="line">… </span><br><span class="line">about to close PreparedStatement (open PreparedStatements: 1, globally: 1) </span><br><span class="line">Not closing pre-bound Hibernate Session after HibernateTemplate </span><br><span class="line"><span class="operator"><span class="keyword">end</span> updateLastLogonTime().. </span><br><span class="line"></span><br><span class="line"><span class="keyword">before</span> scoreService.addScore().. </span><br><span class="line"></span><br><span class="line">③scoreService.addScore()执行时绑定到①处开启的<span class="keyword">Session</span>中，并加入其所对应的事务中 </span><br><span class="line"><span class="keyword">Found</span> thread-bound <span class="keyword">Session</span> [org.hibernate.impl.SessionImpl@c5f468] <span class="keyword">for</span> Hibernate </span><br><span class="line"><span class="keyword">transaction</span> </span><br><span class="line">Participating <span class="keyword">in</span> existing <span class="keyword">transaction</span> </span><br><span class="line">… </span><br><span class="line"><span class="keyword">SQL</span> <span class="keyword">update</span> affected <span class="number">1</span> <span class="keyword">rows</span> </span><br><span class="line"></span><br><span class="line">④此时数据源只打开了一个连接 </span><br><span class="line">[scoreUserService.addScore]激活连接数量：<span class="number">1</span> </span><br><span class="line"><span class="keyword">end</span> scoreService.addScore().. </span><br><span class="line">Initiating <span class="keyword">transaction</span> <span class="keyword">commit</span> </span><br><span class="line"></span><br><span class="line">⑤提交Hibernate的事务，它将触发一级缓存到数据库的同步 </span><br><span class="line">Committing Hibernate <span class="keyword">transaction</span> <span class="keyword">on</span> <span class="keyword">Session</span> [org.hibernate.impl.SessionImpl@c5f468] </span><br><span class="line"><span class="keyword">commit</span> </span><br><span class="line">processing <span class="keyword">flush</span>-<span class="keyword">time</span> cascades </span><br><span class="line">dirty checking collections </span><br><span class="line">Flushed: <span class="number">0</span> insertions, <span class="number">0</span> updates, <span class="number">0</span> deletions <span class="keyword">to</span> <span class="number">1</span> objects </span><br><span class="line">Flushed: <span class="number">0</span> (re)creations, <span class="number">0</span> updates, <span class="number">0</span> removals <span class="keyword">to</span> <span class="number">0</span> collections </span><br><span class="line">listing entities: </span><br><span class="line">com.baobaotao.<span class="keyword">User</span>&#123;lastLogonTime=<span class="number">1300937963882</span>, score=<span class="number">10</span>, userName=tom, <span class="keyword">password</span>=<span class="number">123456</span>&#125; </span><br><span class="line">re-enabling autocommit </span><br><span class="line"></span><br><span class="line">⑥提效<span class="keyword">Session</span>底层所绑定的JDBC <span class="keyword">Connection</span>所对应的事务 </span><br><span class="line">committed JDBC <span class="keyword">Connection</span> </span><br><span class="line"><span class="keyword">transaction</span> completed <span class="keyword">on</span> <span class="keyword">session</span> <span class="keyword">with</span> on_close <span class="keyword">connection</span> <span class="keyword">release</span> <span class="keyword">mode</span>;</span> be sure to close the session to <span class="operator"><span class="keyword">release</span> JDBC resources! </span><br><span class="line">Closing Hibernate <span class="keyword">Session</span> [org.hibernate.impl.SessionImpl@c5f468] <span class="keyword">after</span> <span class="keyword">transaction</span> </span><br><span class="line">Closing Hibernate <span class="keyword">Session</span> </span><br><span class="line">releasing JDBC <span class="keyword">connection</span> [ (<span class="keyword">open</span> PreparedStatements: <span class="number">0</span>, globally: <span class="number">0</span>) (<span class="keyword">open</span> ResultSets: <span class="number">0</span>, globally: <span class="number">0</span>)] </span><br><span class="line"><span class="keyword">transaction</span> completed <span class="keyword">on</span> <span class="keyword">session</span> <span class="keyword">with</span> on_close <span class="keyword">connection</span> <span class="keyword">release</span> <span class="keyword">mode</span>;</span> be sure to close the session to <span class="operator"><span class="keyword">release</span> JDBC resources! </span><br><span class="line"><span class="keyword">after</span> userService.logon()..</span></span><br></pre></td></tr></table></figure></p>
<p>仔细观察这段输出日志，<br>①处UserService#logon()开启一个新的事务。<br>②处的UserService# updateLastLogonTime()绑定到事务上下文的Session中。<br>③处ScoreService#addScore()方法加入到①处开启的事务上下文中。<br>④处的输出是ScoreService#addScore()方法内部的输出信息，汇报此时数据源激活的连接数为1，这清楚地告诉我们Hibernate和JDBC这两种数据访问技术在同一事务上下文中“共用”一个连接。<br>⑤处，提交Hibernate事务，接着在⑥处触发调用底层的Connection提交事务。 </p>
<p>从以上的运行结果，我们可以得出这样的结论：使用Hibernate事务管理器后，可以混合使用Hibernate和SpringJDBC数据访问技术，它们将工作于同一事务上下文中。但是使用SpringJDBC访问数据时，Hibernate的一级或二级缓存得不到同步，此外，一级缓存延迟数据同步机制可能会覆盖SpringJDBC数据更改的结果。 </p>
<p>   由于混合数据访问技术方案存在“事务同步而缓存不同步”的情况，所以最好用Hibernate进行读写操作，而只用Spring JDBC进行读操作。如用Spring JDBC进行简要列表的查询，而用Hibernate对查询出的数据进行维护。<br>   如果确实要同时使用Hibernate和SpringJDBC读写数据，则必须充分考虑到Hibernate缓存机制引发的问题：必须整体分析数据维护逻辑，根据需要及时调用Hibernate的flush()方法，以免覆盖Spring JDBC的更改，在Spring JDBC更改数据库时，维护Hibernate的缓存。由于方法调用顺序的不同都可能影响数据的同步性，因此很容易发生问题，这会极大提高数据访问程序的复杂性。所以笔者郑重建议不要同时使用Spring JDBC和Hibernate对数据进行写操作。 </p>
<blockquote>
<p>可以将以上结论推广到其他混合数据访问技术的方案中，如Hibernate+iBatis、JPA+Spring JDBC、JDO+Spring JDBC等。 </p>
</blockquote>
<p>参考资料：《Spring 3.x企业应用开发实战》</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>最近在梳理项目的时候对事务控制进行了梳理，深入了解了spring的事务，结合相关资料整理如下</p>
<hr>
<p>Spring抽象的DAO体系兼容多种数据访问技术，它们各有特色，各有千秋。像Hibernate是非常优秀的ORM实现方案，但对底层SQL的控制不太方便；而i]]>
    </summary>
    
      <category term="spring" scheme="http://donahue-ldz.github.io/tags/spring/"/>
    
      <category term="事务管理" scheme="http://donahue-ldz.github.io/tags/%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/"/>
    
      <category term="spring" scheme="http://donahue-ldz.github.io/categories/spring/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[redis持久化]]></title>
    <link href="http://donahue-ldz.github.io/2015/03/14/redis%E6%8C%81%E4%B9%85%E5%8C%96/"/>
    <id>http://donahue-ldz.github.io/2015/03/14/redis持久化/</id>
    <published>2015-03-14T12:14:23.000Z</published>
    <updated>2015-03-14T12:24:58.000Z</updated>
    <content type="html"><![CDATA[<h2 id="redis持久化">redis持久化</h2><p>redis提供了两种持久化的方式，分别是RDB（Redis DataBase）和AOF（Append Only File）。</p>
<blockquote>
<p>如果你没有数据持久化的需求，也完全可以关闭RDB和AOF方式，这样的话，redis将变成一个纯内存数据库，就像memcache一样。</p>
</blockquote>
<hr>
<h3 id="redis持久化_–_RDB">redis持久化 – RDB</h3><p>RDB方式，是将redis某一时刻的数据持久化到磁盘中，是一种快照式的持久化方法。</p>
<p>redis在进行数据持久化的过程中，会先将数据写入到一个临时文件中，待持久化过程都结束了，才会用这个临时文件替换上次持久化好的文件。正是这种特性，让我们可以随时来进行备份，因为快照文件总是完整可用的。</p>
<blockquote>
<p>对于RDB方式，redis会单独创建（fork）一个子进程来进行持久化，而主进程是不会进行任何IO操作的，这样就确保了redis极高的性能。</p>
</blockquote>
<p>如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那RDB方式要比AOF方式更加的高效。</p>
<p>虽然RDB有不少优点，但它的缺点也是不容忽视的。如果你对数据的完整性非常敏感，那么RDB方式就不太适合你，因为即使你每5分钟都持久化一次，当redis故障时，仍然会有近5分钟的数据丢失。所以，redis还提供了另一种持久化方式，那就是AOF。</p>
<hr>
<h3 id="redis持久化_–_AOF">redis持久化 – AOF</h3><p>AOF，英文是Append Only File，即只允许追加不允许改写的文件。</p>
<p>如前面介绍的，AOF方式是将执行过的写指令记录下来，在数据恢复时按照从前到后的顺序再将指令都执行一遍，就这么简单。</p>
<p>我们通过配置redis.conf中的appendonly yes就可以打开AOF功能。如果有写操作（如SET等），redis就会被追加到AOF文件的末尾。</p>
<blockquote>
<p>默认的AOF持久化策略是每秒钟fsync一次（fsync是指把缓存中的写指令记录到磁盘中），因为在这种情况下，redis仍然可以保持很好的处理性能，即使redis故障，也只会丢失最近1秒钟的数据。</p>
</blockquote>
<p>如果在追加日志时，恰好遇到磁盘空间满、inode满或断电等情况导致日志写入不完整，也没有关系，redis提供了<code>redis-check-aof</code>工具，可以用来进行日志修复。</p>
<p>因为采用了追加方式，如果不做任何处理的话，AOF文件会变得越来越大，为此，redis提供了AOF文件重写（rewrite）机制，即当AOF文件的大小超过所设定的阈值时，redis就会启动AOF文件的内容压缩，只保留可以恢复数据的最小指令集。举个例子或许更形象，假如我们调用了100次INCR指令，在AOF文件中就要存储100条指令，但这明显是很低效的，完全可以把这100条指令合并成一条SET指令，这就是重写机制的原理。</p>
<p>在进行AOF重写时，仍然是采用先写临时文件，全部完成后再替换的流程，所以断电、磁盘满等问题都不会影响AOF文件的可用性，这点大家可以放心。</p>
<p>AOF方式的另一个好处，我们通过一个“场景再现”来说明。某同学在操作redis时，不小心执行了FLUSHALL，导致redis内存中的数据全部被清空了，这是很悲剧的事情。不过这也不是世界末日，只要redis配置了AOF持久化方式，且AOF文件还没有被重写（rewrite），我们就可以用最快的速度暂停redis并编辑AOF文件，将最后一行的FLUSHALL命令删除，然后重启redis，就可以恢复redis的所有数据到FLUSHALL之前的状态了。是不是很神奇，这就是AOF持久化方式的好处之一。但是如果AOF文件已经被重写了，那就无法通过这种方法来恢复数据了。</p>
<p>虽然优点多多，但AOF方式也同样存在缺陷，比如在同样数据规模的情况下，AOF文件要比RDB文件的体积大。而且，AOF方式的恢复速度也要慢于RDB方式。</p>
<p>如果你直接执行BGREWRITEAOF命令，那么redis会生成一个全新的AOF文件，其中便包括了可以恢复现有数据的最少的命令集。</p>
<p>如果运气比较差，AOF文件出现了被写坏的情况，也不必过分担忧，redis并不会贸然加载这个有问题的AOF文件，而是报错退出。这时可以通过以下步骤来修复出错的文件：</p>
<blockquote>
<p>备份被写坏的AOF文件<br>运行redis-check-aof –fix进行修复<br>用diff -u来看下两个文件的差异，确认问题点<br>重启redis，加载修复后的AOF文件</p>
</blockquote>
<hr>
<h3 id="redis持久化_–_AOF重写">redis持久化 – AOF重写</h3><p>在重写即将开始之际，redis会创建（fork）一个“重写子进程”，这个子进程会首先读取现有的AOF文件，并将其包含的指令进行分析压缩并写入到一个临时文件中。</p>
<p>与此同时，主工作进程会将新接收到的写指令一边累积到内存缓冲区中，一边继续写入到原有的AOF文件中，这样做是保证原有的AOF文件的可用性，避免在重写过程中出现意外。</p>
<p>当“重写子进程”完成重写工作后，它会给父进程发一个信号，父进程收到信号后就会将内存中缓存的写指令追加到新AOF文件中。</p>
<p>当追加结束后，redis就会用新AOF文件来代替旧AOF文件，之后再有新的写指令，就都会追加到新的AOF文件中了。</p>
<hr>
<h3 id="如何选择RDB和AOF">如何选择RDB和AOF</h3><p>对于我们应该选择RDB还是AOF，官方的建议是两个同时使用。这样可以提供更可靠的持久化方案。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="redis持久化">redis持久化</h2><p>redis提供了两种持久化的方式，分别是RDB（Redis DataBase）和AOF（Append Only File）。</p>
<blockquote>
<p>如果你没有数据持久化的需求，也完全可以关闭RD]]>
    </summary>
    
      <category term="redis" scheme="http://donahue-ldz.github.io/tags/redis/"/>
    
      <category term="redis" scheme="http://donahue-ldz.github.io/categories/redis/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[lucene基础]]></title>
    <link href="http://donahue-ldz.github.io/2015/03/13/lucene%E5%9F%BA%E7%A1%80/"/>
    <id>http://donahue-ldz.github.io/2015/03/13/lucene基础/</id>
    <published>2015-03-13T12:29:02.000Z</published>
    <updated>2015-03-13T12:39:07.000Z</updated>
    <content type="html"><![CDATA[<h2 id="简介">简介</h2><p>Lucene 是一个基于 Java 的全文信息检索工具包，它不是一个完整的搜索应用程序，而是为你的应用程序提供索引和搜索功能。Lucene 目前是 Apache Jakarta 家族中的一个开源项目。也是目前最为流行的基于 Java 开源全文检索工具包。</p>
<p><img src="https://www.ibm.com/developerworks/cn/java/j-lo-lucene1/fig001.jpg" alt="lucene结构"></p>
<h2 id="索引和搜索">索引和搜索</h2><p>索引和搜索<br>索引是现代搜索引擎的核心，建立索引的过程就是把源数据处理成非常方便查询的索引文件的过程。为什么索引这么重要呢，试想你现在要在大量的文档中搜索含有某个关键词的文档，那么如果不建立索引的话你就需要把这些文档顺序的读入内存，然后检查这个文章中是不是含有要查找的关键词，这样的话就会耗费非常多的时间，想想搜索引擎可是在毫秒级的时间内查找出要搜索的结果的。这就是由于建立了索引的原因，你可以把索引想象成这样一种数据结构，他能够使你快速的随机访问存储在索引中的关键词，进而找到该关键词所关联的文档。Lucene采用的是一种称为<code>反向索引（inverted index）的机制</code>。反向索引就是说我们维护了一个词 / 短语表，对于这个表中的每个词 / 短语，都有一个链表描述了有哪些文档包含了这个词 / 短语。这样在用户输入查询条件的时候，就能非常快的得到搜索结果<br>对文档建立好索引后，就可以在这些索引上面进行搜索了。搜索引擎首先会对搜索的关键词进行解析，然后再在建立好的索引上面进行查找，最终返回和用户输入的关键词相关联的文档。</p>
<h2 id="建立索引">建立索引</h2><h3 id="Document">Document</h3><p>Document 是用来描述文档的，这里的文档可以指一个 HTML 页面，一封电子邮件，或者是一个文本文件。一个 Document 对象由多个 Field 对象组成的。可以把一个 Document 对象想象成数据库中的一个记录，而每个 Field 对象就是记录的一个字段。</p>
<h3 id="Field">Field</h3><p>Field 对象是用来描述一个文档的某个属性的，比如一封电子邮件的标题和内容可以用两个 Field 对象分别描述。</p>
<h3 id="Analyzer">Analyzer</h3><p>在一个文档被索引之前，首先需要对文档内容进行分词处理，这部分工作就是由 Analyzer 来做的。Analyzer类是一个抽象类，它有多个实现。针对不同的语言和应用需要选择适合的 Analyzer。Analyzer 把分词后的内容交给 IndexWriter来建立索引。</p>
<h3 id="IndexWriter">IndexWriter</h3><p>IndexWriter 是 Lucene 用来创建索引的一个核心的类，他的作用是把一个个的 Document 对象加到索引中来。<br><code>IndexWriter indexWriter = new IndexWriter(indexDir,luceneAnalyzer,true);</code></p>
<p>true表示新建，false表示原来的索引更新</p>
<h3 id="Directory">Directory</h3><p>这个类代表了 Lucene 的索引的存储的位置，这是一个抽象类，它目前有两个实现，第一个是 FSDirectory，它表示一个存储在文件系统中的索引的位置。第二个是 RAMDirectory，它表示一个存储在内存当中的索引的位置。</p>
<h2 id="搜索">搜索</h2><h3 id="Query">Query</h3><p>这是一个抽象类，他有多个实现，比如 TermQuery, BooleanQuery, PrefixQuery. 这个类的目的是把用户输入的查询字符串封装成 Lucene 能够识别的 Query。</p>
<h3 id="Term">Term</h3><p>Term 是搜索的基本单位，一个 Term 对象有两个 String 类型的域组成。生成一个 Term 对象可以有如下一条语句来完成：</p>
<p><code>Term term = new Term(“fieldName”,”queryWord”);</code></p>
<p>其中第一个参数代表了要在文档的哪一个Field上进行查找，第二个参数代表了要查询的关键词。</p>
<h3 id="TermQuery">TermQuery</h3><p>TermQuery 是抽象类 Query 的一个子类，它同时也是 Lucene 支持的最为基本的一个查询类。生成一个 TermQuery 对象由如下语句完成：</p>
<p><code>TermQuery termQuery = new TermQuery(new Term(“fieldName”,”queryWord”));</code></p>
<p>它的构造函数只接受一个参数，那就是一个 Term 对象。</p>
<h3 id="IndexSearcher">IndexSearcher</h3><p>IndexSearcher 是用来在建立好的索引上进行搜索的。它只能以只读的方式打开一个索引，所以可以有多个 IndexSearcher 的实例在一个索引上进行操作,如。<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">FSDirectory</span> directory = FSDirectory.getDirectory(indexDir,<span class="built_in">false</span>); </span><br><span class="line"><span class="title">IndexSearcher</span> searcher = new IndexSearcher(directory);</span><br></pre></td></tr></table></figure></p>
<h3 id="Hits">Hits</h3><p>Hits 是用来保存搜索的结果的。<code>hits.doc()</code>获得文档<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Hits hits = searcher.search(luceneQuery); </span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; hits.length(); i++)&#123; </span><br><span class="line">    Document <span class="built_in">document</span> = hits.doc(i); </span><br><span class="line">    System.out.println(<span class="built_in">document</span>.<span class="literal">get</span>(<span class="string">""</span>)); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="简介">简介</h2><p>Lucene 是一个基于 Java 的全文信息检索工具包，它不是一个完整的搜索应用程序，而是为你的应用程序提供索引和搜索功能。Lucene 目前是 Apache Jakarta 家族中的一个开源项目。也是目前最为流行的基于 Java 开]]>
    </summary>
    
      <category term="lucene，搜索" scheme="http://donahue-ldz.github.io/tags/lucene%EF%BC%8C%E6%90%9C%E7%B4%A2/"/>
    
      <category term="lucene" scheme="http://donahue-ldz.github.io/categories/lucene/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[lucene开篇]]></title>
    <link href="http://donahue-ldz.github.io/2015/03/13/lucene%E5%BC%80%E7%AF%87/"/>
    <id>http://donahue-ldz.github.io/2015/03/13/lucene开篇/</id>
    <published>2015-03-13T12:17:24.000Z</published>
    <updated>2015-03-13T12:20:08.000Z</updated>
    <content type="html"><![CDATA[<p>最近由于项目中有用lucene，由于之前时间一直很忙，所以没有将相关的技术整理出来，今天决定将项目中的lucene整理，对lucene进行整体的学习和研究，会将项目中的部分源码分享目的为了便于分析！<br>渐渐的发现很多技术由于长时间没有再次接触很快就能忘记，汗～<br>反思：再忙也不能忘记更新博客，笨～</p>
<hr>
<p><code>go ~ ~ ~ ~ ~ ~</code></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>最近由于项目中有用lucene，由于之前时间一直很忙，所以没有将相关的技术整理出来，今天决定将项目中的lucene整理，对lucene进行整体的学习和研究，会将项目中的部分源码分享目的为了便于分析！<br>渐渐的发现很多技术由于长时间没有再次接触很快就能忘记，汗～<br>反]]>
    </summary>
    
      <category term="lucene" scheme="http://donahue-ldz.github.io/categories/lucene/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[MarkDown语法入门]]></title>
    <link href="http://donahue-ldz.github.io/2015/02/15/MarkDown%E8%AF%AD%E6%B3%95%E5%85%A5%E9%97%A8/"/>
    <id>http://donahue-ldz.github.io/2015/02/15/MarkDown语法入门/</id>
    <published>2015-02-15T02:32:21.000Z</published>
    <updated>2015-03-07T05:15:56.000Z</updated>
    <content type="html"><![CDATA[<h2 id="MarkDown_理念">MarkDown 理念</h2><blockquote>
<p>让文档更容易读、写和随意改。HTML 是一种发布的格式，Markdown 是一种书写的格式。就这样，Markdown 的格式语法只涵盖纯文本可以涵盖的范围.</p>
</blockquote>
<hr>
<h2 id="注意">注意</h2><blockquote>
<p>不在 Markdown 涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写。不需要额外标注这是 HTML 或是 Markdown；只要直接加标签就可以了。<br>要制约的只有一些 HTML 区块元素――比如 <code>&lt;div&gt;、&lt;table&gt;、&lt;pre&gt;、&lt;p&gt;</code>等标签，必须在 <strong>前后</strong> 加上 <strong>空行</strong> 与其它内容区隔开，还要求它们的开始标签与结尾标签不能用制表符或空格来缩进。Markdown 的生成器有足够智能，不会在 HTML 区块标签外加上不必要的 <code>&lt;p&gt;</code> 标签。</p>
</blockquote>
<hr>
<h1 id="常见的使用">常见的使用</h1><h3 id="标题">标题</h3><p>Markdown 支持两种标题的语法，类 Setext 和类 atx 形式。</p>
<blockquote>
<ol>
<li>类 Setext 形式是用底线的形式(在需要成为标题的文字下方加入…)，利用 = （最高阶标题）和 - （第二阶标题)</li>
<li>类 Atx 形式则是在行首插入 1 到 6 个 # ，对应到标题 1 到 6 阶</li>
</ol>
</blockquote>
<p><strong><em>你可以选择性地「闭合」类 atx 样式的标题，这纯粹只是美观用的若是觉得这样看起来比较舒适，你就可以在行尾加上<br>而行尾的 # 数量也不用和开头一样（行首的井字符数量决定标题的阶数）</em></strong></p>
<hr>
<h3 id="区块引用_Blockquotes">区块引用 Blockquotes</h3><ul>
<li>Markdown 标记区块引用是使用类似 email 中用 &gt; 的引用方式。</li>
<li>Markdown 也允许你偷懒只在整个段落的第一行最前面加上 &gt; </li>
<li>区块引用可以嵌套（例如：引用内的引用），只要根据层次加上不同数量的 &gt; </li>
<li>引用的区块内也可以使用其他的 Markdown 语法，包括标题、列表、代码区块等</li>
</ul>
<hr>
<h3 id="列表">列表</h3><p>Markdown 支持有序列表和无序列表。</p>
<ul>
<li>无序列表使用星号、加号或是减号作为列表标记 : <code>*+空格</code></li>
<li>有序列表则使用数字接着一个英文句点：<code>数字+句点+空格</code>  <strong>可以完全不在意数字的正确和顺序</strong></li>
<li>列表项目可以包含多个段落，每个项目下的段落都必须缩进 4 个空格或是 1 个制表符</li>
<li>如果要在列表项目内放进引用，那 &gt; 就需要缩进</li>
<li><code>如果要放代码区块的话，该区块就需要缩进两次，也就是 8 个空格或是 2 个制表符</code></li>
<li>在行首出现数字-句点-空白，要避免这样的状况，你可以在句点前面加上反斜杠     </li>
</ul>
<hr>
<h3 id="代码区块">代码区块</h3><p>Markdown 会用<code>&lt;pre&gt;</code> 和 <code>&lt;code&gt;</code> 标签来把代码区块包起来.<br>要在 Markdown 中建立代码区块很简单，只要简单地缩进 4 个空格或是 1 个制表符就可以(<strong>中间需要一行空行隔开</strong>)，一个代码区块会一直持续到没有缩进的那一行（或是文件结尾）。例如，下面的输入：</p>
<p>这是一个普通段落：</p>
<pre><code><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[]args)
</code></pre><ul>
<li>在代码区块里面， &amp; 、 &lt; 和 &gt; 会自动转成 HTML 实体，这样的方式让你非常容易使用 Markdown 插入范例用的 HTML 原始码，只需要复制贴上，再加上缩进就可以了，剩下的 Markdown 都会帮你处理</li>
<li>代码区块中，一般的 Markdown 语法不会被转换，像是星号便只是星号，这表示你可以很容易地以 Markdown 语法撰写 Markdown 语法相关的文件</li>
</ul>
<hr>
<h3 id="分割线">分割线</h3><p>你可以在一行中用三个以上的<code>星号、减号、底线</code>来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线.</p>
<hr>
<h3 id="链接">链接</h3><p>Markdown 支持两种形式的链接语法： 行内式和参考式两种形式。</p>
<p>不管是哪一种，链接文字都是用 [方括号] 来标记。</p>
<ul>
<li>要建立一个行内式的链接，只要在方块括号后面紧接着圆括号并插入网址链接即可，如果你还想要加上链接的 title 文字，只要在网址后面，用双引号把 title 文字包起来即可，例如：<blockquote>
<p><code>This is [an example](http://example.com/ &quot;Title&quot;) inline link.</code><br><code>[This link](http://example.net/) has no title attribute.</code></p>
</blockquote>
</li>
</ul>
<p><code>如果你是要链接到同样主机的资源，你可以使用相对路径：See my [About](/about/) page for details.</code></p>
<ul>
<li>参考式的链接是在链接文字的括号后面再接上另一个方括号，而在第二个方括号里面要填入用以辨识链接的标记：<blockquote>
<p><code>This is [an example] [id] reference-style link</code>.<br>你也可以选择性地在两个方括号中间加上一个空格：<br><code>This is [an example] [id] reference-style link</code>.<br>接着，在文件的任意处，你可以把这个标记的链接内容定义出来：</p>
</blockquote>
</li>
</ul>
<p><code>[id]: http://example.com/  &quot;Optional Title Here&quot;</code> </p>
<h3 id="强调">强调</h3><p>Markdown 使用星号（<em>）和底线（_）作为标记强调字词的符号，被 </em> 或 <em> 包围的字词会被转成用 <code>&lt;em&gt;</code> 标签包围，用两个 * 或 </em> 包起来的话，则会被转成 <code>&lt;strong&gt;</code></p>
<h3 id="代码">代码</h3><ul>
<li>如果要标记一小段行内代码，你可以用反引号把它包起来（`）</li>
<li>如果要在代码区段内插入反引号，你可以用多个反引号来开启和结束代码区段：</li>
</ul>
<h3 id="图片">图片</h3><p>markdown 使用一种和链接很相似的语法来标记图片，同样也允许两种样式： 行内式和参考式。<br>行内式的图片语法看起来像是：</p>
<p><code>![Alt text](/path/to/img.jpg)</code></p>
<p><code>![Alt text](/path/to/img.jpg &quot;Optional title&quot;)</code><br>详细叙述如下：</p>
<p>一个惊叹号 !<br>接着一个方括号，里面放上图片的替代文字<br>接着一个普通括号，里面放上图片的网址，最后还可以用引号包住并加上 选择性的 ‘title’ 文字。<br>参考式的图片语法则长得像这样：</p>
<p><code>![Alt text][id]</code><br>「id」是图片参考的名称，图片参考的定义方式则和连结参考一样：</p>
<p><code>[id]: url/to/image  &quot;Optional title attribute&quot;</code><br>到目前为止， Markdown 还没有办法指定图片的宽高，如果你需要的话，你可以使用普通的 <code>&lt;img&gt;</code> 标签。</p>
<hr>
<h3 id="自动链接">自动链接</h3><blockquote>
<p>Markdown 支持以比较简短的自动链接形式来处理网址和电子邮件信箱，只要是用尖括号包起来， Markdown 就会自动把它转成链接。一般网址的链接文字就和链接地址一样，例如：<br><code>&lt;http://example.com/&gt;</code><br>Markdown 会转为：<br><code>&lt;a href=&quot;http://example.com/&quot;&gt;http://example.com/&lt;/a&gt;</code><br>邮址的自动链接也很类似，只是 Markdown 会先做一个编码转换的过程，把文字字符转成 16 进位码的 HTML 实体，这样的格式可以糊弄一些不好的邮址收集机器人<br><code>&lt;address@example.com&gt;</code></p>
</blockquote>
<hr>
<h3 id="反斜杠">反斜杠</h3><p><strong>也就是程序员所熟悉的转义符号</strong></p>
<hr>
<p><a href="http://wowubuntu.com/markdown/" target="_blank" rel="external">参考资料</a><a href="http://wowubuntu.com/markdown/" target="_blank" rel="external">http://wowubuntu.com/markdown/</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="MarkDown_理念">MarkDown 理念</h2><blockquote>
<p>让文档更容易读、写和随意改。HTML 是一种发布的格式，Markdown 是一种书写的格式。就这样，Markdown 的格式语法只涵盖纯文本可以涵盖的范围.</p>
</bl]]>
    </summary>
    
      <category term="MarkDown" scheme="http://donahue-ldz.github.io/tags/MarkDown/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[log4j常见日志级别的选用]]></title>
    <link href="http://donahue-ldz.github.io/2015/01/17/log4j%E5%B8%B8%E8%A7%81%E6%97%A5%E5%BF%97%E7%BA%A7%E5%88%AB%E7%9A%84%E9%80%89%E7%94%A8/"/>
    <id>http://donahue-ldz.github.io/2015/01/17/log4j常见日志级别的选用/</id>
    <published>2015-01-17T05:24:44.000Z</published>
    <updated>2015-03-15T05:30:12.000Z</updated>
    <content type="html"><![CDATA[<h2 id="RootLogger">RootLogger</h2><p><code>log4j.rootLogger = [ level ] , appenderName1, appenderName2,...</code><br><code>log4j.additivity.org.apache=false</code>表示Logger不会在父Logger的appender里输出，默认为true。<br>level ：设定日志记录的最低级别，可设的值有:<br><code>OFF、FATAL、ERROR、WARN、INFO、DEBUG、ALL</code>或者自定义的级别，Log4j建议只使用中间四个级别。<strong>通过在这里设定级别</strong>，您可以控制应用程序中相应级别的日志信息的开关，比如在这里设定了INFO级别，则应用程序中所有DEBUG级别的日志信息将不会被打印出来。<br>appenderName：就是指定日志信息要输出到哪里。可以同时指定多个输出目的地，用逗号隔开。<br>具体详见：<a href="http://donahue-ldz.github.io/2015/01/05/%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95/" target="_blank" rel="external">日志记录</a></p>
<hr>
<blockquote>
<p>这里主要针对什么时候选择相关的打印级别帮助系统能很好运行做简单介绍</p>
</blockquote>
<hr>
<h2 id="日志级别">日志级别</h2><h3 id="ERROR">ERROR</h3><p>系统发生了严重的错误, 必须马上进行处理, 否则系统将无法继续运行. 比如数据库不可用等</p>
<h3 id="WARN">WARN</h3><p>系统能继续运行, 但是必须引起关注. 对于存在的问题一般可以分为两类: 一种系统存在明显的问题(比如, 数据不可用),另一种就是系统存在潜在的问题, 需要引起注意或者给出一些建议(比如,系统运行在安全模式或者访问当前系统的账号存在安全隐患). 总之就是系统仍然可用, 但是最好进行检查和调整。</p>
<h3 id="INFO">INFO</h3><p>重要的业务逻辑处理完成。在理想情况下,INFO的日志信息要能让高级用户和系统管理员理解, 并从日志信息中能知道系统当前的运行状态。理解系统的运行状态和流程…</p>
<h3 id="DEBUG">DEBUG</h3><p>主要用于调试、测试时使用，一般是在程序中不是非常重要的地方,这部分的日志较多，但是在线上运行时我们一般会将日志级别设置为INFO，避免DEBUG日志过多影响性。</p>
<h3 id="TRACE">TRACE</h3><p>系统详细信息, 主要给开发人员用,一般来说,如果是线上系统的话,可以认为是临时输出, 而且随时可以通过开关将其关闭.有时候我们很难将DEBUG和TRACE区分开, 一般情况下, 如果是一个已经开发测试完成的系统,再往系统中添加日志输出, 那么应该设为TRACE级别。</p>
<h2 id="日志的好处">日志的好处</h2><p>帮助分析了解系统运行</p>
<h2 id="日志缺点">日志缺点</h2><p>打印日志将会降低程序的性能和响应，尤其是在高并发等实时相应的系统中</p>
<h2 id="日志输出原则">日志输出原则</h2><p>Log4j建议只使用四个级别，优先级从高到低分别是 ERROR、WARN、INFO、DEBUG。通过在这里定义的级别，您可以控制到应用程序中相应级别的日志信息的开关。</p>
<ul>
<li>对程序的输入输出要以DEBUG记录下来，常包括从文件、数据库、网络、用户等输入的信息，向文件、数据库、网络输出的信息。</li>
<li>对重要对象或程序状态的修改，要以INFO记录修改前的信息和修改后的状态。</li>
<li>不能忽视每个调用错误，异常日志的内容要能清晰描述运行上下文，这样有助于排查错误，输出异常日志时，第一个参数一定是一个字符串,一般都是对问题的描述信息, 而不能是异常message(因为堆栈里面会有),第二个参数才是具体的异常实例. 例如：log.error(“导入数据失败，错误信息为：”, e) 。</li>
<li>记下打印信息时所在的文件名和函数名（必须能区分开重载函数）,有行数最好。</li>
<li>对于高并发系统，能不打印日志就不打印日志，输出的日志数量、级别、内容都要经过评估，避免日志输出影响性能,可以采用初期上线时多打印一些日志，上线运行一段时间后，通过观察方法调用次数，响应性能来决定减少那些日志的打印或者改变打印日志的级别。</li>
<li>对于异常日志的内容要能清晰描述运行上下文，这样有助于排查错误。 </li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="RootLogger">RootLogger</h2><p><code>log4j.rootLogger = [ level ] , appenderName1, appenderName2,...</code><br><code>log4j.additivity]]>
    </summary>
    
      <category term="log4j" scheme="http://donahue-ldz.github.io/tags/log4j/"/>
    
      <category term="日志" scheme="http://donahue-ldz.github.io/tags/%E6%97%A5%E5%BF%97/"/>
    
      <category term="log" scheme="http://donahue-ldz.github.io/categories/log/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[log4j常见配置]]></title>
    <link href="http://donahue-ldz.github.io/2015/01/15/log4j%E5%B8%B8%E8%A7%81%E9%85%8D%E7%BD%AE/"/>
    <id>http://donahue-ldz.github.io/2015/01/15/log4j常见配置/</id>
    <published>2015-01-15T07:27:41.000Z</published>
    <updated>2015-03-15T05:30:18.000Z</updated>
    <content type="html"><![CDATA[<h2 id="xml类型的配置">xml类型的配置</h2><p>Log4j配置文件实现了输出到控制台、文件、固定大小文件、发送日志邮件、输出到数据库日志表、自定义标签等全套功能。 </p>
<pre><code><span class="pi">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span>  
<span class="doctype">&lt;!DOCTYPE log4j:configuration SYSTEM "log4j.dtd"&gt;</span>  

<span class="tag">&lt;<span class="title">log4j:configuration</span>&gt;</span>  

 <span class="comment">&lt;!--自定义输出到控制台--&gt;</span>
 <span class="tag">&lt;<span class="title">appender</span> <span class="attribute">name</span>=<span class="value">"CONSOLE"</span> <span class="attribute">class</span>=<span class="value">"org.apache.log4j.ConsoleAppender"</span>&gt;</span>
  <span class="tag">&lt;<span class="title">layout</span> <span class="attribute">class</span>=<span class="value">"org.apache.log4j.PatternLayout"</span>&gt;</span>  
   <span class="tag">&lt;<span class="title">param</span> <span class="attribute">name</span>=<span class="value">"ConversionPattern"</span>  
    <span class="attribute">value</span>=<span class="value">"%d - %c -%-4r [%t] %-5p %x - %m%n"</span> /&gt;</span>  
  <span class="tag">&lt;/<span class="title">layout</span>&gt;</span>  

  <span class="comment">&lt;!--限制输出级别--&gt;</span>  
  <span class="tag">&lt;<span class="title">filter</span> <span class="attribute">class</span>=<span class="value">"org.apache.log4j.varia.LevelRangeFilter"</span>&gt;</span>  
   <span class="tag">&lt;<span class="title">param</span> <span class="attribute">name</span>=<span class="value">"LevelMax"</span> <span class="attribute">value</span>=<span class="value">"ERROR"</span>/&gt;</span>  
   <span class="tag">&lt;<span class="title">param</span> <span class="attribute">name</span>=<span class="value">"LevelMin"</span> <span class="attribute">value</span>=<span class="value">"TRACE"</span>/&gt;</span>  
  <span class="tag">&lt;/<span class="title">filter</span>&gt;</span>  
 <span class="tag">&lt;/<span class="title">appender</span>&gt;</span>  

 <span class="comment">&lt;!--输出到文件--&gt;</span>
 <span class="tag">&lt;<span class="title">appender</span> <span class="attribute">name</span>=<span class="value">"FILE"</span> <span class="attribute">class</span>=<span class="value">"org.apache.log4j.FileAppender"</span>&gt;</span>  
  <span class="tag">&lt;<span class="title">param</span> <span class="attribute">name</span>=<span class="value">"File"</span> <span class="attribute">value</span>=<span class="value">"log4j.log"</span>/&gt;</span>  
  <span class="tag">&lt;<span class="title">layout</span> <span class="attribute">class</span>=<span class="value">"org.apache.log4j.PatternLayout"</span>&gt;</span>  
   <span class="tag">&lt;<span class="title">param</span> <span class="attribute">name</span>=<span class="value">"ConversionPattern"</span>  
    <span class="attribute">value</span>=<span class="value">"%d - %c -%-4r [%t] %-5p %x - %m%n"</span> /&gt;</span>  
  <span class="tag">&lt;/<span class="title">layout</span>&gt;</span>  
 <span class="tag">&lt;/<span class="title">appender</span>&gt;</span>    

 <span class="comment">&lt;!--输出到数据库--&gt;</span>
 <span class="tag">&lt;<span class="title">appender</span> <span class="attribute">name</span>=<span class="value">"DATABASE"</span> <span class="attribute">class</span>=<span class="value">"org.apache.log4j.jdbc.JDBCAppender"</span>&gt;</span>  
  <span class="tag">&lt;<span class="title">param</span> <span class="attribute">name</span>=<span class="value">"URL"</span> <span class="attribute">value</span>=<span class="value">"jdbc:oracle:thin:@192.168.0.59:1521:oanet"</span>/&gt;</span>  
  <span class="tag">&lt;<span class="title">param</span> <span class="attribute">name</span>=<span class="value">"driver"</span> <span class="attribute">value</span>=<span class="value">"oracle.jdbc.driver.OracleDriver"</span>/&gt;</span>  
  <span class="tag">&lt;<span class="title">param</span> <span class="attribute">name</span>=<span class="value">"user"</span> <span class="attribute">value</span>=<span class="value">"user"</span>/&gt;</span>  
  <span class="tag">&lt;<span class="title">param</span> <span class="attribute">name</span>=<span class="value">"password"</span> <span class="attribute">value</span>=<span class="value">"password"</span>/&gt;</span>      
  <span class="tag">&lt;<span class="title">layout</span> <span class="attribute">class</span>=<span class="value">"org.apache.log4j.PatternLayout"</span>&gt;</span>  
   <span class="tag">&lt;<span class="title">param</span> <span class="attribute">name</span>=<span class="value">"ConversionPattern"</span> 
   <span class="attribute">value</span>=<span class="value">"INSERT INTO hdczoa.LOG4J(stamp,thread,info_level,class,message) VALUES ('%d', '%t', '%p', '%c', %m)"</span> /&gt;</span>  
  <span class="tag">&lt;/<span class="title">layout</span>&gt;</span>  
 <span class="tag">&lt;/<span class="title">appender</span>&gt;</span>  

 <span class="comment">&lt;!-- 发邮件（只有ERROR时才会发送！） --&gt;</span>  
 <span class="tag">&lt;<span class="title">appender</span> <span class="attribute">name</span>=<span class="value">"MAIL"</span>  <span class="attribute">class</span>=<span class="value">"org.apache.log4j.net.SMTPAppender"</span>&gt;</span>  
  <span class="tag">&lt;<span class="title">param</span> <span class="attribute">name</span>=<span class="value">"threshold"</span> <span class="attribute">value</span>=<span class="value">"debug"</span> /&gt;</span>  
  <span class="comment">&lt;!-- 日志的错误级别  
   &lt;param name="threshold" value="fatal"/&gt;  
  --&gt;</span>  
  <span class="comment">&lt;!-- 缓存文件大小，日志达到512K时发送Email --&gt;</span>  
  <span class="tag">&lt;<span class="title">param</span> <span class="attribute">name</span>=<span class="value">"BufferSize"</span> <span class="attribute">value</span>=<span class="value">"512"</span> /&gt;</span><span class="comment">&lt;!-- 单位K --&gt;</span>  
  <span class="tag">&lt;<span class="title">param</span> <span class="attribute">name</span>=<span class="value">"From"</span> <span class="attribute">value</span>=<span class="value">"test@163.com"</span> /&gt;</span>  
  <span class="tag">&lt;<span class="title">param</span> <span class="attribute">name</span>=<span class="value">"SMTPHost"</span> <span class="attribute">value</span>=<span class="value">"smtp.163.com"</span> /&gt;</span>  
  <span class="tag">&lt;<span class="title">param</span> <span class="attribute">name</span>=<span class="value">"Subject"</span> <span class="attribute">value</span>=<span class="value">"juyee-log4jMessage"</span> /&gt;</span>  
  <span class="comment">&lt;!--收件人--&gt;</span>
  <span class="tag">&lt;<span class="title">param</span> <span class="attribute">name</span>=<span class="value">"To"</span> <span class="attribute">value</span>=<span class="value">"reciever@163.com"</span> /&gt;</span>
  <span class="comment">&lt;!--发件人登陆邮箱服务器--&gt;</span>
  <span class="tag">&lt;<span class="title">param</span> <span class="attribute">name</span>=<span class="value">"SMTPUsername"</span> <span class="attribute">value</span>=<span class="value">"user"</span> /&gt;</span>  
  <span class="tag">&lt;<span class="title">param</span> <span class="attribute">name</span>=<span class="value">"SMTPPassword"</span> <span class="attribute">value</span>=<span class="value">"password"</span> /&gt;</span>  
  <span class="tag">&lt;<span class="title">layout</span> <span class="attribute">class</span>=<span class="value">"org.apache.log4j.PatternLayout"</span>&gt;</span>  
   <span class="tag">&lt;<span class="title">param</span> <span class="attribute">name</span>=<span class="value">"ConversionPattern"</span>  
    <span class="attribute">value</span>=<span class="value">"%-d{yyyy-MM-dd HH:mm:ss.SSS} [%p]-[%c] %m%n"</span> /&gt;</span>  
  <span class="tag">&lt;/<span class="title">layout</span>&gt;</span>  
 <span class="tag">&lt;/<span class="title">appender</span>&gt;</span>  

 <span class="tag">&lt;<span class="title">appender</span> <span class="attribute">name</span>=<span class="value">"ASYNC"</span> <span class="attribute">class</span>=<span class="value">"org.apache.log4j.AsyncAppender"</span>&gt;</span>  
  <span class="tag">&lt;<span class="title">param</span> <span class="attribute">name</span>=<span class="value">"BufferSize"</span> <span class="attribute">value</span>=<span class="value">"256"</span> /&gt;</span>  
  <span class="tag">&lt;<span class="title">appender-ref</span> <span class="attribute">ref</span>=<span class="value">"DATABASE"</span> /&gt;</span>  
 <span class="tag">&lt;/<span class="title">appender</span>&gt;</span>  

 <span class="comment">&lt;!--通过&lt;logger&gt;&lt;/logger&gt;的定义可以将各个包中的类日志输出到不同的日志文件中--&gt;</span>  
 <span class="tag">&lt;<span class="title">logger</span> <span class="attribute">name</span>=<span class="value">"packageName"</span> <span class="attribute">additivity</span>=<span class="value">"false"</span>&gt;</span>     
        <span class="tag">&lt;<span class="title">level</span> <span class="attribute">value</span>=<span class="value">"WARN"</span> /&gt;</span>     
        <span class="tag">&lt;<span class="title">appender-ref</span> <span class="attribute">ref</span>=<span class="value">"CONSOLE"</span> /&gt;</span>     
    <span class="tag">&lt;/<span class="title">logger</span>&gt;</span>  

 <span class="comment">&lt;!--通过&lt;category&gt;&lt;/category&gt;的定义可以将各个包中的类日志输出到不同的日志文件中--&gt;</span>  
 <span class="tag">&lt;<span class="title">category</span> <span class="attribute">name</span>=<span class="value">"com.litt3"</span>&gt;</span>     
    <span class="tag">&lt;<span class="title">level</span> <span class="attribute">value</span>=<span class="value">"DEBUG"</span> /&gt;</span>   
       <span class="tag">&lt;<span class="title">appender-ref</span> <span class="attribute">ref</span>=<span class="value">"CONSOLE"</span> /&gt;</span>  
       <span class="tag">&lt;<span class="title">appender-ref</span> <span class="attribute">ref</span>=<span class="value">"MAIL"</span> /&gt;</span>  
  <span class="tag">&lt;/<span class="title">category</span>&gt;</span>  

 <span class="tag">&lt;<span class="title">root</span>&gt;</span>  
  <span class="tag">&lt;<span class="title">priority</span> <span class="attribute">value</span>=<span class="value">"debug"</span> /&gt;</span>  
  <span class="tag">&lt;<span class="title">appender-ref</span> <span class="attribute">ref</span>=<span class="value">"CONSOLE"</span> /&gt;</span>  
  <span class="tag">&lt;<span class="title">appender-ref</span> <span class="attribute">ref</span>=<span class="value">"FILE"</span> /&gt;</span>  
 <span class="tag">&lt;/<span class="title">root</span>&gt;</span>  


<span class="tag">&lt;/<span class="title">log4j:configuration</span>&gt;</span>  
</code></pre><hr>
<h2 id="属性文件配置">属性文件配置</h2><p>Log4j配置文件实现了输出到控制台、文件、固定大小文件、发送日志邮件、输出到数据库日志表、自定义标签等全套功能。 </p>
<pre><code>log4j.rootLogger=DEBUG,console,dailyFile,im 
log4j<span class="class">.additivity</span><span class="class">.org</span><span class="class">.apache</span>=true 
</code></pre><h3 id="控制台(console)">控制台(console)</h3><pre><code>log4j<span class="class">.appender</span><span class="class">.console</span>=org<span class="class">.apache</span><span class="class">.log4j</span><span class="class">.ConsoleAppender</span> 
log4j<span class="class">.appender</span><span class="class">.console</span><span class="class">.Threshold</span>=DEBUG 
log4j<span class="class">.appender</span><span class="class">.console</span><span class="class">.ImmediateFlush</span>=true 
log4j<span class="class">.appender</span><span class="class">.console</span><span class="class">.Target</span>=System<span class="class">.err</span> 
log4j<span class="class">.appender</span><span class="class">.console</span><span class="class">.layout</span>=org<span class="class">.apache</span><span class="class">.log4j</span><span class="class">.PatternLayout</span> 
log4j<span class="class">.appender</span><span class="class">.console</span><span class="class">.layout</span><span class="class">.ConversionPattern</span>=[%-<span class="number">5</span>p] %<span class="function"><span class="title">d</span><span class="params">(%r)</span></span> --&gt; [%t] %l: %m %x %n 
</code></pre><h3 id="日志文件(logFile)">日志文件(logFile)</h3><pre><code>log4j<span class="class">.appender</span><span class="class">.logFile</span>=org<span class="class">.apache</span><span class="class">.log4j</span><span class="class">.FileAppender</span> 
log4j<span class="class">.appender</span><span class="class">.logFile</span><span class="class">.Threshold</span>=DEBUG 
log4j<span class="class">.appender</span><span class="class">.logFile</span><span class="class">.ImmediateFlush</span>=true 
log4j<span class="class">.appender</span><span class="class">.logFile</span><span class="class">.Append</span>=true 
log4j<span class="class">.appender</span><span class="class">.logFile</span><span class="class">.File</span>=log<span class="class">.log4j</span> 
log4j<span class="class">.appender</span><span class="class">.logFile</span><span class="class">.layout</span>=org<span class="class">.apache</span><span class="class">.log4j</span><span class="class">.PatternLayout</span> 
log4j<span class="class">.appender</span><span class="class">.logFile</span><span class="class">.layout</span><span class="class">.ConversionPattern</span>=[%-<span class="number">5</span>p] %<span class="function"><span class="title">d</span><span class="params">(%r)</span></span> --&gt; [%t] %l: %m %x %n 
</code></pre><h3 id="指定大小文件(rollingFile)">指定大小文件(rollingFile)</h3><p><code>文件大小到达指定尺寸的时候产生一个新的文件</code></p>
<pre><code>log4j<span class="class">.appender</span><span class="class">.rollingFile</span>=org<span class="class">.apache</span><span class="class">.log4j</span><span class="class">.RollingFileAppender</span> 
log4j<span class="class">.appender</span><span class="class">.rollingFile</span><span class="class">.Threshold</span>=DEBUG 
log4j<span class="class">.appender</span><span class="class">.rollingFile</span><span class="class">.ImmediateFlush</span>=true 
log4j<span class="class">.appender</span><span class="class">.rollingFile</span><span class="class">.Append</span>=true 
log4j<span class="class">.appender</span><span class="class">.rollingFile</span><span class="class">.File</span>=log<span class="class">.log4j</span> 
#文件达到多大开始重新开始记录新文件
log4j<span class="class">.appender</span><span class="class">.rollingFile</span><span class="class">.MaxFileSize</span>=<span class="number">200</span>KB 
log4j<span class="class">.appender</span><span class="class">.rollingFile</span><span class="class">.MaxBackupIndex</span>=<span class="number">50</span> 
log4j<span class="class">.appender</span><span class="class">.rollingFile</span><span class="class">.layout</span>=org<span class="class">.apache</span><span class="class">.log4j</span><span class="class">.PatternLayout</span> 
log4j<span class="class">.appender</span><span class="class">.rollingFile</span><span class="class">.layout</span><span class="class">.ConversionPattern</span>=[%-<span class="number">5</span>p] %<span class="function"><span class="title">d</span><span class="params">(%r)</span></span> --&gt; [%t] %l: %m %x %n 
</code></pre><h3 id="每天产生一个文件(dailyFile)">每天产生一个文件(dailyFile)</h3><pre><code>log4j<span class="class">.appender</span><span class="class">.dailyFile</span>=org<span class="class">.apache</span><span class="class">.log4j</span><span class="class">.DailyRollingFileAppender</span> 
log4j<span class="class">.appender</span><span class="class">.dailyFile</span><span class="class">.Threshold</span>=DEBUG 
log4j<span class="class">.appender</span><span class="class">.dailyFile</span><span class="class">.ImmediateFlush</span>=true 
log4j<span class="class">.appender</span><span class="class">.dailyFile</span><span class="class">.Append</span>=true 
log4j<span class="class">.appender</span><span class="class">.dailyFile</span><span class="class">.File</span>=log<span class="class">.log4j</span> 
log4j<span class="class">.appender</span><span class="class">.dailyFile</span><span class="class">.DatePattern</span>=<span class="string">'.'</span>yyyy-MM-<span class="tag">dd</span> 
log4j<span class="class">.appender</span><span class="class">.dailyFile</span><span class="class">.layout</span>=org<span class="class">.apache</span><span class="class">.log4j</span><span class="class">.PatternLayout</span> 
log4j<span class="class">.appender</span><span class="class">.dailyFile</span><span class="class">.layout</span><span class="class">.ConversionPattern</span>=[%-<span class="number">5</span>p] %<span class="function"><span class="title">d</span><span class="params">(%r)</span></span> --&gt; [%t] %l: %m %x %n 
</code></pre><h3 id="发送日志到指定邮件">发送日志到指定邮件</h3><pre><code>log4j<span class="class">.appender</span><span class="class">.mail</span>=org<span class="class">.apache</span><span class="class">.log4j</span><span class="class">.net</span><span class="class">.SMTPAppender</span> 
log4j<span class="class">.appender</span><span class="class">.mail</span><span class="class">.Threshold</span>=FATAL 
log4j<span class="class">.appender</span><span class="class">.mail</span><span class="class">.BufferSize</span>=<span class="number">10</span> 
log4j<span class="class">.appender</span><span class="class">.mail</span><span class="class">.From</span> = xxx@mail<span class="class">.com</span> 
log4j<span class="class">.appender</span><span class="class">.mail</span><span class="class">.SMTPHost</span>=mail<span class="class">.com</span> 
log4j<span class="class">.appender</span><span class="class">.mail</span><span class="class">.Subject</span>=Log4J Message 
log4j<span class="class">.appender</span><span class="class">.mail</span><span class="class">.To</span>= xxx@mail<span class="class">.com</span> 
log4j<span class="class">.appender</span><span class="class">.mail</span><span class="class">.layout</span>=org<span class="class">.apache</span><span class="class">.log4j</span><span class="class">.PatternLayout</span> 
log4j<span class="class">.appender</span><span class="class">.mail</span><span class="class">.layout</span><span class="class">.ConversionPattern</span>=[%-<span class="number">5</span>p] %<span class="function"><span class="title">d</span><span class="params">(%r)</span></span> --&gt; [%t] %l: %m %x %n 
</code></pre><h3 id="应用于数据库">应用于数据库</h3><pre><code>log4j<span class="class">.appender</span><span class="class">.database</span>=org<span class="class">.apache</span><span class="class">.log4j</span><span class="class">.jdbc</span><span class="class">.JDBCAppender</span> 
log4j<span class="class">.appender</span><span class="class">.database</span><span class="class">.URL</span>=jdbc:mysql:<span class="comment">//localhost:3306/test </span>
log4j<span class="class">.appender</span><span class="class">.database</span><span class="class">.driver</span>=com<span class="class">.mysql</span><span class="class">.jdbc</span><span class="class">.Driver</span> 
log4j<span class="class">.appender</span><span class="class">.database</span><span class="class">.user</span>=root 
log4j<span class="class">.appender</span><span class="class">.database</span><span class="class">.password</span>= 
log4j<span class="class">.appender</span><span class="class">.database</span><span class="class">.sql</span>=INSERT INTO LOG4J (Message) <span class="function"><span class="title">VALUES</span><span class="params">(<span class="string">'=[%-5p] %d(%r) --&gt; [%t] %l: %m %x %n'</span>)</span></span> 
log4j<span class="class">.appender</span><span class="class">.database</span><span class="class">.layout</span>=org<span class="class">.apache</span><span class="class">.log4j</span><span class="class">.PatternLayout</span> 
log4j<span class="class">.appender</span><span class="class">.database</span><span class="class">.layout</span><span class="class">.ConversionPattern</span>=[%-<span class="number">5</span>p] %<span class="function"><span class="title">d</span><span class="params">(%r)</span></span> --&gt; [%t] %l: %m %x %n 
</code></pre><h3 id="自定义Appender">自定义Appender</h3><pre><code>log4j<span class="class">.appender</span><span class="class">.im</span> = net<span class="class">.cybercorlin</span><span class="class">.util</span><span class="class">.logger</span><span class="class">.appender</span><span class="class">.IMAppender</span> 
log4j<span class="class">.appender</span><span class="class">.im</span><span class="class">.host</span> = mail<span class="class">.cybercorlin</span><span class="class">.net</span> 
log4j<span class="class">.appender</span><span class="class">.im</span><span class="class">.username</span> = username 
log4j<span class="class">.appender</span><span class="class">.im</span><span class="class">.password</span> = password 
log4j<span class="class">.appender</span><span class="class">.im</span><span class="class">.recipient</span> = 
log4j<span class="class">.appender</span><span class="class">.im</span><span class="class">.layout</span>=org<span class="class">.apache</span><span class="class">.log4j</span><span class="class">.PatternLayout</span> 
log4j<span class="class">.appender</span><span class="class">.im</span><span class="class">.layout</span><span class="class">.ConversionPattern</span>=[%-<span class="number">5</span>p] %<span class="function"><span class="title">d</span><span class="params">(%r)</span></span> --&gt; [%t] %l: %m %x %n 
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<h2 id="xml类型的配置">xml类型的配置</h2><p>Log4j配置文件实现了输出到控制台、文件、固定大小文件、发送日志邮件、输出到数据库日志表、自定义标签等全套功能。 </p>
<pre><code><span class="pi">&lt;?xml versio]]>
    </summary>
    
      <category term="log4j配置" scheme="http://donahue-ldz.github.io/tags/log4j%E9%85%8D%E7%BD%AE/"/>
    
      <category term="log" scheme="http://donahue-ldz.github.io/categories/log/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[日志记录]]></title>
    <link href="http://donahue-ldz.github.io/2015/01/05/%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95/"/>
    <id>http://donahue-ldz.github.io/2015/01/05/日志记录/</id>
    <published>2015-01-05T06:42:11.000Z</published>
    <updated>2015-03-15T05:30:37.000Z</updated>
    <content type="html"><![CDATA[<h2 id="日志服务">日志服务</h2><p>三个目的 ：</p>
<ul>
<li>监视代码中变量的变化情况，周期性的记录到文件中供其他应用进行统计分析工作</li>
<li>跟踪代码运行时轨迹，作为日后审计的依据</li>
<li><p>担当集成开发环境中的调试器的作用，向文件或控制台打印代码的调试信息</p>
<hr>
</li>
</ul>
<h2 id="log4j简介">log4j简介</h2><blockquote>
<p>Log4j是Apache的一个开放源代码项目，通过使用Log4j，我们可以控制日志信息输送的目的地为控制台、文件、GUI组件、甚至可以为套接口服务器、NT的事件记录器、UNIX Syslog守护进程等；我们也可以控制每一条日志的输出格式；通过定义每一条日志信息的级别，我们能够更加细致地控制日志的生成过程。这些可以通过一个配置文件来灵活地进行配置，而不需要修改应用的代码。</p>
<p>此外，通过 Log4j 其他语言接口，您可以在 C 、 C+ + 、 .Net 、 PL/SQL 程序中使用 Log4j ，其语法和用法与在 Java 程序中一样，使得多语言分布式系统得到一个统一一致的日志组件模块。而且，通 过使用各种第三方扩展，您可以很方便地将 Log4j 集成到 J2EE 、 JINI 甚至是 SNMP 应用中。</p>
</blockquote>
<hr>
<h2 id="Log4j三大类构成">Log4j三大类构成</h2><h3 id="Logger">Logger</h3><p>负责输出日志信息，并能够对日志信息进行分类筛选，即决定哪些日志信息应该被输出，哪些该被忽略。Loggers组件输出日志信息时分为5个级别：DEBUG、INFO、WARN、ERROR、FATAL。这五个级别的顺序是：DEBUG&lt;INFO&lt;WARN&lt;ERROR&lt;FATAL。如果设置某个Logger组件的级别是P，则只有级别比P高的日志信息才能输出。Logger是有继承关系的，最上层是rootLogger，定义的其他Logger都会继承rootLogger。</p>
<h3 id="Appender">Appender</h3><p>定义了日志输出目的地，指定日志信息应该被输出到什么地方。输出的目的地可以是控制台、文件或网络设备。<br>格式为：log4j.appender.appenderName =  其中， Log4j提供的appender有以下几种:</p>
<blockquote>
<ol>
<li>org.apache.log4j.ConsoleAppender （控制台）</li>
<li>org.apache.log4j.FileAppender （文件）</li>
<li>org.apache.log4j.DailyRollingFileAppender （每天产生一个日志文件）， </li>
<li>org.apache.log4j.RollingFileAppender （文件大小到达指定尺寸的时候产生一个新的文件） </li>
<li>org.apache.log4j.WriterAppender（将日志信息以流格式发送到任意指定的地方）</li>
<li>org.apache.log4j.JdbcAppender(将日志讯息保存到数据库中) </li>
</ol>
</blockquote>
<p>此外还可以自己定义</p>
<h3 id="Layout">Layout</h3><p>通过在Appender的后面附加Layout来实现格式化输出。</p>
<p>一个Logger可以有多个Appender，每个Appender对应一个Layout。<br>配置日志信息的格式（布局），其语法为：<br>log4j.appender.appenderName.layout = 其中， Log4j 提供的 layout 有以几种：</p>
<blockquote>
<ol>
<li>org.apache.log4j.HTMLLayout （以 HTML 表格形式布局）</li>
<li>org.apache.log4j.SimpleLayout （包含日志信息的级别和信息字符串）</li>
<li>org.apache.log4j.TTCCLayout （包含日志产生的时间、线程、类别等等信息） </li>
<li>org.apache.log4j.PatternLayout （可以灵活地指定布局模式）</li>
</ol>
</blockquote>
<p><code>org.apache.log4j.PatternLayout （可以灵活地指定布局模式）</code></p>
<blockquote>
<p>Log4J 采用类似 C 语言中的 printf 函数的打印格式格式化日志信息，打印参数如下：<br>%m 输出代码中指定的消息<br>%p 输出优先级，即 DEBUG ， INFO ， WARN ， ERROR ， FATAL<br>%r 输出自应用启动到输出该 log 信息耗费的毫秒数<br>%c 输出所属的类目，通常就是所在类的全名<br>%t 输出产生该日志事件的线程名<br>%n 输出一个回车换行符， Windows 平台为 “rn” ， Unix 平台为 “n”<br>%d 输出日志时间点的日期或时间，默认格式为 ISO8601，也可以在其后指定格式，比如： %d{yyy MMM dd HH:mm:ss,SSS} </p>
</blockquote>
<hr>
<h2 id="常见优秀配置配置">常见优秀配置配置</h2><p>详见博文，<a href="http://donahue-ldz.github.io/2015/01/15/log4j%E5%B8%B8%E8%A7%81%E9%85%8D%E7%BD%AE/" target="_blank" rel="external">log4j常见配置</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="日志服务">日志服务</h2><p>三个目的 ：</p>
<ul>
<li>监视代码中变量的变化情况，周期性的记录到文件中供其他应用进行统计分析工作</li>
<li>跟踪代码运行时轨迹，作为日后审计的依据</li>
<li><p>担当集成开发环境中的调试器的作用]]>
    </summary>
    
      <category term="log4j" scheme="http://donahue-ldz.github.io/tags/log4j/"/>
    
      <category term="日志记录" scheme="http://donahue-ldz.github.io/tags/%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95/"/>
    
      <category term="log" scheme="http://donahue-ldz.github.io/categories/log/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[finalize理解]]></title>
    <link href="http://donahue-ldz.github.io/2014/09/28/finalize%E7%90%86%E8%A7%A3/"/>
    <id>http://donahue-ldz.github.io/2014/09/28/finalize理解/</id>
    <published>2014-09-28T09:30:28.000Z</published>
    <updated>2015-03-07T05:15:56.000Z</updated>
    <content type="html"><![CDATA[<p><strong>Object类声明了protect finalize方法</strong></p>
<blockquote>
<p>我们都知道程序初始化的重要性，但是通常会忘记清除工作的重要性，我们知道在c++中有构造函数初始化，有相应的析构函数完成收尾清楚工作</p>
</blockquote>
<p>在java中，有c++样构造函数却没有其相应的析构函数，但是却有一个和析构函数相似的一个finalize方法，很多人容易混淆他们两个，下面是区别：</p>
<ol>
<li><p>c++中析构函数在对象声明周期结束时会被调用，数组等new出来时候，delete等函数时候析构会被调用，如果忘记调用这些函数的时候就会造成内存泄露</p>
</li>
<li><p>java中的finalize方法在GC进行回收之前在做<code>第二次标记</code>的时候会被调用。<br>如果对象没有覆盖finalize()或者已经被调用了一次之后，将不再调用了，如果需要调用的话会被加入一个称为F-queue队列中，然后由虚拟机去自动开一条低优先权的线程去执行，<strong>但是不一定会等待其去执行完</strong>。<br>我们知道对于GC什么时候调用，以及什么时候调用对象的finalize方法这些都是不确定的，一般情况下当内存比较充足时候GC不会去时刻调用的<br>因Gc调用也要消耗资源嘛，对于有些程序而言，有可能某些对象的没有调用GC时候程序已经结束，此时交给<strong>操作系统去回收内存</strong>。</p>
</li>
</ol>
<hr>
<p>所以finalize方法并不总是调用。但是这个方法还是比较有用的，我们知道：<br><code>java的GC之后回收new 出来的对象内存</code><br><code>对于有些时候我们使用native方法，如才c/c++时候采取malloc分配的内存此时GC就不能回收了</code><br>我们也不希望这些内存一直存在，我们可以在finalize方法中去调用native方法的free等函数去试着回收，当finalize方法被调用时候，就象的finalize方法被调用时候，我们可以在里面实现和析构函数相同的功能<br>但是如果没能呗回收了，最起码被回收的机会由原来的0变成大于0了</p>
<p>就是当对有被调用的时候，就不能同等去看待了<br>在现实的使用中我们完全可以忘掉这个方法，她所做的事情完全可以有finally模块去完成，不要使用他吧</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>Object类声明了protect finalize方法</strong></p>
<blockquote>
<p>我们都知道程序初始化的重要性，但是通常会忘记清除工作的重要性，我们知道在c++中有构造函数初始化，有相应的析构函数完成收尾清楚工作</p>
<]]>
    </summary>
    
      <category term="finalize" scheme="http://donahue-ldz.github.io/tags/finalize/"/>
    
      <category term="内存回收" scheme="http://donahue-ldz.github.io/tags/%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6/"/>
    
      <category term="java" scheme="http://donahue-ldz.github.io/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[线程等待]]></title>
    <link href="http://donahue-ldz.github.io/2014/09/15/%E7%BA%BF%E7%A8%8B%E7%AD%89%E5%BE%85/"/>
    <id>http://donahue-ldz.github.io/2014/09/15/线程等待/</id>
    <published>2014-09-15T02:32:21.000Z</published>
    <updated>2015-03-07T05:15:56.000Z</updated>
    <content type="html"><![CDATA[<p><strong>在多线程程序设计中，经常会遇到一个线程等待一个或多个线程的场景<br>遇到这样的场景应该如何解决？</strong></p>
<blockquote>
<ul>
<li>如果是一个线程等待一个线程，则可以通过await()和notify()来实现；</li>
<li>如果是一个线程等待多个线程，则就可以使用CountDownLatch和CyclicBarrier来实现比较好的控制。</li>
</ul>
</blockquote>
<hr>
<h2 id="CountDownLatch应用">CountDownLatch应用</h2><p><code>场景：主要是:一个线程等待多个其他线程</code></p>
<p>例如：百米赛跑：8名运动员同时起跑，由于速度的快慢，肯定有会出现先到终点和晚到终点的情况，而终点有个统计成绩的仪器，当所有选手到达终点时，它会统计所有人的成绩并进行排序，然后把结果发送到汇报成绩的系统。</p>
<p>其实这就是一个CountDownLatch的应用场景：一个线程或多个线程等待其他线程运行达到某一目标后进行自己的下一步工作，而被等待的“其他线程”达到这个目标后继续自己下面的任务。</p>
<p>这个场景中：</p>
<p>被等待的“其他线程”——&gt;8名运动员<br>等待“其他线程”的这个线程——&gt;终点统计成绩的仪器<br>那么，如何来通过CountDownLatch来实现上述场景的线程控制和调度呢？</p>
<blockquote>
<p>jdk中CountDownLatch类有一个常用的构造方法：CountDownLatch(int count)<br>两个常用的方法：await()和countdown()</p>
</blockquote>
<p>其中count是一个计数器中的初始化数字，比如初始化的数字是2，当一个线程里调用了countdown()，则这个计数器就减一，当线程调用了await()，则这个线程就等待这个计数器变为0，当这个计数器变为0时，这个线程继续自己下面的工作。下面是上述CountDownLatch场景的实现：</p>
<p>Work类（运动员）：</p>
<pre><code><span class="keyword">import</span> java.util.concurrent.CountDownLatch;

<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Work</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>{
    <span class="keyword">private</span> <span class="keyword">int</span> id;
    <span class="keyword">private</span> CountDownLatch beginSignal;
    <span class="keyword">private</span> CountDownLatch endSignal;

    <span class="function"><span class="keyword">public</span> <span class="title">Work</span><span class="params">(<span class="keyword">int</span> id, CountDownLatch begin, CountDownLatch end)</span> </span>{
        <span class="keyword">this</span>.id = id;
        <span class="keyword">this</span>.beginSignal = begin;
        <span class="keyword">this</span>.endSignal = end;
    }

    <span class="annotation">@Override</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{
        <span class="keyword">try</span> {
              beginSignal.await();
              System.out.println(<span class="string">"起跑..."</span>);
              System.out.println(<span class="string">"work"</span> + id + <span class="string">"到达终点"</span>);
              endSignal.countDown();
              System.out.println(<span class="string">"work"</span> + id + <span class="string">"继续干其他事情"</span>);
            } <span class="keyword">catch</span> (InterruptedException e) {
                <span class="comment">// TODO Auto-generated catch block</span>
                e.printStackTrace();
            }
    }
</code></pre><p>}<br>Main类（终点统计仪器）：</p>
<pre><code>import java.util.concurrent.CountDownLatch;
<span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Main</span> {

    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{
        CountDownLatch begSignal = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);
        CountDownLatch endSignal = <span class="keyword">new</span> CountDownLatch(<span class="number">8</span>);
        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) {
            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Work(i, begSignal, endSignal)).start();
        }

    <span class="keyword">try</span> {
        begSignal.countDown();  <span class="comment">//统一起跑</span>
        endSignal.await();      <span class="comment">//等待运动员到达终点</span>
        System.<span class="keyword">out</span>.println(<span class="string">"结果发送到汇报成绩的系统"</span>);
        } <span class="keyword">catch</span> (InterruptedException e) {
            e.printStackTrace();
        }
     }
</code></pre><p>}</p>
<hr>
<h2 id="CyclicBarrier的应用">CyclicBarrier的应用</h2><p><code>场景：主要是多个线程之间相互等待，循环等待</code></p>
<p> 例如：有四个游戏玩家玩游戏，游戏有三个关卡，每个关卡必须要所有玩家都到达后才能允许通关。</p>
<p>其实这个场景里的玩家中如果有玩家A先到了关卡1，他必须等待其他所有玩家都到达关卡1时才能通过，也就是说：<br><code>线程之间需要互相等待，这和CountDownLatch的应用场景有区别。</code><br><code>CountDownLatch里的线程是到了运行的目标后继续干自己的其他事情</code><br><code>而这里的线程需要等待其他线程后才能继续完成下面的工作</code>。   </p>
<blockquote>
<p>jdk中CyclicBarrier类有两个常用的构造方法：</p>
<ol>
<li>CyclicBarrier(int parties)<br>这里的parties也是一个计数器，例如，初始化时parties里的计数是3，于是拥有该CyclicBarrier对象的线程当parties的计数为3时就唤醒，注：这里parties里的计数在运行时当调用CyclicBarrier:await()时,计数就加1，一直加到初始的值。</li>
<li>CyclicBarrier(int parties, Runnable barrierAction)<br>这里的parties与上一个构造方法的解释是一样的，这里需要解释的是第二个入参（Runnable barrierAction）,这个参数是一个实现Runnable接口的类的对象，也就是说当parties加到初始值时就出发barrierAction的内容。</li>
</ol>
</blockquote>
<p>下面来实现上述的应用场景：</p>
<p>Player类（玩家类）</p>
<pre><code><span class="keyword">import</span> java.util.concurrent.BrokenBarrierException;
<span class="keyword">import</span> java.util.concurrent.CyclicBarrier;

<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Player</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>{

    <span class="keyword">private</span> CyclicBarrier cyclicBarrier;
    <span class="keyword">private</span> <span class="keyword">int</span> id;

    <span class="function"><span class="keyword">public</span> <span class="title">Player</span><span class="params">(<span class="keyword">int</span> id, CyclicBarrier cyclicBarrier)</span> </span>{
        <span class="keyword">this</span>.cyclicBarrier = cyclicBarrier;
        <span class="keyword">this</span>.id = id;
    }

    <span class="annotation">@Override</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{
        <span class="keyword">try</span> {
            System.out.println(<span class="string">"玩家"</span> + id + <span class="string">"正在玩第一关..."</span>);
            cyclicBarrier.await();
            System.out.println(<span class="string">"玩家"</span> + id + <span class="string">"进入第二关..."</span>);
            } <span class="keyword">catch</span> (InterruptedException e) {
              e.printStackTrace();
        } <span class="keyword">catch</span> (BrokenBarrierException e) {
             e.printStackTrace();
    }
  }
}
</code></pre><p>GameBarrier类（关卡类，这里控制玩家必须全部到达第一关结束的关口才能进入第二关）</p>
<pre><code><span class="keyword">import</span> java.util.concurrent.CyclicBarrier;

<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GameBarrier</span> </span>{

    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{
    CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">4</span>, <span class="keyword">new</span> Runnable() {

        <span class="annotation">@Override</span>
        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{
             System.out.println(<span class="string">"所有玩家进入第二关！"</span>);
        }
     });

    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) {
        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Player(i, cyclicBarrier)).start();
     }
  }
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p><strong>在多线程程序设计中，经常会遇到一个线程等待一个或多个线程的场景<br>遇到这样的场景应该如何解决？</strong></p>
<blockquote>
<ul>
<li>如果是一个线程等待一个线程，则可以通过await()和notify()来实现；</li>]]>
    </summary>
    
      <category term="CyclicBarrier" scheme="http://donahue-ldz.github.io/tags/CyclicBarrier/"/>
    
      <category term="线程" scheme="http://donahue-ldz.github.io/tags/%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="线程等待，CountDownLatch" scheme="http://donahue-ldz.github.io/tags/%E7%BA%BF%E7%A8%8B%E7%AD%89%E5%BE%85%EF%BC%8CCountDownLatch/"/>
    
      <category term="java" scheme="http://donahue-ldz.github.io/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[vim 配色知识]]></title>
    <link href="http://donahue-ldz.github.io/2014/03/23/vim-%E9%85%8D%E8%89%B2/"/>
    <id>http://donahue-ldz.github.io/2014/03/23/vim-配色/</id>
    <published>2014-03-23T08:31:51.000Z</published>
    <updated>2015-03-07T05:17:49.000Z</updated>
    <content type="html"><![CDATA[<p>在vimcolorschemetest站点上，有数以千计的vim主题插件，然而每款主题或多或少都有我们不满意的地方，这就需要我们自己动手来进行扩展。</p>
<hr>
<h2 id="基础知识">基础知识</h2><p>在vim中，主题也是以插件形式存在的。其中系统自带的主题，存放在$VIMRUNTIME/colors文件夹下，以*.vim命名。（注：查看$VIMRUNTIME请在vim中执行 :echo $VIMRUNTIME）<br>用户自定义的主题一般不放在系统目录下，而是放在<code>~/.vim/colors</code>目录下，这样不会干扰到其他用户，同时也方便备份自己的vim配置。<br>更换vim主题的命令为：<br><code>:colorscheme 主题插件名称</code><br>但是这样只能临时改变vim主题，退出后又会恢复原样，如果想永久改变，请在~/.vimrc中添加：<br><code>colorscheme 主题插件名称</code></p>
<p>由于我不使用Windows下的gvim，而是在linux下或远程ssh使用终端下的vim，因此首先需要在~/.vimrc中添加开启256颜色支持：<br><code>set t_Co=256</code><br>为了能在编辑程序时高亮显示关键字，还需要在~/.vimrc中开启语法高亮显示：<br><code>syntax enable</code><br><code>syntax on</code><br>做完上述的准备工作后，让我们正式开始定制主题之旅吧！</p>
<h3 id="主题色调">主题色调</h3><p>在配置其他属性前，首先要配置主题整体的色调，只有两个选择：dark和light（暗色调和亮色调）。对于经常阅读和编写代码的程序员来说，暗色调是更好的选择：</p>
<p><code>set background=dark</code><br><strong><span style="color: #ff00ff;">接下来，需要重新设置一下语法高亮，否则设置不会生效：</span></strong><br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">version</span> &gt; <span class="number">580</span></span><br><span class="line"><span class="keyword">hi</span> clear</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">exists</span>(<span class="string">"syntax_on"</span>)</span><br><span class="line"><span class="keyword">syntax</span> reset</span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure></p>
<h3 id="主题名称">主题名称</h3><p>主题名称是无参数调用 :colorscheme 时返回的信息，用于分辨不同主题，其设置如下：</p>
<p><code>let g:colors_name=&quot;nslib_color256&quot;</code></p>
<h4 id="基础属性">基础属性</h4><p>由于vim可以在黑白终端、彩色终端、GUI界面下运行，所以需要对其分贝进行配置，下面给出一个简要的文档说明：</p>
<blockquote>
<p>term 黑白终端的属性<br>cterm  彩色终端的属性<br>ctermfg 彩色终端前景色<br>ctermbg 彩色终端背景色<br>gui GUI属性<br>guifg GUI前景色<br>guibg GUI背景色</p>
</blockquote>
<p>对于黑白终端，我们没有配置的必要，因此主要的配置工作集中在彩色终端与GUI界面上，又由于彩色终端与GUI界面的配置只是关键字不同，因此这里只选取彩色终端进行说明。</p>
<a id="more"></a>
<p>由于不是所有终端都支持256色，因此使用一些安全色会使我们的主题更有移植性，而GUI可以支持所有颜色，不在考虑范围之内，vim文档给出的安全色如下：</p>
<blockquote>
<p>“0 Black<br>“1 DarkBlue<br>“2 DarkGreen<br>“3 DarkCyan<br>“4 DarkRed<br>“5 DarkMagenta<br>“6 Brown, DarkYellow<br>“7 LightGray, LightGrey, Gray, Grey<br>“8 DarkGray, DarkGrey<br>“9 Blue, LightBlue<br>“10 Green, LightGreen<br>“11 Cyan, LightCyan<br>“12 Red, LightRed<br>“13 Magenta, LightMagenta<br>“14 Yellow, LightYellow<br>“15 White</p>
</blockquote>
<!--more-->
<h3 id="配色语法">配色语法</h3><p>下面举例说明配色语法：<br><code>hi Type ctermfg=LightYellow ctermbg=Black cterm=bold</code><br>其中，hi是highlight命令的缩写，用于高亮配置；Type是要配色的元素名称；参数采用的是Key=Value的形式。</p>
<p>元素列表<br>配置颜色的语法非常简单，无需累赘，下面将分类介绍常用的元素标签：</p>
<h4 id="状态栏提示信息">状态栏提示信息</h4><blockquote>
<p>hi StatusLine 状态栏<br>hi StatusLineNC 非当前窗口的状态栏<br>ErrorMsg 错误信息<br>WarningMsg 警告信息<br>ModeMsg 当前模式<br>MoreMsg 其他文本<br>Question 询问用户<br>Error 错误</p>
</blockquote>
<h4 id="文本搜索">文本搜索</h4><blockquote>
<p>hi IncSearch 增量搜索时匹配的文本符串<br>hi Search 匹配的文本串</p>
</blockquote>
<h4 id="弹出菜单">弹出菜单</h4><blockquote>
<p>Pmenu 弹出菜单<br>PmenuSel 菜单当前选择项</p>
</blockquote>
<h4 id="窗体边框相关">窗体边框相关</h4><blockquote>
<p>VertSplit 垂直分割窗口的边框<br>LineNr 行号<br>Cursor 光标所在字符<br>CursorLine 光标所在行<br>ColorColumn 光标所在列<br>ColorColumn 标尺<br>NonText 窗口尾部的~和@，以及文本里实际不显示的字符</p>
</blockquote>
<h4 id="diff模式">diff模式</h4><blockquote>
<p>DiffAdd diff模式增加的行<br>DiffChange diff模式改变的行<br>DiffDelete diff模式删除的行<br>DiffText diff模式插入文本</p>
</blockquote>
<h4 id="C/C++语法">C/C++语法</h4><blockquote>
<p>Comment 注释<br>PreProc 预处理<br>Type 数据类型<br>Constant 常量<br>Statement 控制语句<br>Special 字符串中的中的特殊字符<br>String 字符串<br>cCppString Cpp字符串<br>Number 数字<br>Todo TODO、HACK、FIXME等标签</p>
</blockquote>
<h3 id="我的主题">我的主题</h3><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">set <span class="variable">background=</span>dark</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> version &amp;gt; <span class="number">580</span></span><br><span class="line">hi clear</span><br><span class="line"><span class="keyword">if</span> exists(<span class="string">"syntax_on"</span>)</span><br><span class="line">syntax reset</span><br><span class="line">endif</span><br><span class="line">endif</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> g:<span class="variable">colors_name=</span><span class="string">"nslib_color256"</span></span><br><span class="line"></span><br><span class="line">hi Normal <span class="variable">ctermfg=</span>Grey <span class="variable">ctermbg=</span>Black</span><br><span class="line">hi ColorColumn <span class="variable">ctermfg=</span>White <span class="variable">ctermbg=</span>Grey</span><br><span class="line">·</span><br><span class="line">hi ErrorMsg <span class="variable">term=</span>standout</span><br><span class="line">hi ErrorMsg <span class="variable">ctermfg=</span>LightBlue <span class="variable">ctermbg=</span>DarkBlue</span><br><span class="line">hi WarningMsg <span class="variable">term=</span>standout</span><br><span class="line">hi WarningMsg <span class="variable">ctermfg=</span>LightBlue <span class="variable">ctermbg=</span>DarkBlue</span><br><span class="line">hi ModeMsg <span class="variable">term=</span>bold <span class="variable">cterm=</span>bold</span><br><span class="line">hi ModeMsg <span class="variable">ctermfg=</span>LightBlue <span class="variable">ctermbg=</span>Black</span><br><span class="line">hi MoreMsg <span class="variable">term=</span>bold <span class="variable">ctermfg=</span>LightGreen</span><br><span class="line">hi MoreMsg <span class="variable">ctermfg=</span>LightBlue <span class="variable">ctermbg=</span>Black</span><br><span class="line">hi Question <span class="variable">term=</span>standout <span class="variable">gui=</span>bold</span><br><span class="line">hi Question <span class="variable">ctermfg=</span>LightBlue <span class="variable">ctermbg=</span>Black</span><br><span class="line">hi Error <span class="variable">term=</span>bold <span class="variable">cterm=</span>bold</span><br><span class="line">hi Error <span class="variable">ctermfg=</span>LightBlue <span class="variable">ctermbg=</span>Black</span><br><span class="line">·</span><br><span class="line">hi LineNr <span class="variable">ctermfg=</span>LightBlue <span class="variable">ctermbg=</span>Black</span><br><span class="line">hi CursorColumn <span class="variable">ctermfg=</span>White <span class="variable">ctermbg=</span>Grey</span><br><span class="line">hi CursorLine <span class="variable">ctermfg=</span>LightBlue <span class="variable">ctermbg=</span>Black</span><br><span class="line">hi ColorColumn <span class="variable">ctermfg=</span>White <span class="variable">ctermbg=</span>Grey</span><br><span class="line">·</span><br><span class="line">hi IncSearch <span class="variable">ctermfg=</span>Black <span class="variable">ctermbg=</span>DarkGrey</span><br><span class="line">hi Search <span class="variable">ctermfg=</span>Black <span class="variable">ctermbg=</span>DarkGrey</span><br><span class="line">hi StatusLine <span class="variable">term=</span>bold <span class="variable">cterm=</span>bold</span><br><span class="line">hi StatusLine <span class="variable">ctermfg=</span>Black <span class="variable">ctermbg=</span>Grey</span><br><span class="line">hi StatusLineNC <span class="variable">term=</span>bold <span class="variable">cterm=</span>bold</span><br><span class="line">hi StatusLineNC <span class="variable">ctermfg=</span>Black <span class="variable">ctermbg=</span>Grey</span><br><span class="line">·</span><br><span class="line">hi VertSplit <span class="variable">ctermfg=</span>Grey <span class="variable">ctermbg=</span>Grey</span><br><span class="line">hi Visual <span class="variable">term=</span>bold <span class="variable">cterm=</span>bold</span><br><span class="line">hi Visual <span class="variable">ctermfg=</span>Black <span class="variable">ctermbg=</span>Grey</span><br><span class="line">·</span><br><span class="line">highlight Pmenu <span class="variable">ctermfg=</span>Black <span class="variable">ctermbg=</span>Grey</span><br><span class="line">highlight PmenuSel <span class="variable">ctermfg=</span>LightBlue <span class="variable">ctermbg=</span>DarkBlue</span><br><span class="line">·</span><br><span class="line">hi Comment <span class="variable">ctermfg=</span>DarkCyan <span class="variable">ctermbg=</span>Black</span><br><span class="line">hi PreProc <span class="variable">ctermfg=</span>Blue <span class="variable">ctermbg=</span>Black</span><br><span class="line">hi Type <span class="variable">ctermfg=</span>LightYellow <span class="variable">ctermbg=</span>Black <span class="variable">cterm=</span>bold</span><br><span class="line">hi Constant <span class="variable">ctermfg=</span>Blue <span class="variable">ctermbg=</span>Black <span class="variable">cterm=</span>bold</span><br><span class="line">hi Statement <span class="variable">ctermfg=</span>LightYellow <span class="variable">ctermbg=</span>Black <span class="variable">cterm=</span>bold</span><br><span class="line">hi Special <span class="variable">ctermfg=</span>Red <span class="variable">ctermbg=</span>Black <span class="variable">cterm=</span>bold</span><br><span class="line">hi SpecialKey <span class="variable">ctermfg=</span>Red <span class="variable">ctermbg=</span>Black <span class="variable">cterm=</span>bold</span><br><span class="line">hi Number <span class="variable">ctermfg=</span>Blue <span class="variable">ctermbg=</span>Black</span><br><span class="line">hi cCppString <span class="variable">ctermfg=</span>Red <span class="variable">ctermbg=</span>Black</span><br><span class="line">hi String <span class="variable">ctermfg=</span>Red <span class="variable">ctermbg=</span>Black</span><br><span class="line">hi Identifier <span class="variable">ctermfg=</span>Red <span class="variable">ctermbg=</span>Black <span class="variable">cterm=</span>bold</span><br><span class="line">hi Todo <span class="variable">ctermfg=</span>Black <span class="variable">ctermbg=</span>Gray <span class="variable">cterm=</span>bold</span><br><span class="line">hi NonText <span class="variable">ctermfg=</span>LightBlue <span class="variable">ctermbg=</span>Black</span><br><span class="line">hi Directory <span class="variable">ctermfg=</span>Blue <span class="variable">ctermbg=</span>Black</span><br><span class="line">hi Folded <span class="variable">ctermfg=</span>DarkBlue <span class="variable">ctermbg=</span>Black <span class="variable">cterm=</span>bold</span><br><span class="line">hi FoldColumn <span class="variable">ctermfg=</span>LightBlue <span class="variable">ctermbg=</span>Black</span><br><span class="line">hi Underlined <span class="variable">ctermfg=</span>LightBlue <span class="variable">ctermbg=</span>Black <span class="variable">cterm=</span>underline</span><br><span class="line">hi Title <span class="variable">ctermfg=</span>LightBlue <span class="variable">ctermbg=</span>Black</span><br><span class="line">hi Ignore <span class="variable">ctermfg=</span>LightBlue <span class="variable">ctermbg=</span>Black</span><br><span class="line"></span><br><span class="line">hi Directory <span class="variable">ctermfg=</span>LightBlue <span class="variable">ctermbg=</span>Black</span><br><span class="line">hi browseSynopsis <span class="variable">ctermfg=</span>LightBlue <span class="variable">ctermbg=</span>Black</span><br><span class="line">hi browseCurDir <span class="variable">ctermfg=</span>LightBlue <span class="variable">ctermbg=</span>Black</span><br><span class="line">hi favoriteDirectory <span class="variable">ctermfg=</span>LightBlue <span class="variable">ctermbg=</span>Black</span><br><span class="line">hi browseDirectory <span class="variable">ctermfg=</span>LightBlue <span class="variable">ctermbg=</span>Black</span><br><span class="line">hi browseSuffixInfo <span class="variable">ctermfg=</span>LightBlue <span class="variable">ctermbg=</span>Black</span><br><span class="line">hi browseSortBy <span class="variable">ctermfg=</span>LightBlue <span class="variable">ctermbg=</span>Black</span><br><span class="line">hi browseFilter <span class="variable">ctermfg=</span>LightBlue <span class="variable">ctermbg=</span>Black</span><br><span class="line">hi browseFiletime <span class="variable">ctermfg=</span>LightBlue <span class="variable">ctermbg=</span>Black</span><br><span class="line">hi browseSuffixes <span class="variable">ctermfg=</span>LightBlue <span class="variable">ctermbg=</span>Black</span><br><span class="line"></span><br><span class="line">hi TagListComment <span class="variable">ctermfg=</span>LightBlue <span class="variable">ctermbg=</span>Black</span><br><span class="line">hi TagListFileName <span class="variable">ctermfg=</span>LightBlue <span class="variable">ctermbg=</span>Black</span><br><span class="line">hi TagListTitle <span class="variable">ctermfg=</span>LightBlue <span class="variable">ctermbg=</span>Black</span><br><span class="line">hi TagListTagScope <span class="variable">ctermfg=</span>LightBlue <span class="variable">ctermbg=</span>Black</span><br><span class="line">hi TagListTagName <span class="variable">ctermfg=</span>LightBlue <span class="variable">ctermbg=</span>Black</span><br><span class="line">hi Tag <span class="variable">ctermfg=</span>LightBlue <span class="variable">ctermbg=</span>Black</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<p>在vimcolorschemetest站点上，有数以千计的vim主题插件，然而每款主题或多或少都有我们不满意的地方，这就需要我们自己动手来进行扩展。</p>
<hr>
<h2 id="基础知识">基础知识</h2><p>在vim中，主题也是以插件形式存在的。其中系统自带的主题，存放在$VIMRUNTIME/colors文件夹下，以*.vim命名。（注：查看$VIMRUNTIME请在vim中执行 :echo $VIMRUNTIME）<br>用户自定义的主题一般不放在系统目录下，而是放在<code>~/.vim/colors</code>目录下，这样不会干扰到其他用户，同时也方便备份自己的vim配置。<br>更换vim主题的命令为：<br><code>:colorscheme 主题插件名称</code><br>但是这样只能临时改变vim主题，退出后又会恢复原样，如果想永久改变，请在~/.vimrc中添加：<br><code>colorscheme 主题插件名称</code></p>
<p>由于我不使用Windows下的gvim，而是在linux下或远程ssh使用终端下的vim，因此首先需要在~/.vimrc中添加开启256颜色支持：<br><code>set t_Co=256</code><br>为了能在编辑程序时高亮显示关键字，还需要在~/.vimrc中开启语法高亮显示：<br><code>syntax enable</code><br><code>syntax on</code><br>做完上述的准备工作后，让我们正式开始定制主题之旅吧！</p>
<h3 id="主题色调">主题色调</h3><p>在配置其他属性前，首先要配置主题整体的色调，只有两个选择：dark和light（暗色调和亮色调）。对于经常阅读和编写代码的程序员来说，暗色调是更好的选择：</p>
<p><code>set background=dark</code><br><strong><span style="color: #ff00ff;">接下来，需要重新设置一下语法高亮，否则设置不会生效：</span></strong><br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">version</span> &gt; <span class="number">580</span></span><br><span class="line"><span class="keyword">hi</span> clear</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">exists</span>(<span class="string">"syntax_on"</span>)</span><br><span class="line"><span class="keyword">syntax</span> reset</span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure></p>
<h3 id="主题名称">主题名称</h3><p>主题名称是无参数调用 :colorscheme 时返回的信息，用于分辨不同主题，其设置如下：</p>
<p><code>let g:colors_name=&quot;nslib_color256&quot;</code></p>
<h4 id="基础属性">基础属性</h4><p>由于vim可以在黑白终端、彩色终端、GUI界面下运行，所以需要对其分贝进行配置，下面给出一个简要的文档说明：</p>
<blockquote>
<p>term 黑白终端的属性<br>cterm  彩色终端的属性<br>ctermfg 彩色终端前景色<br>ctermbg 彩色终端背景色<br>gui GUI属性<br>guifg GUI前景色<br>guibg GUI背景色</p>
</blockquote>
<p>对于黑白终端，我们没有配置的必要，因此主要的配置工作集中在彩色终端与GUI界面上，又由于彩色终端与GUI界面的配置只是关键字不同，因此这里只选取彩色终端进行说明。</p>]]>
    
    </summary>
    
      <category term="vim" scheme="http://donahue-ldz.github.io/tags/vim/"/>
    
  </entry>
  
</feed>