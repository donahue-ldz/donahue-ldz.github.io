<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[心缘冰河]]></title>
  <subtitle><![CDATA[写出我人生,coding]]></subtitle>
  <link href="//atom.xml" rel="self"/>
  <link href="http://donahue-ldz.github.io/"/>
  <updated>2015-03-06T04:21:39.000Z</updated>
  <id>http://donahue-ldz.github.io/</id>
  
  <author>
    <name><![CDATA[donahue]]></name>
    <email><![CDATA[ldz2012yn@gmail.com]]></email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[MarkDown语法入门]]></title>
    <link href="http://donahue-ldz.github.io/2015/02/15/MarkDown%E8%AF%AD%E6%B3%95%E5%85%A5%E9%97%A8/"/>
    <id>http://donahue-ldz.github.io/2015/02/15/MarkDown语法入门/</id>
    <published>2015-02-15T02:32:21.000Z</published>
    <updated>2015-03-06T04:21:39.000Z</updated>
    <content type="html"><![CDATA[<h2 id="MarkDown_理念">MarkDown 理念</h2><blockquote>
<p>让文档更容易读、写和随意改。HTML 是一种发布的格式，Markdown 是一种书写的格式。就这样，Markdown 的格式语法只涵盖纯文本可以涵盖的范围.</p>
</blockquote>
<hr>
<h2 id="注意">注意</h2><blockquote>
<p>不在 Markdown 涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写。不需要额外标注这是 HTML 或是 Markdown；只要直接加标签就可以了。<br>要制约的只有一些 HTML 区块元素――比如 <code>&lt;div&gt;、&lt;table&gt;、&lt;pre&gt;、&lt;p&gt;</code>等标签，必须在 <strong>前后</strong> 加上 <strong>空行</strong> 与其它内容区隔开，还要求它们的开始标签与结尾标签不能用制表符或空格来缩进。Markdown 的生成器有足够智能，不会在 HTML 区块标签外加上不必要的 <code>&lt;p&gt;</code> 标签。</p>
</blockquote>
<hr>
<h1 id="常见的使用">常见的使用</h1><h3 id="标题">标题</h3><p>Markdown 支持两种标题的语法，类 Setext 和类 atx 形式。</p>
<blockquote>
<ol>
<li>类 Setext 形式是用底线的形式(在需要成为标题的文字下方加入…)，利用 = （最高阶标题）和 - （第二阶标题)</li>
<li>类 Atx 形式则是在行首插入 1 到 6 个 # ，对应到标题 1 到 6 阶</li>
</ol>
</blockquote>
<p><strong><em>你可以选择性地「闭合」类 atx 样式的标题，这纯粹只是美观用的若是觉得这样看起来比较舒适，你就可以在行尾加上<br>而行尾的 # 数量也不用和开头一样（行首的井字符数量决定标题的阶数）</em></strong></p>
<hr>
<h3 id="区块引用_Blockquotes">区块引用 Blockquotes</h3><ul>
<li>Markdown 标记区块引用是使用类似 email 中用 &gt; 的引用方式。</li>
<li>Markdown 也允许你偷懒只在整个段落的第一行最前面加上 &gt; </li>
<li>区块引用可以嵌套（例如：引用内的引用），只要根据层次加上不同数量的 &gt; </li>
<li>引用的区块内也可以使用其他的 Markdown 语法，包括标题、列表、代码区块等</li>
</ul>
<hr>
<h3 id="列表">列表</h3><p>Markdown 支持有序列表和无序列表。</p>
<ul>
<li>无序列表使用星号、加号或是减号作为列表标记 : <code>*+空格</code></li>
<li>有序列表则使用数字接着一个英文句点：<code>数字+句点+空格</code>  <strong>可以完全不在意数字的正确和顺序</strong></li>
<li>列表项目可以包含多个段落，每个项目下的段落都必须缩进 4 个空格或是 1 个制表符</li>
<li>如果要在列表项目内放进引用，那 &gt; 就需要缩进</li>
<li><code>如果要放代码区块的话，该区块就需要缩进两次，也就是 8 个空格或是 2 个制表符</code></li>
<li>在行首出现数字-句点-空白，要避免这样的状况，你可以在句点前面加上反斜杠     </li>
</ul>
<hr>
<h3 id="代码区块">代码区块</h3><p>Markdown 会用<code>&lt;pre&gt;</code> 和 <code>&lt;code&gt;</code> 标签来把代码区块包起来.<br>要在 Markdown 中建立代码区块很简单，只要简单地缩进 4 个空格或是 1 个制表符就可以(<strong>中间需要一行空行隔开</strong>)，一个代码区块会一直持续到没有缩进的那一行（或是文件结尾）。例如，下面的输入：</p>
<p>这是一个普通段落：</p>
<pre><code><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[]args)
</code></pre><ul>
<li>在代码区块里面， &amp; 、 &lt; 和 &gt; 会自动转成 HTML 实体，这样的方式让你非常容易使用 Markdown 插入范例用的 HTML 原始码，只需要复制贴上，再加上缩进就可以了，剩下的 Markdown 都会帮你处理</li>
<li>代码区块中，一般的 Markdown 语法不会被转换，像是星号便只是星号，这表示你可以很容易地以 Markdown 语法撰写 Markdown 语法相关的文件</li>
</ul>
<hr>
<h3 id="分割线">分割线</h3><p>你可以在一行中用三个以上的<code>星号、减号、底线</code>来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线.</p>
<hr>
<h3 id="链接">链接</h3><p>Markdown 支持两种形式的链接语法： 行内式和参考式两种形式。</p>
<p>不管是哪一种，链接文字都是用 [方括号] 来标记。</p>
<ul>
<li>要建立一个行内式的链接，只要在方块括号后面紧接着圆括号并插入网址链接即可，如果你还想要加上链接的 title 文字，只要在网址后面，用双引号把 title 文字包起来即可，例如：<blockquote>
<p><code>This is [an example](http://example.com/ &quot;Title&quot;) inline link.</code><br><code>[This link](http://example.net/) has no title attribute.</code></p>
</blockquote>
</li>
</ul>
<p><code>如果你是要链接到同样主机的资源，你可以使用相对路径：See my [About](/about/) page for details.</code></p>
<ul>
<li>参考式的链接是在链接文字的括号后面再接上另一个方括号，而在第二个方括号里面要填入用以辨识链接的标记：<blockquote>
<p><code>This is [an example] [id] reference-style link</code>.<br>你也可以选择性地在两个方括号中间加上一个空格：<br><code>This is [an example] [id] reference-style link</code>.<br>接着，在文件的任意处，你可以把这个标记的链接内容定义出来：</p>
</blockquote>
</li>
</ul>
<p><code>[id]: http://example.com/  &quot;Optional Title Here&quot;</code> </p>
<h3 id="强调">强调</h3><p>Markdown 使用星号（<em>）和底线（_）作为标记强调字词的符号，被 </em> 或 <em> 包围的字词会被转成用 <code>&lt;em&gt;</code> 标签包围，用两个 * 或 </em> 包起来的话，则会被转成 <code>&lt;strong&gt;</code></p>
<h3 id="代码">代码</h3><ul>
<li>如果要标记一小段行内代码，你可以用反引号把它包起来（`）</li>
<li>如果要在代码区段内插入反引号，你可以用多个反引号来开启和结束代码区段：</li>
</ul>
<h3 id="图片">图片</h3><p>markdown 使用一种和链接很相似的语法来标记图片，同样也允许两种样式： 行内式和参考式。<br>行内式的图片语法看起来像是：</p>
<p><code>![Alt text](/path/to/img.jpg)</code></p>
<p><code>![Alt text](/path/to/img.jpg &quot;Optional title&quot;)</code><br>详细叙述如下：</p>
<p>一个惊叹号 !<br>接着一个方括号，里面放上图片的替代文字<br>接着一个普通括号，里面放上图片的网址，最后还可以用引号包住并加上 选择性的 ‘title’ 文字。<br>参考式的图片语法则长得像这样：</p>
<p><code>![Alt text][id]</code><br>「id」是图片参考的名称，图片参考的定义方式则和连结参考一样：</p>
<p><code>[id]: url/to/image  &quot;Optional title attribute&quot;</code><br>到目前为止， Markdown 还没有办法指定图片的宽高，如果你需要的话，你可以使用普通的 <code>&lt;img&gt;</code> 标签。</p>
<hr>
<h3 id="自动链接">自动链接</h3><blockquote>
<p>Markdown 支持以比较简短的自动链接形式来处理网址和电子邮件信箱，只要是用尖括号包起来， Markdown 就会自动把它转成链接。一般网址的链接文字就和链接地址一样，例如：<br><code>&lt;http://example.com/&gt;</code><br>Markdown 会转为：<br><code>&lt;a href=&quot;http://example.com/&quot;&gt;http://example.com/&lt;/a&gt;</code><br>邮址的自动链接也很类似，只是 Markdown 会先做一个编码转换的过程，把文字字符转成 16 进位码的 HTML 实体，这样的格式可以糊弄一些不好的邮址收集机器人<br><code>&lt;address@example.com&gt;</code></p>
</blockquote>
<hr>
<h3 id="反斜杠">反斜杠</h3><p><strong>也就是程序员所熟悉的转义符号</strong></p>
<hr>
<p><a href="http://wowubuntu.com/markdown/" target="_blank" rel="external">参考资料</a><a href="http://wowubuntu.com/markdown/" target="_blank" rel="external">http://wowubuntu.com/markdown/</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="MarkDown_理念">MarkDown 理念</h2><blockquote>
<p>让文档更容易读、写和随意改。HTML 是一种发布的格式，Markdown 是一种书写的格式。就这样，Markdown 的格式语法只涵盖纯文本可以涵盖的范围.</p>
</bl]]>
    </summary>
    
      <category term="MarkDown" scheme="http://donahue-ldz.github.io/tags/MarkDown/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[log4j常见配置]]></title>
    <link href="http://donahue-ldz.github.io/2015/01/15/log4j%E5%B8%B8%E8%A7%81%E9%85%8D%E7%BD%AE/"/>
    <id>http://donahue-ldz.github.io/2015/01/15/log4j常见配置/</id>
    <published>2015-01-15T07:27:41.000Z</published>
    <updated>2015-03-06T02:22:41.000Z</updated>
    <content type="html"><![CDATA[<h2 id="xml类型的配置">xml类型的配置</h2><p>Log4j配置文件实现了输出到控制台、文件、固定大小文件、发送日志邮件、输出到数据库日志表、自定义标签等全套功能。 </p>
<pre><code><span class="pi">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span>  
<span class="doctype">&lt;!DOCTYPE log4j:configuration SYSTEM "log4j.dtd"&gt;</span>  

<span class="tag">&lt;<span class="title">log4j:configuration</span>&gt;</span>  

 <span class="comment">&lt;!--自定义输出到控制台--&gt;</span>
 <span class="tag">&lt;<span class="title">appender</span> <span class="attribute">name</span>=<span class="value">"CONSOLE"</span> <span class="attribute">class</span>=<span class="value">"org.apache.log4j.ConsoleAppender"</span>&gt;</span>
  <span class="tag">&lt;<span class="title">layout</span> <span class="attribute">class</span>=<span class="value">"org.apache.log4j.PatternLayout"</span>&gt;</span>  
   <span class="tag">&lt;<span class="title">param</span> <span class="attribute">name</span>=<span class="value">"ConversionPattern"</span>  
    <span class="attribute">value</span>=<span class="value">"%d - %c -%-4r [%t] %-5p %x - %m%n"</span> /&gt;</span>  
  <span class="tag">&lt;/<span class="title">layout</span>&gt;</span>  

  <span class="comment">&lt;!--限制输出级别--&gt;</span>  
  <span class="tag">&lt;<span class="title">filter</span> <span class="attribute">class</span>=<span class="value">"org.apache.log4j.varia.LevelRangeFilter"</span>&gt;</span>  
   <span class="tag">&lt;<span class="title">param</span> <span class="attribute">name</span>=<span class="value">"LevelMax"</span> <span class="attribute">value</span>=<span class="value">"ERROR"</span>/&gt;</span>  
   <span class="tag">&lt;<span class="title">param</span> <span class="attribute">name</span>=<span class="value">"LevelMin"</span> <span class="attribute">value</span>=<span class="value">"TRACE"</span>/&gt;</span>  
  <span class="tag">&lt;/<span class="title">filter</span>&gt;</span>  
 <span class="tag">&lt;/<span class="title">appender</span>&gt;</span>  

 <span class="comment">&lt;!--输出到文件--&gt;</span>
 <span class="tag">&lt;<span class="title">appender</span> <span class="attribute">name</span>=<span class="value">"FILE"</span> <span class="attribute">class</span>=<span class="value">"org.apache.log4j.FileAppender"</span>&gt;</span>  
  <span class="tag">&lt;<span class="title">param</span> <span class="attribute">name</span>=<span class="value">"File"</span> <span class="attribute">value</span>=<span class="value">"log4j.log"</span>/&gt;</span>  
  <span class="tag">&lt;<span class="title">layout</span> <span class="attribute">class</span>=<span class="value">"org.apache.log4j.PatternLayout"</span>&gt;</span>  
   <span class="tag">&lt;<span class="title">param</span> <span class="attribute">name</span>=<span class="value">"ConversionPattern"</span>  
    <span class="attribute">value</span>=<span class="value">"%d - %c -%-4r [%t] %-5p %x - %m%n"</span> /&gt;</span>  
  <span class="tag">&lt;/<span class="title">layout</span>&gt;</span>  
 <span class="tag">&lt;/<span class="title">appender</span>&gt;</span>    

 <span class="comment">&lt;!--输出到数据库--&gt;</span>
 <span class="tag">&lt;<span class="title">appender</span> <span class="attribute">name</span>=<span class="value">"DATABASE"</span> <span class="attribute">class</span>=<span class="value">"org.apache.log4j.jdbc.JDBCAppender"</span>&gt;</span>  
  <span class="tag">&lt;<span class="title">param</span> <span class="attribute">name</span>=<span class="value">"URL"</span> <span class="attribute">value</span>=<span class="value">"jdbc:oracle:thin:@192.168.0.59:1521:oanet"</span>/&gt;</span>  
  <span class="tag">&lt;<span class="title">param</span> <span class="attribute">name</span>=<span class="value">"driver"</span> <span class="attribute">value</span>=<span class="value">"oracle.jdbc.driver.OracleDriver"</span>/&gt;</span>  
  <span class="tag">&lt;<span class="title">param</span> <span class="attribute">name</span>=<span class="value">"user"</span> <span class="attribute">value</span>=<span class="value">"user"</span>/&gt;</span>  
  <span class="tag">&lt;<span class="title">param</span> <span class="attribute">name</span>=<span class="value">"password"</span> <span class="attribute">value</span>=<span class="value">"password"</span>/&gt;</span>      
  <span class="tag">&lt;<span class="title">layout</span> <span class="attribute">class</span>=<span class="value">"org.apache.log4j.PatternLayout"</span>&gt;</span>  
   <span class="tag">&lt;<span class="title">param</span> <span class="attribute">name</span>=<span class="value">"ConversionPattern"</span> 
   <span class="attribute">value</span>=<span class="value">"INSERT INTO hdczoa.LOG4J(stamp,thread,info_level,class,message) VALUES ('%d', '%t', '%p', '%c', %m)"</span> /&gt;</span>  
  <span class="tag">&lt;/<span class="title">layout</span>&gt;</span>  
 <span class="tag">&lt;/<span class="title">appender</span>&gt;</span>  

 <span class="comment">&lt;!-- 发邮件（只有ERROR时才会发送！） --&gt;</span>  
 <span class="tag">&lt;<span class="title">appender</span> <span class="attribute">name</span>=<span class="value">"MAIL"</span>  <span class="attribute">class</span>=<span class="value">"org.apache.log4j.net.SMTPAppender"</span>&gt;</span>  
  <span class="tag">&lt;<span class="title">param</span> <span class="attribute">name</span>=<span class="value">"threshold"</span> <span class="attribute">value</span>=<span class="value">"debug"</span> /&gt;</span>  
  <span class="comment">&lt;!-- 日志的错误级别  
   &lt;param name="threshold" value="fatal"/&gt;  
  --&gt;</span>  
  <span class="comment">&lt;!-- 缓存文件大小，日志达到512K时发送Email --&gt;</span>  
  <span class="tag">&lt;<span class="title">param</span> <span class="attribute">name</span>=<span class="value">"BufferSize"</span> <span class="attribute">value</span>=<span class="value">"512"</span> /&gt;</span><span class="comment">&lt;!-- 单位K --&gt;</span>  
  <span class="tag">&lt;<span class="title">param</span> <span class="attribute">name</span>=<span class="value">"From"</span> <span class="attribute">value</span>=<span class="value">"test@163.com"</span> /&gt;</span>  
  <span class="tag">&lt;<span class="title">param</span> <span class="attribute">name</span>=<span class="value">"SMTPHost"</span> <span class="attribute">value</span>=<span class="value">"smtp.163.com"</span> /&gt;</span>  
  <span class="tag">&lt;<span class="title">param</span> <span class="attribute">name</span>=<span class="value">"Subject"</span> <span class="attribute">value</span>=<span class="value">"juyee-log4jMessage"</span> /&gt;</span>  
  <span class="comment">&lt;!--收件人--&gt;</span>
  <span class="tag">&lt;<span class="title">param</span> <span class="attribute">name</span>=<span class="value">"To"</span> <span class="attribute">value</span>=<span class="value">"reciever@163.com"</span> /&gt;</span>
  <span class="comment">&lt;!--发件人登陆邮箱服务器--&gt;</span>
  <span class="tag">&lt;<span class="title">param</span> <span class="attribute">name</span>=<span class="value">"SMTPUsername"</span> <span class="attribute">value</span>=<span class="value">"user"</span> /&gt;</span>  
  <span class="tag">&lt;<span class="title">param</span> <span class="attribute">name</span>=<span class="value">"SMTPPassword"</span> <span class="attribute">value</span>=<span class="value">"password"</span> /&gt;</span>  
  <span class="tag">&lt;<span class="title">layout</span> <span class="attribute">class</span>=<span class="value">"org.apache.log4j.PatternLayout"</span>&gt;</span>  
   <span class="tag">&lt;<span class="title">param</span> <span class="attribute">name</span>=<span class="value">"ConversionPattern"</span>  
    <span class="attribute">value</span>=<span class="value">"%-d{yyyy-MM-dd HH:mm:ss.SSS} [%p]-[%c] %m%n"</span> /&gt;</span>  
  <span class="tag">&lt;/<span class="title">layout</span>&gt;</span>  
 <span class="tag">&lt;/<span class="title">appender</span>&gt;</span>  

 <span class="tag">&lt;<span class="title">appender</span> <span class="attribute">name</span>=<span class="value">"ASYNC"</span> <span class="attribute">class</span>=<span class="value">"org.apache.log4j.AsyncAppender"</span>&gt;</span>  
  <span class="tag">&lt;<span class="title">param</span> <span class="attribute">name</span>=<span class="value">"BufferSize"</span> <span class="attribute">value</span>=<span class="value">"256"</span> /&gt;</span>  
  <span class="tag">&lt;<span class="title">appender-ref</span> <span class="attribute">ref</span>=<span class="value">"DATABASE"</span> /&gt;</span>  
 <span class="tag">&lt;/<span class="title">appender</span>&gt;</span>  

 <span class="comment">&lt;!--通过&lt;logger&gt;&lt;/logger&gt;的定义可以将各个包中的类日志输出到不同的日志文件中--&gt;</span>  
 <span class="tag">&lt;<span class="title">logger</span> <span class="attribute">name</span>=<span class="value">"packageName"</span> <span class="attribute">additivity</span>=<span class="value">"false"</span>&gt;</span>     
        <span class="tag">&lt;<span class="title">level</span> <span class="attribute">value</span>=<span class="value">"WARN"</span> /&gt;</span>     
        <span class="tag">&lt;<span class="title">appender-ref</span> <span class="attribute">ref</span>=<span class="value">"CONSOLE"</span> /&gt;</span>     
    <span class="tag">&lt;/<span class="title">logger</span>&gt;</span>  

 <span class="comment">&lt;!--通过&lt;category&gt;&lt;/category&gt;的定义可以将各个包中的类日志输出到不同的日志文件中--&gt;</span>  
 <span class="tag">&lt;<span class="title">category</span> <span class="attribute">name</span>=<span class="value">"com.litt3"</span>&gt;</span>     
    <span class="tag">&lt;<span class="title">level</span> <span class="attribute">value</span>=<span class="value">"DEBUG"</span> /&gt;</span>   
       <span class="tag">&lt;<span class="title">appender-ref</span> <span class="attribute">ref</span>=<span class="value">"CONSOLE"</span> /&gt;</span>  
       <span class="tag">&lt;<span class="title">appender-ref</span> <span class="attribute">ref</span>=<span class="value">"MAIL"</span> /&gt;</span>  
  <span class="tag">&lt;/<span class="title">category</span>&gt;</span>  

 <span class="tag">&lt;<span class="title">root</span>&gt;</span>  
  <span class="tag">&lt;<span class="title">priority</span> <span class="attribute">value</span>=<span class="value">"debug"</span> /&gt;</span>  
  <span class="tag">&lt;<span class="title">appender-ref</span> <span class="attribute">ref</span>=<span class="value">"CONSOLE"</span> /&gt;</span>  
  <span class="tag">&lt;<span class="title">appender-ref</span> <span class="attribute">ref</span>=<span class="value">"FILE"</span> /&gt;</span>  
 <span class="tag">&lt;/<span class="title">root</span>&gt;</span>  


<span class="tag">&lt;/<span class="title">log4j:configuration</span>&gt;</span>  
</code></pre><hr>
<h2 id="属性文件配置">属性文件配置</h2><p>Log4j配置文件实现了输出到控制台、文件、固定大小文件、发送日志邮件、输出到数据库日志表、自定义标签等全套功能。 </p>
<pre><code>log4j.rootLogger=DEBUG,console,dailyFile,im 
log4j<span class="class">.additivity</span><span class="class">.org</span><span class="class">.apache</span>=true 
</code></pre><h3 id="控制台(console)">控制台(console)</h3><pre><code>log4j<span class="class">.appender</span><span class="class">.console</span>=org<span class="class">.apache</span><span class="class">.log4j</span><span class="class">.ConsoleAppender</span> 
log4j<span class="class">.appender</span><span class="class">.console</span><span class="class">.Threshold</span>=DEBUG 
log4j<span class="class">.appender</span><span class="class">.console</span><span class="class">.ImmediateFlush</span>=true 
log4j<span class="class">.appender</span><span class="class">.console</span><span class="class">.Target</span>=System<span class="class">.err</span> 
log4j<span class="class">.appender</span><span class="class">.console</span><span class="class">.layout</span>=org<span class="class">.apache</span><span class="class">.log4j</span><span class="class">.PatternLayout</span> 
log4j<span class="class">.appender</span><span class="class">.console</span><span class="class">.layout</span><span class="class">.ConversionPattern</span>=[%-<span class="number">5</span>p] %<span class="function"><span class="title">d</span><span class="params">(%r)</span></span> --&gt; [%t] %l: %m %x %n 
</code></pre><h3 id="日志文件(logFile)">日志文件(logFile)</h3><pre><code>log4j<span class="class">.appender</span><span class="class">.logFile</span>=org<span class="class">.apache</span><span class="class">.log4j</span><span class="class">.FileAppender</span> 
log4j<span class="class">.appender</span><span class="class">.logFile</span><span class="class">.Threshold</span>=DEBUG 
log4j<span class="class">.appender</span><span class="class">.logFile</span><span class="class">.ImmediateFlush</span>=true 
log4j<span class="class">.appender</span><span class="class">.logFile</span><span class="class">.Append</span>=true 
log4j<span class="class">.appender</span><span class="class">.logFile</span><span class="class">.File</span>=log<span class="class">.log4j</span> 
log4j<span class="class">.appender</span><span class="class">.logFile</span><span class="class">.layout</span>=org<span class="class">.apache</span><span class="class">.log4j</span><span class="class">.PatternLayout</span> 
log4j<span class="class">.appender</span><span class="class">.logFile</span><span class="class">.layout</span><span class="class">.ConversionPattern</span>=[%-<span class="number">5</span>p] %<span class="function"><span class="title">d</span><span class="params">(%r)</span></span> --&gt; [%t] %l: %m %x %n 
</code></pre><h3 id="指定大小文件(rollingFile)">指定大小文件(rollingFile)</h3><p><code>文件大小到达指定尺寸的时候产生一个新的文件</code></p>
<pre><code>log4j<span class="class">.appender</span><span class="class">.rollingFile</span>=org<span class="class">.apache</span><span class="class">.log4j</span><span class="class">.RollingFileAppender</span> 
log4j<span class="class">.appender</span><span class="class">.rollingFile</span><span class="class">.Threshold</span>=DEBUG 
log4j<span class="class">.appender</span><span class="class">.rollingFile</span><span class="class">.ImmediateFlush</span>=true 
log4j<span class="class">.appender</span><span class="class">.rollingFile</span><span class="class">.Append</span>=true 
log4j<span class="class">.appender</span><span class="class">.rollingFile</span><span class="class">.File</span>=log<span class="class">.log4j</span> 
#文件达到多大开始重新开始记录新文件
log4j<span class="class">.appender</span><span class="class">.rollingFile</span><span class="class">.MaxFileSize</span>=<span class="number">200</span>KB 
log4j<span class="class">.appender</span><span class="class">.rollingFile</span><span class="class">.MaxBackupIndex</span>=<span class="number">50</span> 
log4j<span class="class">.appender</span><span class="class">.rollingFile</span><span class="class">.layout</span>=org<span class="class">.apache</span><span class="class">.log4j</span><span class="class">.PatternLayout</span> 
log4j<span class="class">.appender</span><span class="class">.rollingFile</span><span class="class">.layout</span><span class="class">.ConversionPattern</span>=[%-<span class="number">5</span>p] %<span class="function"><span class="title">d</span><span class="params">(%r)</span></span> --&gt; [%t] %l: %m %x %n 
</code></pre><h3 id="每天产生一个文件(dailyFile)">每天产生一个文件(dailyFile)</h3><pre><code>log4j<span class="class">.appender</span><span class="class">.dailyFile</span>=org<span class="class">.apache</span><span class="class">.log4j</span><span class="class">.DailyRollingFileAppender</span> 
log4j<span class="class">.appender</span><span class="class">.dailyFile</span><span class="class">.Threshold</span>=DEBUG 
log4j<span class="class">.appender</span><span class="class">.dailyFile</span><span class="class">.ImmediateFlush</span>=true 
log4j<span class="class">.appender</span><span class="class">.dailyFile</span><span class="class">.Append</span>=true 
log4j<span class="class">.appender</span><span class="class">.dailyFile</span><span class="class">.File</span>=log<span class="class">.log4j</span> 
log4j<span class="class">.appender</span><span class="class">.dailyFile</span><span class="class">.DatePattern</span>=<span class="string">'.'</span>yyyy-MM-<span class="tag">dd</span> 
log4j<span class="class">.appender</span><span class="class">.dailyFile</span><span class="class">.layout</span>=org<span class="class">.apache</span><span class="class">.log4j</span><span class="class">.PatternLayout</span> 
log4j<span class="class">.appender</span><span class="class">.dailyFile</span><span class="class">.layout</span><span class="class">.ConversionPattern</span>=[%-<span class="number">5</span>p] %<span class="function"><span class="title">d</span><span class="params">(%r)</span></span> --&gt; [%t] %l: %m %x %n 
</code></pre><h3 id="发送日志到指定邮件">发送日志到指定邮件</h3><pre><code>log4j<span class="class">.appender</span><span class="class">.mail</span>=org<span class="class">.apache</span><span class="class">.log4j</span><span class="class">.net</span><span class="class">.SMTPAppender</span> 
log4j<span class="class">.appender</span><span class="class">.mail</span><span class="class">.Threshold</span>=FATAL 
log4j<span class="class">.appender</span><span class="class">.mail</span><span class="class">.BufferSize</span>=<span class="number">10</span> 
log4j<span class="class">.appender</span><span class="class">.mail</span><span class="class">.From</span> = xxx@mail<span class="class">.com</span> 
log4j<span class="class">.appender</span><span class="class">.mail</span><span class="class">.SMTPHost</span>=mail<span class="class">.com</span> 
log4j<span class="class">.appender</span><span class="class">.mail</span><span class="class">.Subject</span>=Log4J Message 
log4j<span class="class">.appender</span><span class="class">.mail</span><span class="class">.To</span>= xxx@mail<span class="class">.com</span> 
log4j<span class="class">.appender</span><span class="class">.mail</span><span class="class">.layout</span>=org<span class="class">.apache</span><span class="class">.log4j</span><span class="class">.PatternLayout</span> 
log4j<span class="class">.appender</span><span class="class">.mail</span><span class="class">.layout</span><span class="class">.ConversionPattern</span>=[%-<span class="number">5</span>p] %<span class="function"><span class="title">d</span><span class="params">(%r)</span></span> --&gt; [%t] %l: %m %x %n 
</code></pre><h3 id="应用于数据库">应用于数据库</h3><pre><code>log4j<span class="class">.appender</span><span class="class">.database</span>=org<span class="class">.apache</span><span class="class">.log4j</span><span class="class">.jdbc</span><span class="class">.JDBCAppender</span> 
log4j<span class="class">.appender</span><span class="class">.database</span><span class="class">.URL</span>=jdbc:mysql:<span class="comment">//localhost:3306/test </span>
log4j<span class="class">.appender</span><span class="class">.database</span><span class="class">.driver</span>=com<span class="class">.mysql</span><span class="class">.jdbc</span><span class="class">.Driver</span> 
log4j<span class="class">.appender</span><span class="class">.database</span><span class="class">.user</span>=root 
log4j<span class="class">.appender</span><span class="class">.database</span><span class="class">.password</span>= 
log4j<span class="class">.appender</span><span class="class">.database</span><span class="class">.sql</span>=INSERT INTO LOG4J (Message) <span class="function"><span class="title">VALUES</span><span class="params">(<span class="string">'=[%-5p] %d(%r) --&gt; [%t] %l: %m %x %n'</span>)</span></span> 
log4j<span class="class">.appender</span><span class="class">.database</span><span class="class">.layout</span>=org<span class="class">.apache</span><span class="class">.log4j</span><span class="class">.PatternLayout</span> 
log4j<span class="class">.appender</span><span class="class">.database</span><span class="class">.layout</span><span class="class">.ConversionPattern</span>=[%-<span class="number">5</span>p] %<span class="function"><span class="title">d</span><span class="params">(%r)</span></span> --&gt; [%t] %l: %m %x %n 
</code></pre><h3 id="自定义Appender">自定义Appender</h3><pre><code>log4j<span class="class">.appender</span><span class="class">.im</span> = net<span class="class">.cybercorlin</span><span class="class">.util</span><span class="class">.logger</span><span class="class">.appender</span><span class="class">.IMAppender</span> 
log4j<span class="class">.appender</span><span class="class">.im</span><span class="class">.host</span> = mail<span class="class">.cybercorlin</span><span class="class">.net</span> 
log4j<span class="class">.appender</span><span class="class">.im</span><span class="class">.username</span> = username 
log4j<span class="class">.appender</span><span class="class">.im</span><span class="class">.password</span> = password 
log4j<span class="class">.appender</span><span class="class">.im</span><span class="class">.recipient</span> = 
log4j<span class="class">.appender</span><span class="class">.im</span><span class="class">.layout</span>=org<span class="class">.apache</span><span class="class">.log4j</span><span class="class">.PatternLayout</span> 
log4j<span class="class">.appender</span><span class="class">.im</span><span class="class">.layout</span><span class="class">.ConversionPattern</span>=[%-<span class="number">5</span>p] %<span class="function"><span class="title">d</span><span class="params">(%r)</span></span> --&gt; [%t] %l: %m %x %n 
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<h2 id="xml类型的配置">xml类型的配置</h2><p>Log4j配置文件实现了输出到控制台、文件、固定大小文件、发送日志邮件、输出到数据库日志表、自定义标签等全套功能。 </p>
<pre><code><span class="pi">&lt;?xml versio]]>
    </summary>
    
      <category term="log4j配置" scheme="http://donahue-ldz.github.io/tags/log4j%E9%85%8D%E7%BD%AE/"/>
    
      <category term="java" scheme="http://donahue-ldz.github.io/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[日志记录]]></title>
    <link href="http://donahue-ldz.github.io/2015/01/05/%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95/"/>
    <id>http://donahue-ldz.github.io/2015/01/05/日志记录/</id>
    <published>2015-01-05T06:42:11.000Z</published>
    <updated>2015-03-06T03:35:25.000Z</updated>
    <content type="html"><![CDATA[<h2 id="日志服务">日志服务</h2><p>三个目的 ：</p>
<ul>
<li>监视代码中变量的变化情况，周期性的记录到文件中供其他应用进行统计分析工作</li>
<li>跟踪代码运行时轨迹，作为日后审计的依据</li>
<li><p>担当集成开发环境中的调试器的作用，向文件或控制台打印代码的调试信息</p>
<hr>
</li>
</ul>
<h2 id="log4j简介">log4j简介</h2><blockquote>
<p>Log4j是Apache的一个开放源代码项目，通过使用Log4j，我们可以控制日志信息输送的目的地为控制台、文件、GUI组件、甚至可以为套接口服务器、NT的事件记录器、UNIX Syslog守护进程等；我们也可以控制每一条日志的输出格式；通过定义每一条日志信息的级别，我们能够更加细致地控制日志的生成过程。这些可以通过一个配置文件来灵活地进行配置，而不需要修改应用的代码。</p>
<p>此外，通过 Log4j 其他语言接口，您可以在 C 、 C+ + 、 .Net 、 PL/SQL 程序中使用 Log4j ，其语法和用法与在 Java 程序中一样，使得多语言分布式系统得到一个统一一致的日志组件模块。而且，通 过使用各种第三方扩展，您可以很方便地将 Log4j 集成到 J2EE 、 JINI 甚至是 SNMP 应用中。</p>
</blockquote>
<hr>
<h2 id="Log4j三大类构成">Log4j三大类构成</h2><h3 id="Logger">Logger</h3><p>负责输出日志信息，并能够对日志信息进行分类筛选，即决定哪些日志信息应该被输出，哪些该被忽略。Loggers组件输出日志信息时分为5个级别：DEBUG、INFO、WARN、ERROR、FATAL。这五个级别的顺序是：DEBUG&lt;INFO&lt;WARN&lt;ERROR&lt;FATAL。如果设置某个Logger组件的级别是P，则只有级别比P高的日志信息才能输出。Logger是有继承关系的，最上层是rootLogger，定义的其他Logger都会继承rootLogger。</p>
<h3 id="Appender">Appender</h3><p>定义了日志输出目的地，指定日志信息应该被输出到什么地方。输出的目的地可以是控制台、文件或网络设备。<br>格式为：log4j.appender.appenderName =  其中， Log4j提供的appender有以下几种:</p>
<blockquote>
<ol>
<li>org.apache.log4j.ConsoleAppender （控制台）</li>
<li>org.apache.log4j.FileAppender （文件）</li>
<li>org.apache.log4j.DailyRollingFileAppender （每天产生一个日志文件）， </li>
<li>org.apache.log4j.RollingFileAppender （文件大小到达指定尺寸的时候产生一个新的文件） </li>
<li>org.apache.log4j.WriterAppender（将日志信息以流格式发送到任意指定的地方）</li>
<li>org.apache.log4j.JdbcAppender(将日志讯息保存到数据库中) </li>
</ol>
</blockquote>
<p>此外还可以自己定义</p>
<h3 id="Layout">Layout</h3><p>通过在Appender的后面附加Layout来实现格式化输出。</p>
<p>一个Logger可以有多个Appender，每个Appender对应一个Layout。<br>配置日志信息的格式（布局），其语法为：<br>log4j.appender.appenderName.layout = 其中， Log4j 提供的 layout 有以几种：</p>
<blockquote>
<ol>
<li>org.apache.log4j.HTMLLayout （以 HTML 表格形式布局）</li>
<li>org.apache.log4j.SimpleLayout （包含日志信息的级别和信息字符串）</li>
<li>org.apache.log4j.TTCCLayout （包含日志产生的时间、线程、类别等等信息） </li>
<li>org.apache.log4j.PatternLayout （可以灵活地指定布局模式）</li>
</ol>
</blockquote>
<p><code>org.apache.log4j.PatternLayout （可以灵活地指定布局模式）</code></p>
<blockquote>
<p>Log4J 采用类似 C 语言中的 printf 函数的打印格式格式化日志信息，打印参数如下：<br>%m 输出代码中指定的消息<br>%p 输出优先级，即 DEBUG ， INFO ， WARN ， ERROR ， FATAL<br>%r 输出自应用启动到输出该 log 信息耗费的毫秒数<br>%c 输出所属的类目，通常就是所在类的全名<br>%t 输出产生该日志事件的线程名<br>%n 输出一个回车换行符， Windows 平台为 “rn” ， Unix 平台为 “n”<br>%d 输出日志时间点的日期或时间，默认格式为 ISO8601，也可以在其后指定格式，比如： %d{yyy MMM dd HH:mm:ss,SSS} </p>
</blockquote>
<hr>
<h2 id="常见优秀配置配置">常见优秀配置配置</h2><p>详见博文，<a href="http://donahue-ldz.github.io/2015/01/15/log4j%E5%B8%B8%E8%A7%81%E9%85%8D%E7%BD%AE/" target="_blank" rel="external">log4j常见配置</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="日志服务">日志服务</h2><p>三个目的 ：</p>
<ul>
<li>监视代码中变量的变化情况，周期性的记录到文件中供其他应用进行统计分析工作</li>
<li>跟踪代码运行时轨迹，作为日后审计的依据</li>
<li><p>担当集成开发环境中的调试器的作用]]>
    </summary>
    
      <category term="log4j" scheme="http://donahue-ldz.github.io/tags/log4j/"/>
    
      <category term="日志记录" scheme="http://donahue-ldz.github.io/tags/%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95/"/>
    
      <category term="java" scheme="http://donahue-ldz.github.io/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[finalize理解]]></title>
    <link href="http://donahue-ldz.github.io/2014/09/28/finalize%E7%90%86%E8%A7%A3/"/>
    <id>http://donahue-ldz.github.io/2014/09/28/finalize理解/</id>
    <published>2014-09-28T09:30:28.000Z</published>
    <updated>2015-03-06T03:34:42.000Z</updated>
    <content type="html"><![CDATA[<p><strong>Object类声明了protect finalize方法</strong></p>
<blockquote>
<p>我们都知道程序初始化的重要性，但是通常会忘记清除工作的重要性，我们知道在c++中有构造函数初始化，有相应的析构函数完成收尾清楚工作</p>
</blockquote>
<p>在java中，有c++样构造函数却没有其相应的析构函数，但是却有一个和析构函数相似的一个finalize方法，很多人容易混淆他们两个，下面是区别：</p>
<ol>
<li><p>c++中析构函数在对象声明周期结束时会被调用，数组等new出来时候，delete等函数时候析构会被调用，如果忘记调用这些函数的时候就会造成内存泄露</p>
</li>
<li><p>java中的finalize方法在GC进行回收之前在做<code>第二次标记</code>的时候会被调用。<br>如果对象没有覆盖finalize()或者已经被调用了一次之后，将不再调用了，如果需要调用的话会被加入一个称为F-queue队列中，然后由虚拟机去自动开一条低优先权的线程去执行，<strong>但是不一定会等待其去执行完</strong>。<br>我们知道对于GC什么时候调用，以及什么时候调用对象的finalize方法这些都是不确定的，一般情况下当内存比较充足时候GC不会去时刻调用的<br>因Gc调用也要消耗资源嘛，对于有些程序而言，有可能某些对象的没有调用GC时候程序已经结束，此时交给<strong>操作系统去回收内存</strong>。</p>
</li>
</ol>
<hr>
<p>所以finalize方法并不总是调用。但是这个方法还是比较有用的，我们知道：<br><code>java的GC之后回收new 出来的对象内存</code><br><code>对于有些时候我们使用native方法，如才c/c++时候采取malloc分配的内存此时GC就不能回收了</code><br>我们也不希望这些内存一直存在，我们可以在finalize方法中去调用native方法的free等函数去试着回收，当finalize方法被调用时候，就象的finalize方法被调用时候，我们可以在里面实现和析构函数相同的功能<br>但是如果没能呗回收了，最起码被回收的机会由原来的0变成大于0了</p>
<p>就是当对有被调用的时候，就不能同等去看待了<br>在现实的使用中我们完全可以忘掉这个方法，她所做的事情完全可以有finally模块去完成，不要使用他吧</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>Object类声明了protect finalize方法</strong></p>
<blockquote>
<p>我们都知道程序初始化的重要性，但是通常会忘记清除工作的重要性，我们知道在c++中有构造函数初始化，有相应的析构函数完成收尾清楚工作</p>
<]]>
    </summary>
    
      <category term="finalize" scheme="http://donahue-ldz.github.io/tags/finalize/"/>
    
      <category term="内存回收" scheme="http://donahue-ldz.github.io/tags/%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6/"/>
    
      <category term="java" scheme="http://donahue-ldz.github.io/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[finalize理解]]></title>
    <link href="http://donahue-ldz.github.io/2014/09/22/finalize-e7-90-86-e8-a7-a3/"/>
    <id>http://donahue-ldz.github.io/2014/09/22/finalize-e7-90-86-e8-a7-a3/</id>
    <published>2014-09-22T00:05:21.000Z</published>
    <updated>2015-03-07T04:42:44.000Z</updated>
    <content type="html"><![CDATA[<p>Object类声明了protect finalize方法</p>
<p>我们都知道程序初始化的重要性，但是通常会忘记清除工作的重要性，我们知道在c++中有构造函数初始化，有相应的析构函数完成收尾清楚工作</p>
<p><span style="color: #ff00ff;">在java中，有c++样构造函数却没有其相应的析构函数，但是却有一个和析构函数相似的一个finalize方法，很多人容易混淆他们两个，下面是区别：</span></p>
<p>1.c++中析构函数在对象声明周期结束时会被调用，数组等new出来时候，delete等函数时候析构会被调用，如果忘记调用这些函数的时候就会造成内存泄露</p>
<p>2.java中的finalize方法在GC进行回收之前在做第二次标记的时候会被调用（如果对象没有覆盖finalize()或者已经被调用了一次之后，将不再调用了，如果需要调用的话会被加入一个称为F-queue队列中，然后有虚拟机去自动开一条低优先权的线程去执行，但是不一定会等待其去执行完）。我们知道对于GC什么时候调用，以及什么时候调用对象的finalize方法这些都是不确定的，一般情况下当内存比较充足时候GC不会去时刻调用的，因Gc调用也要消耗资源嘛，对于有些程序而言，有可能某些对象的没有调用GC时候程序已经结束，此时交给操作系统去回收内存</p>
<p>所以finalize方法并不总是调用。但是这个方法还是比较有用的，我们知道java的GC之后回收new 出来的对象内存，对于有些时候我们使用native方法，如才c/c++时候采取malloc分配的内存此时GC就不能回收了，我们也不希望这些内存一直存在，我们可以在finalize方法中去调用native方法的free等函数去试着回收，当finalize方法被调用时候，就能呗回收了，最起码被回收的机会由原来的0变成大于0了</p>
<p>就是当对象的finalize方法被调用时候，我们可以在里面实现和析构函数相同的功能<br>但是如果没有被调用的时候，就不能同等去看待了<br><strong><span style="color: #ff00ff;">在现实的使用中我们完全可以忘掉这个方法，她所做的事情完全可以有finally模块去完成，不要使用他吧</span></strong></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Object类声明了protect finalize方法</p>
<p>我们都知道程序初始化的重要性，但是通常会忘记清除工作的重要性，我们知道在c++中有构造函数初始化，有相应的析构函数完成收尾清楚工作</p>
<p><span style="color: #ff00ff;]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[深入泛型]]></title>
    <link href="http://donahue-ldz.github.io/2014/09/21/e6-b7-b1-e5-85-a5-e6-b3-9b-e5-9e-8b/"/>
    <id>http://donahue-ldz.github.io/2014/09/21/e6-b7-b1-e5-85-a5-e6-b3-9b-e5-9e-8b/</id>
    <published>2014-09-21T02:55:56.000Z</published>
    <updated>2015-03-07T04:42:44.000Z</updated>
    <content type="html"><![CDATA[<p>由于Java泛型的实现机制，使用了泛型的代码在运行期间相关的泛型参数的类型会被擦除(<span style="color: #ff00ff;">泛型擦除</span>)，我们无法在运行期间获知泛型参数的具体类型（所有的泛型类型在运行时都是Object类型）。</p>
<p>但是有的时候，我们确实需要获知泛型参数的类型，比如将使用了泛型的Java代码序列化或者反序列化的时候，这个时候问题就变得比较棘手。可以利用很多成熟的框架,但是此处讨论的是JDK方法</p>
<p><span style="color: #ff00ff;"><strong>原理:</strong></span></p>
<p>Java的Class字节码中存储的泛型参数信息。Java的泛型机制虽然在运行期间泛型类和非泛型类都相同，但是在编译java源代码成class文件中还是保存了泛型相关的信息，这些信息被保存在class字节码常量池中，使用了泛型的代码处会生成一个signature签名字段，通过签名signature字段指明这个常量池的地址。</p>
<p>JDK里面提供了方法去读取这些泛型信息的方法，再借助反射，就可以获得泛型参数的具体类型</p>
<p>常用代码获取类级别的泛型如下</p>
<p>类：</p>
<p>public class Foo&lt;T&gt;{}</p>
<p>获取T如下</p>
<p>Type genType = getClass().getGenericSuperclass();//在Foo<br>Type type = ((ParameterizedType)genType).getActualTypeArguments()[0];<br>System.out.println(type);</p>
<p><span style="color: #ff00ff;"><strong>概括来说就是对于带有泛型的class，返回一个ParameterizedType对象，对于Object、接口和原始类型返回null，对于数组class则是返回Object.class。ParameterizedType是表示带有泛型参数的类型的Java类型，JDK1.5引入了泛型之后，Java中所有的Class都实现了Type接口，ParameterizedType则是继承了Type接口，所有包含泛型的Class类都会实现这个接口。</strong></span></p>
<p>&nbsp;</p>
<p><span style="color: #ff00ff;">获取Field里面的泛型</span></p>
<p>通过指定类对应的Class对象，程序可以获得该类里包括的所有Field，不管该Field使用private修饰，还是使用public修饰。获得了Field对象后，就可以很容易的获得该Field的数据类型，例如，下面的代码便是获得该Field对象foeld的类型：</p>
<p>Class&lt;?&gt; type = field.getType();</p>
<p><strong>    但是通过这种方式只对普通类型的Field有效，如果该Field的类型是有泛型限制的类型，如Map&lt;String,Integer&gt;类型，则不能准确得到该Field的泛型参数。</strong></p>
<p>为了获得指定Field的泛型类型，应该使用如下方法来获取指定Field的泛型类型：</p>
<p>Type type = field.getGenericType();</p>
<p>然后将Type对象强制类型转换成ParameterizedType对象，ParameterizedType代表被参数化的类型，也就是增加了泛型限制的类型，ParameterizedType类提供了两个方法：</p>
<p>getRawType();返回被泛型限制的类型；</p>
<p>getActualTypeArguments();返回泛型参数类型。</p>
<p>例子如下：<br>`<br>import java.lang.reflect.Field;<br>import java.lang.reflect.ParameterizedType;<br>import java.lang.reflect.Type;<br>import java.util.HashMap;<br>import java.util.Map;</p>
<p>public class GenericTest {</p>
<pre><code><span class="keyword">private</span> Map&lt;<span class="keyword">String</span> , Integer&gt; <span class="built_in">map</span> = <span class="keyword">new</span> <span class="keyword">HashMap</span>&lt;<span class="keyword">String</span>, Integer&gt;();

<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) <span class="keyword">throws</span> SecurityException, NoSuchFieldException {
    <span class="comment">// 获取Class实例</span>
    Class&lt;GenericTest&gt; class1 = GenericTest.class;
    <span class="comment">// 根据属性名取得该属性对应的Field对象</span>
    Field mapField = class1.getDeclaredField(<span class="string">"map"</span>);
    <span class="comment">// 示范第一个方法：直接通过getType()取出Field的类型，只对普通类型的Field有效</span>
    Class&lt;?&gt; class2 = mapField.getType();
    <span class="comment">// 输出查看</span>
    System.out.<span class="built_in">println</span>(<span class="string">"属性名为map的属性类型为："</span>+class2);

    <span class="comment">// 示范第二种方法：</span>
    Type mapMainType = mapField.getGenericType();
    <span class="comment">// 为了确保安全转换，使用instanceof</span>
    <span class="keyword">if</span> (mapMainType <span class="keyword">instanceof</span> ParameterizedType) {
        <span class="comment">// 执行强制类型转换</span>
        ParameterizedType parameterizedType = (ParameterizedType)mapMainType;
        <span class="comment">// 获取基本类型信息，即Map</span>
        Type basicType = parameterizedType.getRawType();
        System.out.<span class="built_in">println</span>(<span class="string">"基本类型为："</span>+basicType);
        <span class="comment">// 获取泛型类型的泛型参数</span>
        Type[] types = parameterizedType.getActualTypeArguments();
        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; types.length; i++) {
            System.out.<span class="built_in">println</span>(<span class="string">"第"</span>+(i+<span class="number">1</span>)+<span class="string">"个泛型类型是："</span>+types[i]);
        }
    } <span class="keyword">else</span> {
        System.out.<span class="built_in">println</span>(<span class="string">"获取泛型类型出错!"</span>);
    }
}
</code></pre><p>}<br>`</p>
<p>输出结果：<br>属性名为map的属性类型为：interface java.util.Map<br>基本类型为：interface java.util.Map<br>第1个泛型类型是：class java.lang.String<br>第2个泛型类型是：class java.lang.Integer</p>
<p>&nbsp;</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>由于Java泛型的实现机制，使用了泛型的代码在运行期间相关的泛型参数的类型会被擦除(<span style="color: #ff00ff;">泛型擦除</span>)，我们无法在运行期间获知泛型参数的具体类型（所有的泛型类型在运行时都是Object类型）。</p>
<p>]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[内存泄露和溢出]]></title>
    <link href="http://donahue-ldz.github.io/2014/09/21/e5-86-85-e5-ad-98-e6-b3-84-e9-9c-b2-e5-92-8c-e6-ba-a2-e5-87-ba/"/>
    <id>http://donahue-ldz.github.io/2014/09/21/e5-86-85-e5-ad-98-e6-b3-84-e9-9c-b2-e5-92-8c-e6-ba-a2-e5-87-ba/</id>
    <published>2014-09-21T02:12:43.000Z</published>
    <updated>2015-03-07T04:42:44.000Z</updated>
    <content type="html"><![CDATA[<ul>
<li>内存泄露是指程序中间动态分配了内存，但在程序结束时没有释放这部分内存，从而造成那部分内存不可用的情况，重启计算机可以解决，但也有可能再次发生内存泄露，内存泄露和硬件没有关系，它是由软件设计缺陷引起的。</li>
<li>内存泄漏可以分为4类：1) 常发性内存泄漏。发生内存泄漏的代码会被多次执行到，每次被执行的时候都会导致一块内存泄漏。</li>
</ul>
<p>2) 偶发性内存泄漏。发生内存泄漏的代码只有在某些特定环境或操作过程下才会发生。常发性和偶发性是相对的。对于特定的环境，偶发性的也许就变成了常发性的。所以测试环境和测试方法对检测内存泄漏至关重要。</p>
<p>3) 一次性内存泄漏。发生内存泄漏的代码只会被执行一次，或者由于算法上的缺陷，导致总会有一块仅且一块内存发生泄漏。比如，在类的构造函数中分配内存，在析构函数中却没有释放该内存，所以内存泄漏只会发生一次。</p>
<p>4) 隐式内存泄漏。程序在运行过程中不停的分配内存，但是直到结束的时候才释放内存。严格的说这里并没有发生内存泄漏，因为最终程序释放了所有申请的内存。但是对于一个服务器程序，需要运行几天，几周甚至几个月，不及时释放内存也可能导致最终耗尽系统的所有内存。所以，我们称这类内存泄漏为隐式内存泄漏。</p>
<ul>
<li>内存溢出类型：</li>
</ul>
<p>1) java.lang.OutOfMemoryError: PermGen space</p>
<p>PermGen space 的全称是 Permanent Generation space, 是指内存的永久保存区域。这块内存主要是被JVM存放Class和Meta信息的，Class在被Loader时就会被放到PermGen space中，它和存放类实例(Instance)的Heap区域不同，GC不会在主程序运行期对PermGen space进行清理。</p>
<p>&nbsp;</p>
<p>JVM由XX:PermSize设置非堆内存初始值，默认是物理内存的1/64；</p>
<p>JVM由XX:MaxPermSize设置最大非堆内存的大小，默认是物理内存的1/4。</p>
<p>&nbsp;</p>
<p>该错误常见场合：</p>
<p>a) 应用中有很多Class，web服务器对JSP进行pre compile时。</p>
<p>b) Webapp下用了大量的第三方jar, 其大小超过了JVM默认的大小(4M)时。</p>
<p>&nbsp;</p>
<p>2) java.lang.OutOfMemoryError: Java heap space</p>
<p>&nbsp;</p>
<p>在JVM中如果98%的时间是用于GC且可用的Heap size 不足2%的时候将抛出此异常信息。</p>
<p>&nbsp;</p>
<p>JVM初始分配的内存由-Xms指定，默认是物理内存的1/64；</p>
<p>JVM最大分配的内存由-Xmx指定，默认是物理内存的1/4。</p>
<p>&nbsp;</p>
<p>JVM内存的最大值跟操作系统有很大的关系。32位处理器虽然可控内存空间有4GB，但是具体的操作系统会给一个限制，这个限制一般是2GB-3GB（一般来说Windows系统下为1.5G-2G，Linux系统下为2G-3G），而64bit以上的处理器就不会有限制了。</p>
<p><em>注意：如果Xms超过了Xmx值，或者堆最大值和非堆最大值的总和超过了物理内存或者操作系统的最大限制都会引起服务器启动不起来。</em></p>
<p>该错误常见场合：</p>
<p>a) Web上传文件时。</p>
<p>b) 开启大型文件或从数据库中一次取了太多的数据。</p>
<ul>
<li>内存溢出是要分配的内存在还剩下的内存中不能满足的时候出啊西安内存溢出</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<ul>
<li>内存泄露是指程序中间动态分配了内存，但在程序结束时没有释放这部分内存，从而造成那部分内存不可用的情况，重启计算机可以解决，但也有可能再次发生内存泄露，内存泄露和硬件没有关系，它是由软件设计缺陷引起的。</li>
<li>内存泄漏可以分为4类：1) 常发性内存泄漏]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[线程等待]]></title>
    <link href="http://donahue-ldz.github.io/2014/09/15/%E7%BA%BF%E7%A8%8B%E7%AD%89%E5%BE%85/"/>
    <id>http://donahue-ldz.github.io/2014/09/15/线程等待/</id>
    <published>2014-09-15T02:32:21.000Z</published>
    <updated>2015-03-06T03:35:47.000Z</updated>
    <content type="html"><![CDATA[<p><strong>在多线程程序设计中，经常会遇到一个线程等待一个或多个线程的场景<br>遇到这样的场景应该如何解决？</strong></p>
<blockquote>
<ul>
<li>如果是一个线程等待一个线程，则可以通过await()和notify()来实现；</li>
<li>如果是一个线程等待多个线程，则就可以使用CountDownLatch和CyclicBarrier来实现比较好的控制。</li>
</ul>
</blockquote>
<hr>
<h2 id="CountDownLatch应用">CountDownLatch应用</h2><p><code>场景：主要是:一个线程等待多个其他线程</code></p>
<p>例如：百米赛跑：8名运动员同时起跑，由于速度的快慢，肯定有会出现先到终点和晚到终点的情况，而终点有个统计成绩的仪器，当所有选手到达终点时，它会统计所有人的成绩并进行排序，然后把结果发送到汇报成绩的系统。</p>
<p>其实这就是一个CountDownLatch的应用场景：一个线程或多个线程等待其他线程运行达到某一目标后进行自己的下一步工作，而被等待的“其他线程”达到这个目标后继续自己下面的任务。</p>
<p>这个场景中：</p>
<p>被等待的“其他线程”——&gt;8名运动员<br>等待“其他线程”的这个线程——&gt;终点统计成绩的仪器<br>那么，如何来通过CountDownLatch来实现上述场景的线程控制和调度呢？</p>
<blockquote>
<p>jdk中CountDownLatch类有一个常用的构造方法：CountDownLatch(int count)<br>两个常用的方法：await()和countdown()</p>
</blockquote>
<p>其中count是一个计数器中的初始化数字，比如初始化的数字是2，当一个线程里调用了countdown()，则这个计数器就减一，当线程调用了await()，则这个线程就等待这个计数器变为0，当这个计数器变为0时，这个线程继续自己下面的工作。下面是上述CountDownLatch场景的实现：</p>
<p>Work类（运动员）：</p>
<pre><code><span class="keyword">import</span> java.util.concurrent.CountDownLatch;

<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Work</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>{
    <span class="keyword">private</span> <span class="keyword">int</span> id;
    <span class="keyword">private</span> CountDownLatch beginSignal;
    <span class="keyword">private</span> CountDownLatch endSignal;

    <span class="function"><span class="keyword">public</span> <span class="title">Work</span><span class="params">(<span class="keyword">int</span> id, CountDownLatch begin, CountDownLatch end)</span> </span>{
        <span class="keyword">this</span>.id = id;
        <span class="keyword">this</span>.beginSignal = begin;
        <span class="keyword">this</span>.endSignal = end;
    }

    <span class="annotation">@Override</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{
        <span class="keyword">try</span> {
              beginSignal.await();
              System.out.println(<span class="string">"起跑..."</span>);
              System.out.println(<span class="string">"work"</span> + id + <span class="string">"到达终点"</span>);
              endSignal.countDown();
              System.out.println(<span class="string">"work"</span> + id + <span class="string">"继续干其他事情"</span>);
            } <span class="keyword">catch</span> (InterruptedException e) {
                <span class="comment">// TODO Auto-generated catch block</span>
                e.printStackTrace();
            }
    }
</code></pre><p>}<br>Main类（终点统计仪器）：</p>
<pre><code>import java.util.concurrent.CountDownLatch;
<span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Main</span> {

    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{
        CountDownLatch begSignal = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);
        CountDownLatch endSignal = <span class="keyword">new</span> CountDownLatch(<span class="number">8</span>);
        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) {
            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Work(i, begSignal, endSignal)).start();
        }

    <span class="keyword">try</span> {
        begSignal.countDown();  <span class="comment">//统一起跑</span>
        endSignal.await();      <span class="comment">//等待运动员到达终点</span>
        System.<span class="keyword">out</span>.println(<span class="string">"结果发送到汇报成绩的系统"</span>);
        } <span class="keyword">catch</span> (InterruptedException e) {
            e.printStackTrace();
        }
     }
</code></pre><p>}</p>
<hr>
<h2 id="CyclicBarrier的应用">CyclicBarrier的应用</h2><p><code>场景：主要是多个线程之间相互等待，循环等待</code></p>
<p> 例如：有四个游戏玩家玩游戏，游戏有三个关卡，每个关卡必须要所有玩家都到达后才能允许通关。</p>
<p>其实这个场景里的玩家中如果有玩家A先到了关卡1，他必须等待其他所有玩家都到达关卡1时才能通过，也就是说：<br><code>线程之间需要互相等待，这和CountDownLatch的应用场景有区别。</code><br><code>CountDownLatch里的线程是到了运行的目标后继续干自己的其他事情</code><br><code>而这里的线程需要等待其他线程后才能继续完成下面的工作</code>。   </p>
<blockquote>
<p>jdk中CyclicBarrier类有两个常用的构造方法：</p>
<ol>
<li>CyclicBarrier(int parties)<br>这里的parties也是一个计数器，例如，初始化时parties里的计数是3，于是拥有该CyclicBarrier对象的线程当parties的计数为3时就唤醒，注：这里parties里的计数在运行时当调用CyclicBarrier:await()时,计数就加1，一直加到初始的值。</li>
<li>CyclicBarrier(int parties, Runnable barrierAction)<br>这里的parties与上一个构造方法的解释是一样的，这里需要解释的是第二个入参（Runnable barrierAction）,这个参数是一个实现Runnable接口的类的对象，也就是说当parties加到初始值时就出发barrierAction的内容。</li>
</ol>
</blockquote>
<p>下面来实现上述的应用场景：</p>
<p>Player类（玩家类）</p>
<pre><code><span class="keyword">import</span> java.util.concurrent.BrokenBarrierException;
<span class="keyword">import</span> java.util.concurrent.CyclicBarrier;

<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Player</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>{

    <span class="keyword">private</span> CyclicBarrier cyclicBarrier;
    <span class="keyword">private</span> <span class="keyword">int</span> id;

    <span class="function"><span class="keyword">public</span> <span class="title">Player</span><span class="params">(<span class="keyword">int</span> id, CyclicBarrier cyclicBarrier)</span> </span>{
        <span class="keyword">this</span>.cyclicBarrier = cyclicBarrier;
        <span class="keyword">this</span>.id = id;
    }

    <span class="annotation">@Override</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{
        <span class="keyword">try</span> {
            System.out.println(<span class="string">"玩家"</span> + id + <span class="string">"正在玩第一关..."</span>);
            cyclicBarrier.await();
            System.out.println(<span class="string">"玩家"</span> + id + <span class="string">"进入第二关..."</span>);
            } <span class="keyword">catch</span> (InterruptedException e) {
              e.printStackTrace();
        } <span class="keyword">catch</span> (BrokenBarrierException e) {
             e.printStackTrace();
    }
  }
}
</code></pre><p>GameBarrier类（关卡类，这里控制玩家必须全部到达第一关结束的关口才能进入第二关）</p>
<pre><code><span class="keyword">import</span> java.util.concurrent.CyclicBarrier;

<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GameBarrier</span> </span>{

    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{
    CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">4</span>, <span class="keyword">new</span> Runnable() {

        <span class="annotation">@Override</span>
        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{
             System.out.println(<span class="string">"所有玩家进入第二关！"</span>);
        }
     });

    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) {
        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Player(i, cyclicBarrier)).start();
     }
  }
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p><strong>在多线程程序设计中，经常会遇到一个线程等待一个或多个线程的场景<br>遇到这样的场景应该如何解决？</strong></p>
<blockquote>
<ul>
<li>如果是一个线程等待一个线程，则可以通过await()和notify()来实现；</li>]]>
    </summary>
    
      <category term="CyclicBarrier" scheme="http://donahue-ldz.github.io/tags/CyclicBarrier/"/>
    
      <category term="线程" scheme="http://donahue-ldz.github.io/tags/%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="线程等待，CountDownLatch" scheme="http://donahue-ldz.github.io/tags/%E7%BA%BF%E7%A8%8B%E7%AD%89%E5%BE%85%EF%BC%8CCountDownLatch/"/>
    
      <category term="java" scheme="http://donahue-ldz.github.io/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Swing框架之SwingWorker(二)]]></title>
    <link href="http://donahue-ldz.github.io/2014/09/04/swing-e6-a1-86-e6-9e-b6-e4-b9-8bswingworker-e4-ba-8c/"/>
    <id>http://donahue-ldz.github.io/2014/09/04/swing-e6-a1-86-e6-9e-b6-e4-b9-8bswingworker-e4-ba-8c/</id>
    <published>2014-09-04T13:09:54.000Z</published>
    <updated>2015-03-07T04:42:44.000Z</updated>
    <content type="html"><![CDATA[<p><strong>SwingWorker基础</strong></p>
<p>SwingWorker的定义如下：</p>
<p>public abstract class SwingWorker&lt;T,V&gt; extends Object implements RunnableFuture</p>
<p><wbr> <wbr> <wbr> SwingWorker是抽象类，因此必须继承它才能执行所需的特定任务。注意该类有两个类型参数：T及V。T是doInBackground和get方法的返回类型，V是publish和process方法要处理的数据类型。后文将作详细解释。</p>
<p><wbr> <wbr> <wbr> 该类实现了java.util.concurrent.RunnableFuture接口。RunnableFuture接口是Runnable和Future两个接口的简单封装。由于SwingWorker实现了Runnable接口，因此SwingWorker有一个run方法。Runnable对象一般作为线程的一部分执行，当Thread对象启动时，它激活Runnable对象的run方法。由于SwingWorker实现了Future接口，因此SwingWorker产生类型为T的结果值并提供同线程交互的方法。SwingWorker实现以下接口方法：</p>
<p><wbr> <wbr> <wbr> <em> boolean cancel(boolean mayInterruptIfRunning)<br><wbr> <wbr> <wbr> </em> T get()<br><wbr> <wbr> <wbr> <em> T get(long timeout, TimeUnit unit)<br><wbr> <wbr> <wbr> </em> boolean isCancelled()<br><wbr> <wbr> <wbr> * boolean isDone()</p>
<p><wbr> <wbr> <wbr> SwingWorker实现了所有的接口方法，实际上你仅需要实现以下SwingWorker的抽象方法：</p>
<p>protected T doInBackground() throws Exception</p>
<p><wbr> <wbr> <wbr> doInBackground方法作为任务线程的一部分执行，它负责完成线程的基本任务，并以返回值来作为线程的执行结果。继承类须覆盖该方法并确保包含或代理任务线程的基本任务。不要直接调用该方法，应使用任务对象的execute方法来调度执行。</p>
<p><wbr> <wbr> <wbr> 在获得执行结果后应使用SwingWorker的get方法获取doInBackground方法的结果。可以在EDT上调用get方法，但该方法将一直处于阻塞状态，直到任务线程完成。最好只有在知道结果时才调用get方法，这样用户便不用等待。为防止阻塞，可以使用isDone方法来检验doInBackground是否完成。另外调用方法get(long timeout, TimeUnit unit)将会一直阻塞直到任务线程结束或超时。获取任务结果的最好地方是在done方法内：</p>
<p>protected void done() <wbr></p>
<p><wbr> <wbr> <wbr> 在doInBackground方法完成之后，SwingWorker调用done方法。如果任务需要在完成后使用线程结果更新GUI组件或者做些清理工作，可覆盖done方法来完成它们。这儿是调用get方法的最好地方，因为此时已知道线程任务完成了，SwingWorker在EDT上激活done方法，因此可以在此方法内安全地和任何GUI组件交互。</p>
<p><wbr> <wbr> <wbr> 没必要等到线程完成就可以获得中间结果。中间结果是任务线程在产生最后结果之前就能产生的数据。当任务线程执行时，它可以发布类型为V的中间结果，覆盖process方法来处理中间结果。后文还将提供这些方法的更多详细信息。当属性改变时，SwingWorker实例能通知处理器，SwingWorker有两个重要的属性：状态和进程。任务线程有几种状态，以下面SwingWorker.StateValue枚举值来表示：</p>
<p><wbr> <wbr> <wbr> <em> PENDING<br><wbr> <wbr> <wbr> </em> STARTED<br><wbr> <wbr> <wbr> * DONE</p>
<p><wbr> <wbr> <wbr> 任务线程一创建就处于PENDING状态，当doInBackground方法开始时，任务线程就进入STARTED状态，当doInBackground方法完成后，任务线程就处于DONE状态，随着线程进入各个阶段，SwingWorker超类自动设置这些状态值。你可以添加处理器，当这些属性发生变化来接收通知。</p>
<p><wbr> <wbr> <wbr> 最后，任务对象有一个进度属性，随着任务进展时，可以将这个属性从0更新到100标识任务进度，当该属性发生变化时，任务通知处理器进行处理。 <span style="color: #ff00ff;">你可以使用publish方法来发布要处理的中间数据,并以参数的形式提供要发布的数据。当然像前面所说的那样，必须在类声明中指定中间数据的类型</span>。<span style="color: #ff00ff;">如果SwingWorker子类发布了一些数据，那么也应该实现process方法来处理这些中间结果</span>。<span style="color: #ff00ff;"><strong>任务对象的父类会在EDT线程上激活process方法，因此在此方法中程序可以安全的更新UI组件</strong></span>。</p>
<p>SwingWorker的子类可能既会生成最终结果也会产生中间结果，记住线程在doInBackground方法结束后才产生最后结果，但任务线程也可以产生和公布中间数据</p>
<p>当从任务线程调用publish方法时，SwingWorker类调度process方法。有意思的是process方法是在EDT上面执行，这意味着可以同Swing组件和其模型直接交互.</p>
<p><pre>注意process方法的参数，它并没有使用单个对象，而是这种对象的一个列表。<strong>原因是publish方法能够以批模式来调用process方法，就是说，每个publish调用并不总是产生相应的process调用。如果可能，publish方法会收集对象并以对象的列表为参数调用process方</strong>法</pre><br>&nbsp;</p>
<p>&nbsp;</p>
<p><wbr> <wbr> <wbr> 如果想允许程序用户取消任务，实现代码要在SwingWorker子类中周期性地检查取消请求。调用isCancelled方法来检查是否有取消请求</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>SwingWorker基础</strong></p>
<p>SwingWorker的定义如下：</p>
<p>public abstract class SwingWorker&lt;T,V&gt; extends Object implements Run]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[Swing框架之SwingWorker(一)]]></title>
    <link href="http://donahue-ldz.github.io/2014/09/04/swing-e6-a1-86-e6-9e-b6-e4-b9-8bswingworker-e4-b8-80/"/>
    <id>http://donahue-ldz.github.io/2014/09/04/swing-e6-a1-86-e6-9e-b6-e4-b9-8bswingworker-e4-b8-80/</id>
    <published>2014-09-04T11:22:28.000Z</published>
    <updated>2015-03-07T04:42:44.000Z</updated>
    <content type="html"><![CDATA[<p>桌面应用程序员常见的错误是误用Swing事件调度线程（Event Dispatch Thread, EDT)。他们要么从非UI线程访问UI组件，要么不考虑事件执行顺序，要么不使用独立任务线程而在EDT线程上执行耗时任务，结果使编写的应用程序变得响应迟钝、速度很慢。耗时计算和输入/输出(IO)密集型任务不应放在Swing EDT上运行<a id="more"></a><br><strong>Swing线程基础:</strong><br>一个Swing程序中一般有下面三种类型的线程：</p>
<ul>
<li>初始化线程(Initial Thread)</li>
<li>UI事件调度线程(EDT)</li>
<li>任务线程(Worker Thread)<br>自己写的每个程序必须有一个main方法，这是程序的入口。该方法运行在<strong>初始化或启动线程上</strong>。<span style="color: #ff00ff;">初始化线程读取程序参数并初始化一些对象</span>。在许多Swing程序中，该线程主要目的是启动程序的图形用户界面(GUI)。一旦GUI启动后，对于大多数事件驱动的桌面程序来说，初始化线程的工作就结束了。<br><span style="color: #ff00ff;"><strong>Swing程序只有一个用EDT</strong></span>，该线程负责GUI组件的绘制和更新，通过调用程序的事件处理器来响应用户交互。所有事件处理都是在EDT上进行的，程序同UI组件和其基本数据模型的交互只允许在EDT上进行，所有运行在EDT上的任务应该尽快完成，以便UI能及时响应用户输入。</li>
</ul>
<!--more--><strong>EDT是:</strong><br><br>在Java中，键盘输入、鼠标点击或者应用程序本身产生的请求会被封装成一个事件，放进一个事件队列中，<strong><span style="color: #ff0000;">java.awt.EventQueue对象负责从这个队列中取出事件并派发它们。而EventQueue的派发有一个单独的线程管理，这个线程叫做事件派发线程(Event Dispatch Thread)，也就是EDT</span></strong>。<br><br><!--more-->
<p><span style="color: #ff0000;">Swing编程时应该注意以下几点：</span><br>1.从<strong>其他线程</strong>访问UI组件及其事件处理器会导致界面更新和绘制错误。<br>2.在EDT上执行耗时任务会使程序失去响应，这会使GUI事件阻塞在队列中得不到处理。<br>3.<strong>应使用独立的任务线程来执行耗时计算或输入输出密集型任务，比如同数据库通信、访问网站资源、读写大树据量的文件</strong>。<br><strong><span style="color: #ff00ff;">总之，任何干扰或延迟UI事件的处理只应该出现在独立任务线程中；在初始化线程或任务线程同Swing组件或其缺省数据模型进行的交互都是非线程安全性操作</span></strong>。<br><span style="color: #ff0000;"><strong>SwingWorker类帮你管理任务线程和Swing EDT之间的交互</strong></span>，尽管SwingWorker不能解决并发线程中遇到的所有问题，但的确有助于分离Swing EDT和任务线程，使它们各负其责：<strong>对于EDT来说，就是绘制和更新界面，并响应用户输入</strong>；<strong><em>对于任务线程来说，就是执行和界面无直接关系的耗时任务和I/O密集型操作。</em></strong></p>
<p><strong><em><!--more--></em></strong><br><strong>使用合适线程:</strong><br>初始化线程运行程序的main方法，该方法能处理许多任务。但在典型的Swing程序中，其主要任务就是创建和运行应用程序的界面。创建UI的点，也就是程序开始将控制权转交给UI时的点，往往是同EDT交互出现问题的第一个地方。<br>示例的主类是MainFrame，从其main方法启动。许多程序使用下面方法启动界面，但这是错误的启动UI界面的方法：<br>public class MainFrame extends javax.swing.JFrame {<br>…<br>public static void main(String[] args) {<br>new MainFrame().setVisible(true);<br>}<br>}<br>尽管这种错误出现在开始，<span style="color: #ff0000;">但仍然违反了不应在EDT外的其他线程同Swing组件交互的原则</span>。这个错误尤其容易犯，线程同步问题虽然不是马上显示出来，但是还要注意避免这样书写。<br>正确启动UI界面应该如下：<br>public static void main(String[] args) {<br>SwingUtilities.invokeLater(new Runnable() {<br>public void run() {<br>new MainFrame().setVisible(true);<br>}<br>});<br>}<br>}<br>使用NetBeans IDE的开发者应该对这段代码很熟悉，NetBeans通常会自动生成这段代码。这段启动代码虽然和SwingWorker没有直接关系，但是<span style="color: #ff0000;"><strong>这个编程范式很重要</strong></span>。<strong>SwingUtilities类包含一些静态方法帮你同UI组件交互，其中invokeLater方法意思是在EDT上执行其Runnable任务。Runnable接口定义了可作为独立线程执行的任务</strong>。</p>
<!--more--><strong>InvokeLater:</strong><br>在初始化线程中使用invokeLater方法能正确的初始化程序界面。<strong>此方法是异步执行的，也就是说调用会立即返回。创建界面后，大部分初始化线程基本上就结束了,接下来就直接将控制权交个EDT调用其他队列里面的其他任务</strong>。<br><span style="color: #ff0000;">通常有两种办法调用此方法</span>：<br><em> SwingUtilities.invokeLater
</em> EventQueue.invokeLater<br>两个方法都是正确的，选择任何一个都可以。<strong><span style="color: #ff0000;">实际上，SwingUtilities版只是一个薄薄的封装方法，它直接转而调用EventQueue.invokeLater</span></strong>。因为Swing框架本身经常调用SwingUtilities，使用SwingUtilities可以减少程序引入的类。<br><strong>另种将任务放到EDT执行的方法是SwingUtilities.invokeAndWait，不像invokeLater，invokeAndWait方法是阻塞执行的，它在EDT上执行Runnnable任务，直到任务执行完了，该方法才返回调用线程</strong>。<br>invokeLater和invokeAndWait都在事件派发队列中的所有事件都处理完之后才执行它们的Runnable任务，也就是说，<span style="color: #ff0000;"><strong>这两个方法将Runnable任务放在事件队列的末尾。</strong></span><br>注意：虽然可以在其他线程上调用invokeLater，也可以在EDT上调用invokeLater，但是千万不要在EDT线程上调用invokeAndWait方法！很容易理解，这样做会造成线程竞争，程序就会陷入死锁。<br><br><!--more-->
<p><strong>将EDT线程仅用于GUI任务:</strong><br>Swing框架负责管理组件绘制、更新以及EDT上的线程处理。可以想象，该线程的事件队列很繁忙，几乎每一次GUI交互和事件都是通过它完成。事件队列的上任务必须非常快，否则就会阻塞其他任务的执行，使队列里阻塞了很多等待执行的事件，造成界面响应不灵活，让用户感觉到界面响应速度很慢，使他们失去兴趣。理想情况下，<strong>任何需时超过30到100毫秒的任务不应放在EDT上执行，否则用户就会觉察到输入和界面响应之间的延迟</strong>。<br>幸运的是，不会仅仅因为有复杂的任务、计算或输入输出密集任务需要作为GUI事件处理任务执行，Swing的性能就要有所降低。毕竟有许多桌面程序执行耗时任务，比如处理电子表格公式、跨越网络查询数据库、通过Internet向其他程序发送信息。即使有这些任务，界面仍然可以让用户感觉到响应灵活、快捷。编写响应灵活的程序需要创建和管理独立于EDT的线程。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>桌面应用程序员常见的错误是误用Swing事件调度线程（Event Dispatch Thread, EDT)。他们要么从非UI线程访问UI组件，要么不考虑事件执行顺序，要么不使用独立任务线程而在EDT线程上执行耗时任务，结果使编写的应用程序变得响应迟钝、速度很慢。耗时计算和输入/输出(IO)密集型任务不应放在Swing EDT上运行]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[线程等待]]></title>
    <link href="http://donahue-ldz.github.io/2014/08/27/450/"/>
    <id>http://donahue-ldz.github.io/2014/08/27/450/</id>
    <published>2014-08-27T01:54:11.000Z</published>
    <updated>2015-03-07T04:42:44.000Z</updated>
    <content type="html"><![CDATA[<p><strong>在多线程程序设计中，经常会遇到一个线程等待一个或多个线程的场景，遇到这样的场景应该如何解决？</strong></p>
<p><span style="color: #ff00ff;">如果是一个线程等待一个线程，则可以通过await()和notify()来实现；</span></p>
<p><strong><span style="color: #ff00ff;">如果是一个线程等待多个线程，则就可以使用CountDownLatch和CyclicBarrier来实现比较好的控制。</span></strong></p>
<h4 id="CountDownLatch的应用场景(主要是:一个线程等待多个其他线程)：">CountDownLatch的应用场景(主要是:一个线程等待多个其他线程)：</h4><p>例如：百米赛跑：8名运动员同时起跑，由于速度的快慢，肯定有会出现先到终点和晚到终点的情况，而终点有个统计成绩的仪器，当所有选手到达终点时，它会统计所有人的成绩并进行排序，然后把结果发送到汇报成绩的系统。</p>
<p>其实这就是一个CountDownLatch的应用场景：一个线程或多个线程等待其他线程运行达到某一目标后进行自己的下一步工作，而被等待的“其他线程”达到这个目标后继续自己下面的任务。</p>
<p>这个场景中：</p>
<ol>
<li>被等待的“其他线程”———&gt;8名运动员</li>
<li>等待“其他线程”的这个线程———&gt;终点统计成绩的仪器<br>那么，如何来通过CountDownLatch来实现上述场景的线程控制和调度呢？</li>
</ol>
<p><span style="color: #ff0000;"><strong>jdk中CountDownLatch类有一个常用的构造方法：CountDownLatch(int count)</strong></span></p>
<p><span style="color: #ff0000;"><strong>两个常用的方法：await()和countdown()</strong></span></p>
<p>其中count是一个计数器中的初始化数字，比如初始化的数字是2，当一个线程里调用了countdown()，则这个计数器就减一，当线程调用了await()，则这个线程就等待这个计数器变为0，当这个计数器变为0时，这个线程继续自己下面的工作。下面是上述CountDownLatch场景的实现：</p>
<p>Work类（运动员）：</p>
<p>`</p>
<p>import java.util.concurrent.CountDownLatch;</p>
<p>public class Work implements Runnable {<br>    private int id;<br>    private CountDownLatch beginSignal;<br>    private CountDownLatch endSignal;</p>
<pre><code><span class="function"><span class="keyword">public</span> <span class="title">Work</span><span class="params">(<span class="keyword">int</span> id, CountDownLatch begin, CountDownLatch end)</span> </span>{
     <span class="keyword">this</span>.id = id;
     <span class="keyword">this</span>.beginSignal = begin;
     <span class="keyword">this</span>.endSignal = end;
}

@<span class="function">Override
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{
    <span class="keyword">try</span> {
          beginSignal.await();
          System.<span class="keyword">out</span>.println(<span class="string">"起跑..."</span>);
          System.<span class="keyword">out</span>.println(<span class="string">"work"</span> + id + <span class="string">"到达终点"</span>);
          endSignal.countDown();
          System.<span class="keyword">out</span>.println(<span class="string">"work"</span> + id + <span class="string">"继续干其他事情"</span>);
        } <span class="keyword">catch</span> (InterruptedException e) {
           <span class="comment">// TODO Auto-generated catch block</span>
           e.printStackTrace();
        }
    }
</code></pre><p>}<br><code>Main类（终点统计仪器）：</code><br>import java.util.concurrent.CountDownLatch;</p>
<p>public class Main {</p>
<pre><code><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{
    CountDownLatch begSignal = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);
    CountDownLatch endSignal = <span class="keyword">new</span> CountDownLatch(<span class="number">8</span>);

    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) {
        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Work(i, begSignal, endSignal)).start();
    }

  <span class="keyword">try</span> {
       begSignal.countDown();  <span class="comment">//统一起跑</span>
       endSignal.await();      <span class="comment">//等待运动员到达终点</span>
       System.<span class="keyword">out</span>.println(<span class="string">"结果发送到汇报成绩的系统"</span>);
      } <span class="keyword">catch</span> (InterruptedException e) {
         e.printStackTrace();
   }
</code></pre><p>  }<br>}<br>`</p>
<h4 id="CyclicBarrier的应用场景(主要是多个线程之间相互等待)："><strong>CyclicBarrier的应用场景(主要是多个线程之间相互等待)：</strong></h4><p>有四个游戏玩家玩游戏，游戏有三个关卡，每个关卡必须要所有玩家都到达后才能允许通关。</p>
<p>其实这个场景里的玩家中如果有玩家A先到了关卡1，他必须等待其他所有玩家都到达关卡1时才能通过，也就是说线程之间需要互相等待，这和CountDownLatch的应用场景有区别，CountDownLatch里的线程是到了运行的目标后继续干自己的其他事情，而这里的线程需要等待其他线程后才能继续完成下面的工作。</p>
<p>jdk中CyclicBarrier类有两个常用的构造方法：</p>
<p>1.CyclicBarrier(int parties)</p>
<p>这里的parties也是一个计数器，例如，初始化时parties里的计数是3，于是拥有该CyclicBarrier对象的线程当parties的计数为3时就唤醒，注：这里parties里的计数在运行时当调用CyclicBarrier:await()时,计数就加1，一直加到初始的值</p>
<p>2.CyclicBarrier(int parties, Runnable barrierAction)</p>
<p>这里的parties与上一个构造方法的解释是一样的，这里需要解释的是第二个入参（Runnable barrierAction）,这个参数是一个实现Runnable接口的类的对象，也就是说当parties加到初始值时就出发barrierAction的内容。</p>
<p>下面来实现上述的应用场景：</p>
<p>Player类（玩家类）<br>`<br>import java.util.concurrent.BrokenBarrierException;<br>import java.util.concurrent.CyclicBarrier;</p>
<p>public class Player implements Runnable {</p>
<pre><code><span class="keyword">private</span> CyclicBarrier cyclicBarrier;
<span class="keyword">private</span> <span class="keyword">int</span> id;

<span class="function"><span class="keyword">public</span> <span class="title">Player</span><span class="params">(<span class="keyword">int</span> id, CyclicBarrier cyclicBarrier)</span> </span>{
    <span class="keyword">this</span>.cyclicBarrier = cyclicBarrier;
    <span class="keyword">this</span>.id = id;
}

@<span class="function">Override
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{
    <span class="keyword">try</span> {
        System.<span class="keyword">out</span>.println(<span class="string">"玩家"</span> + id + <span class="string">"正在玩第一关..."</span>);
        cyclicBarrier.await();
        System.<span class="keyword">out</span>.println(<span class="string">"玩家"</span> + id + <span class="string">"进入第二关..."</span>);
        } <span class="keyword">catch</span> (InterruptedException e) {
          e.printStackTrace();
    } <span class="keyword">catch</span> (BrokenBarrierException e) {
         e.printStackTrace();
}
</code></pre><p>  }<br>}<br><code>GameBarrier类（关卡类，这里控制玩家必须全部到达第一关结束的关口才能进入第二关）</code><br>import java.util.concurrent.CyclicBarrier;</p>
<p>public class GameBarrier {</p>
<pre><code><span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{
CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">4</span>, <span class="keyword">new</span> Runnable() {

    <span class="annotation">@Override</span>
    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{
         System.out.println(<span class="string">"所有玩家进入第二关！"</span>);
    }
 });

<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) {
    <span class="keyword">new</span> Thread(<span class="keyword">new</span> Player(i, cyclicBarrier)).start();
 }
</code></pre><p>  }<br>}<br>`</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>在多线程程序设计中，经常会遇到一个线程等待一个或多个线程的场景，遇到这样的场景应该如何解决？</strong></p>
<p><span style="color: #ff00ff;">如果是一个线程等待一个线程，则可以通过await()和notify()来]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[ NIO之Buffer&Channel]]></title>
    <link href="http://donahue-ldz.github.io/2014/08/27/445/"/>
    <id>http://donahue-ldz.github.io/2014/08/27/445/</id>
    <published>2014-08-27T00:17:53.000Z</published>
    <updated>2015-03-07T04:42:44.000Z</updated>
    <content type="html"><![CDATA[<p><strong>NIO概览:</strong></p>
<hr>
<p><strong>所有语言运行时系统提供执行 I/O 较高级别的工具</strong>。在java编程中，标准低版本IO使用流的方式完成I/O操作，所有的I/O都被视为单个的<strong>字节流动</strong>，称为一个Stream的对象一次移动一个字节。</p>
<p>NIO是在JDK1.4之后出现的一种新的IO，sun官方标榜的nio有如下特性：</p>
<ul>
<li>为所有的原始类型提供（Buffer）缓存支持；</li>
<li>字符集编码解决方案（Charset）；</li>
<li>Channel : 一个新的原始I/O抽象；</li>
<li>支持锁和内存映射文件的文件访问接口；</li>
<li>提供多路（non-bloking）非阻塞式的高伸缩性网路I/O。</li>
</ul>
<p>NIO包（java.nio.*）引入了四个关键的抽象数据类型，它们共同解决传统的I/O类中的一些问题。<br>1． Buffer：它是包含数据且用于读写的线形表结构。其中还提供了一个特殊类用于内存映射文件的I/O操作。<br>2． Charset：它提供Unicode字符串影射到字节序列以及逆影射的操作。<br>3． Channels：包含socket，file和pipe三种管道，它实际上是双向交流的通道。<br>4． Selector：它将多元异步I/O操作集中到一个或多个线程中。</p>
<p>本文先介绍chanel和buffer(通道和缓冲)</p>
<p>缓冲区和通道是NIO中的核心对象，通道Channel是对原IO中流的模拟，所有数据都要通过通道进行传输；Buffer实质上是一个容器对象，发送给通道的所有对象都必须首先放到一个缓冲区中。</p>
<p><strong>Buffer是什么？</strong></p>
<p>Bufer是一个对象，它包含要写入或者刚读出的数据。这是NIO与IO的一个重要区别，在面向流的I/O中您将数据直接写入或者将数据直接读到stream中。在 NIO 库中，所有数据都是用缓冲区处理的。在读取数据时，它是直接读到缓冲区中的。在写入数据时，它是写入到缓冲区中的。任何时候访问 NIO 中的数据，您都是将它放到缓冲区中。</p>
<p><strong>缓冲区实质上是一个数组。通常它是一个字节数组，但是也可以使用其他种类的数组。但是一个缓冲区不仅仅是一个数组。缓冲区提供了对数据的结构化访问，而且还可以跟踪系统的读/写进程。</strong></p>
<p>简单的说Buffer是：一块连续的内存块，是NIO数据读或写的中转地。</p>
<p>（2）Buffer的类图结构</p>
<p><img src="http://hi.csdn.net/attachment/201110/15/0_1318674716tv5y.gif" alt=""></p>
<div></div><br><div><br><br><strong>Buffer在JDK中是如何实现的？</strong><br><br>查看JDK源码可以知道，Buffer类是一个抽象类，其中有五个属性，分别是<strong>mark、position、limit、capacity、address。</strong>并且可以看到这样一行注释：<br><br>//Invariants:mark&lt;=position&lt;=limit&lt;=capacity<br><br>一个 buffer 主要由 position、limit、capacity 三个变量来控制读写的过程。这三个变量在读和写时分别代表的含义如下：<br><div><br><table border="1" cellspacing="0" cellpadding="0"><br><tbody><br><tr><br><td rowspan="1" colspan="1" valign="top">参数</td><br><td rowspan="1" colspan="1" valign="top">写模式</td><br><td rowspan="1" colspan="1" valign="top">读模式</td><br></tr><br><tr><br><td rowspan="1" colspan="1" valign="top">position</td><br><td rowspan="1" colspan="1" valign="top">当前写入的单位数据的数量</td><br><td rowspan="1" colspan="1" valign="top">当前读入的单位数据的数量</td><br></tr><br><tr><br><td rowspan="1" colspan="1" valign="top">limit</td><br><td rowspan="1" colspan="1" valign="top">代表最多能写多少单位的数据量，默认和capacity一致</td><br><td rowspan="1" colspan="1" valign="top">代表最多能读多少单位的数据量，和之前写入的数据量一致</td><br></tr><br><tr><br><td rowspan="1" colspan="1" valign="top">capacity</td><br><td rowspan="1" colspan="1" valign="top">Buffer的容量</td><br><td rowspan="1" colspan="1" valign="top">Buffer的容量</td><br></tr><br></tbody><br></table><br></div><br>Buffer抽象类并没有指定Buffer的实现方式，看其子类可以发现，比如ByteBuffer中多出几个属性，其中有个final byte[]类型的属性，可知Buffer其实是用数组实现的。<br><br>（4）Buffer中的一些方法？<br><br><strong>最基本的对应属性操作的方法，在JDK中不是使用set和get方法，查看源码知道要得到当前Buffer的limit值使用public final int limit()方法，设定limit的值使用public final Buffer limit(int)方法，其它属性有对应的方法</strong>。<br><br>public final Buffer flip() {用于将写模式转换成读模式<br><br>    limit = position;    //将limit设置为刚才写入的位置<br><br>    position = 0;         //将position设置为0从头开始读<br><br>    mark = -1;<br><br>    return this;<br><br>}<br><br>public final Buffer clear() : 用于清空缓冲区(<strong>并不是真正的清除屌里面的数据</strong>)，准备再次被写入，limit设置为capacity，position设置为0<br><br>public final Buffer rewind() : 源码实现为position=0,mark=-1。目的是为了重复读。<br><br>public final int remaining() : 一句代码return limit - position;<br><br>public final int hasRemaining() : 一句代码return limit &gt; position;<br><br><strong>继承自Buffer的重要类ByteBuffer类中的方法</strong>：<br><br>首先可以看到在ByteBuffer类中多了三个属性，一个byte数组型的，一个int型的offset，还有一个boolean型的isReadOnly，两个构造函数均是Package-private型的。<br><br><strong>可以使用一下方法产生一个ByteBuffer对象：</strong><br><br><strong>方法一(新建一个buffer)：</strong>ByteBuffer bbuf = ByteBuffer.allocate(1024);<br><br>查看源码知道allocate执行这样一句话：<br><br>              return new HeapByteBuffer(int capacity, int capacity);<br><br>而HeapByteBuffer又是ByteBuffer的子类，并且在HeapByteBuffer的构造方法中执行的是这样一个语句：<br><br>super(-1, 0, lim, cap, new byte[cap], 0);<br><br>也就是说调用的还是ByteBuffer中的构造方法，包范围内使用。这个方法做了如下工作，首先调用Buffer的构造方法，依次初始化mark、position、limit、capacity，然后初始化ByteBuffer的属性byte数组，接着初始offset，这样使用allocate方法就可以构造出一个ByteBuffer对象了。<br><br><strong>方法二(对一个存在的buffer进行wrap)：</strong>ByteBuffer bbuf = ByteBuffer.wrap(new Byte[1024] array, 0, 1024);<br><br>这个方法比较好用的一点是当这个Byte数组已经存在的话，直接传入这个Byte数组，然后传入起始值和结束值即可。默认wrap实现是初始值传入为0，结束值传入为Byte数组的长度array.length。<br><br><strong>ByteBuffer类中其它重要方法：</strong><br><br><strong>取出:(将数据读入byte数组中)</strong>get(byte[] dst) 或者 get(byte[] dst, int offset, int len)<br><br>（该方法是用来获取当前ByteBuffer中的指定位置的数据并赋值给dst，最终返回当前对象本身。方法实现时第一步检查参数是否合法，调用的是checkBounds静态包范围私有方法。然后检查len是否大于remaining，接着对dst数组循环赋值，最终返回该对象。）<br><br><strong>放入(将数组中的内容放在buffer中)</strong>put(byte[] src) 或者 put(byte[] src, int offerset, int len)<br><br>（该方法和上面的一对get方法类似，功能是将已有的byte数组从0位置开始放入当前的ByteBuffer中，最终返回ByteBuffer本身。）<br><br>put(ByteBuffer src)<br><br>（该方法将src的remaining逐个放入当前ByteBuffer中，最终返回当前ByteBuffer。）<br><br>除此之外还有类型化的get方法，例如getInt(), getFloat(), getShort()等。<br><br>Buffer的更多内容？<br><br><strong>缓冲区分片</strong>：slice()方法根据现有的缓冲区创建一种子缓冲区，新的缓冲区与原缓冲区共享部分数据。<br><br>只读缓冲区：可以通过调用缓冲区的 asReadOnlyBuffer() 方法，将任何常规缓冲区转换为只读缓冲区，这个方法返回一个与原缓冲区完全相同的缓冲区(并与其共享数据)，只不过它是只读的。只读缓冲区对于保护数据很有用。没有办法将只读缓冲区改变为可写的。<br><br>下面例子对缓冲区进行分片，并操作数据：<br><br>//产生一个ByteBuffer实例<br><br>ByteBuffer buffer = ByteBuffer.allocate( 10 );<br><br>//对该ByteBuffer实例进行初始化<br><br>for (int i=0; i&lt;buffer.capacity(); ++i) {<br><br>buffer.put( (byte)i );<br><br>}<br><br>//修改buffer的position（起点）和limit（终点）<br><br>buffer.position( 3 );<br><br>buffer.limit( 7 );<br><br>//对缓冲区进行分片<br><br>ByteBuffer slice = buffer.slice();<br><br>//对分片的数据进行操作<br><br>for (int i=0; i&lt;slice.capacity(); ++i) {<br><br>byte b = slice.get( i );<br><br>b <em>= 11;<br><br>slice.put( i, b );<br><br>}<br><br>//重新定位并输出结果<br><br>buffer.position( 0 );<br><br>buffer.limit( buffer.capacity() );<br><br>while (buffer.remaining()&gt;0) {<br><br>System.out.println( buffer.get() );<br><br>}<br><br><strong>直接或者间接缓冲区：直接缓冲区可以加快I/O的读写速度，使用allocateDirect(int capacity)产生一个直接缓冲区</strong>。<br><br><strong>内存映射文件(将文件中的部分内容映射到内存中,加快读写)：</strong>下面代码将一个 FileChannel (它的全部或者部分)映射到内存<br><br>中。将文件的前1024个字节映射到内存中：<br><br>MappedByteBuffer mbb = fc.map( FileChannel.MapMode.READ_WRITE, 0, 1024 );

</em> <em> </em><br><br><em> </em> <em>

</em> <em> </em><br><br>Channel是什么？<br><br>Channel 是一个对象，可以通过它读取和写入数据(直接和底层的IO支持抽象)。拿 NIO 与原来的 I/O 做个比较，通道就像是流。<br><br>正如前面提到的，所有数据都通过 Buffer 对象来处理。您永远不会将字节直接写入通道中，相反，您是将数据写入包含一个或者多个字节的缓冲区。同样，您不会直接从通道中读取字节，而是将数据从通道读入缓冲区，再从缓冲区获取这个字节。<br><br><strong>简单的说Channel是：数据的源头或者数据的目的地(写入就是目的地,读取就是源头,直接和底层IO交道)，用于向buffer提供数据或者读取buffer数据，并且对I/O提供异步支持。</strong><br><br>（2）Channel的类图结构？<br><br><img src="http://hi.csdn.net/attachment/201110/15/0_1318674803WGPq.gif" alt=""><br><br>java.nio.channels.Channel是一个公共的接口，所有子Channel均实现了该接口，在java.nio.channels包中还实现了Channels、FileLock、SelectionKey、Selector、Pipe等比较好用的类。<br><br><strong>channel包含三种分别是包含socket，file和pipe三种管道，它实际上是双向交流的通道。</strong><br><br><strong>Channel在JDK中是如何实现的？</strong><br><br>在Channel接口中共定义了两个方法<br><br>public boolean isOpen();   //Tells whether or not this channel is open<br><br>public void close() throws IOException();     //Close this channel<br><br><em> </em> <em><br><br><strong>FileChannel : 使用以下三个方法可以得到一个FileChannel的实例</strong><br><br>FileInputStream.getChannel()<br><br>FileOutputStream.getChannel()<br><br>RandomAccessFile.getChannel()<br><br>上面提到Channel是数据的源头或者数据的目的地，用于向bufer提供数据或者从buffer读取数据。那么在实现了该接口的子类中应该有相应的read和write方法。<br><br>在FileChannel中有以下方法可以使用：<br><br>public long read(ByteBuffer[] dsts)<br><br>Reads a sequence of bytes from this channel into the given buffers.<br><br>public long write(ByteBuffer[] srcs)<br><br>//Writes a sequence of bytes to this channel from the given buffers.

</em> <em> </em><br><br><strong>附加：文件锁定</strong><br><br>FileChannel提供两种方法获得FileLock<br><br>FileLock lock();<br><br>FileLock lock(long position, long size, boolean size);<br><br>使用方法举例：<br><br>要获取文件的一部分上的锁，您要调用一个打开的 FileChannel 上的 lock() 方法。注意，如果要获取一个排它锁，您必须以写方式打开文件。<br><br>RandomAccessFile raf = new RandomAccessFile( “filelocks.txt”, “rw” );<br><br>FileChannel fc = raf.getChannel();<br><br>FileLock lock = fc.lock( start, end, false );<br><br>原始Stream获取channel,然后获取channel的FileLock,然后操作FileLock的Lock和release<br><br>在拥有锁之后，您可以执行需要的任何敏感操作，然后再释放锁：<br><br>lock.release();<br><br><em> </em> <em><br><br>SocketChannel : 使用以下两个方法得到一个SocketChannel的实例<br><br>SocketChannel.open();      //打开一个socket channel<br><br>SocketChannel.open(SocketAddress remote);<br><br>//调用上面的方法，并connect(remote)<br><br>例子代码：<br><br>InetSocketAddress socketAddress = new InetSocketAddress(“<a href="http://www.baidu.com/" target="_blank" rel="external">www.baidu.com</a>”,80);<br><br><em>*SocketChannel sc = SocketChannel.open(socketAddress);</em></em><br><br>sc.read(buffer);<br><br>buffer.flip();<br><br>buffer.clear();<br><br>sc.write(bufer);<br><br>DatagramChannel : 与其它的Channel有相同或者相似的方法。<br><br>参考资料:<br><br><a href="http://blog.csdn.net/tsyj810883979/article/details/6876594" target="_blank" rel="external">http://blog.csdn.net/tsyj810883979/article/details/6876594</a><br><br>Java nio入门教程 IBM开发者园地 <a href="https://www.ibm.com/developerworks/java/tutorials/j-nio/" target="_blank" rel="external">https://www.ibm.com/developerworks/java/tutorials/j-nio/</a><br><br></div>]]></content>
    <summary type="html">
    <![CDATA[<p><strong>NIO概览:</strong></p>
<hr>
<p><strong>所有语言运行时系统提供执行 I/O 较高级别的工具</strong>。在java编程中，标准低版本IO使用流的方式完成I/O操作，所有的I/O都被视为单个的<strong>字节流动</s]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[文本文件中检索关键字]]></title>
    <link href="http://donahue-ldz.github.io/2014/08/26/e6-96-87-e6-9c-ac-e6-96-87-e4-bb-b6-e4-b8-ad-e6-a3-80-e7-b4-a2-e5-85-b3-e9-94-ae-e5-ad-97/"/>
    <id>http://donahue-ldz.github.io/2014/08/26/e6-96-87-e6-9c-ac-e6-96-87-e4-bb-b6-e4-b8-ad-e6-a3-80-e7-b4-a2-e5-85-b3-e9-94-ae-e5-ad-97/</id>
    <published>2014-08-26T11:57:36.000Z</published>
    <updated>2015-03-07T04:42:44.000Z</updated>
    <content type="html"><![CDATA[<p><span style="color: #ff00ff;"><strong>在一个文本文件中检索关键字是一个很常用的技术,实现也不是很难,大致思路就是:将文本文件映射到一个String对象中,然后再indexof或者进行相应的查找操作</strong></span><br>传统的方法就不说了,现在考虑NIO的文件映射,所谓文件映射就是将文件的内容全部或者部分映射到内存中(操作系统支持的),然后再从内存中进行操作,这样能加快文件的读写提高效率<br>涉及到的类有Buffer的实现类MappedByteBuffer,CharSet类,更多相关NIO知识,请自行查阅相关文档<br>直接贴代码:代码为了阐述逻辑,异常就没有处理了</p>
<p>`<br>package testdemo;<br>import java.io.File;<br>import java.io.FileInputStream;<br>import java.io.RandomAccessFile;<br>import java.util.<em>;<br>import java.nio.</em>;<br>import java.nio.channels.FileChannel;<br>import java.nio.charset.Charset;</p>
<p>/**</p>
<ul>
<li>实现在大文本文件中查找字符串操作</li>
<li><p>@author donahue<br><em>
</em>/<br>public class MappedByteBufferDemo {</p>
<p> public static void main(String[] args) {</p>
<pre><code><span class="typename">String</span> pathname = <span class="string">"test.txt"</span>;
<span class="typename">String</span> keys = <span class="string">"test"</span>;
<span class="keyword">File</span> <span class="keyword">file</span> = <span class="keyword">new</span> <span class="keyword">File</span>(pathname);
<span class="keyword">if</span>(MappedByteBufferDemo.serach(<span class="keyword">file</span>, keys))
    System.<span class="keyword">out</span>.println(<span class="string">"true"</span>);
<span class="keyword">else</span> 
    System.<span class="keyword">out</span>.println(<span class="string">"false"</span>);
</code></pre><p> }</p>
<p> public  static boolean serach(File file,String keys){</p>
<pre><code><span class="comment">//将整个文件映射到内存,一本文本文件都不是很大,为了安全,你也可以每次将部分文本文件映射,然后操作</span>
MappedByteBuffer mbb = <span class="keyword">new</span> RandomAccessFile(file, <span class="string">"rw"</span>).getChannel()
    .<span class="built_in">map</span>(FileChannel.MapMode.READ_WRITE, <span class="number">0</span>, file.length());
<span class="comment">//对字符进行解码,当然相应文本文件也应该统一编码</span>
<span class="keyword">String</span> <span class="built_in">str</span> = Charset.forName(<span class="string">"UTF-8"</span>).decode(mbb).toString();
System.out.<span class="built_in">println</span>(<span class="built_in">str</span>);
<span class="keyword">if</span>(<span class="built_in">str</span>.indexOf(keys)!=-<span class="number">1</span>)
    <span class="keyword">return</span> <span class="keyword">true</span>;
<span class="keyword">else</span>
<span class="keyword">return</span> <span class="keyword">false</span> ;
</code></pre><p> }</p>
</li>
</ul>
<p>}</p>
<p>`</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><span style="color: #ff00ff;"><strong>在一个文本文件中检索关键字是一个很常用的技术,实现也不是很难,大致思路就是:将文本文件映射到一个String对象中,然后再indexof或者进行相应的查找操作</strong></span><br>]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[局域网聊天]]></title>
    <link href="http://donahue-ldz.github.io/2014/08/25/e5-b1-80-e5-9f-9f-e7-bd-91-e8-81-8a-e5-a4-a9/"/>
    <id>http://donahue-ldz.github.io/2014/08/25/e5-b1-80-e5-9f-9f-e7-bd-91-e8-81-8a-e5-a4-a9/</id>
    <published>2014-08-25T13:20:02.000Z</published>
    <updated>2015-03-07T04:42:44.000Z</updated>
    <content type="html"><![CDATA[<p><strong>由于UDP的优势,所以局域网内的聊天工具就采用的UDP实现,此聊天工具实现群聊+私聊</strong></p>
<p><strong>简单的分析下:</strong></p>
<p>1.群聊采取Java的类MulticastSocket实现多点广播,MulticastSocket可以将数据以广播的方式将数据发送给在一个广播地址里面的所有客户端<br>2.私聊采取DatagramSocket实现<br><span style="color: #ff0000;"><strong>前提知识:</strong></span></p>
<p>IP多点广播,实现了将单一信息发送到多个接收者的广播,其思想是设置一组特殊的网络地址作为多点广播地址,每一个多点广播地址都被看成一个组,当客户端需要发送,接收广播的时候只需要加入该组即可 IP协议为多点广播提供了特殊的IP地址,IP地址的范围是224.0.0.0~239.255.255.255<br>MulticastSocket将DatagramPacket发送到指定的地址,然后该数据将被发送到加入改组的所有MulticastSocket,MulticastSocket是DatagramSocket的子类</p>
<p><strong>功能实现:</strong><br>1.为了实现发送和接收,创建两个进程,一个用于发送一个用于接收;<br>2.心跳检测,采取MulticastSocket实现,当用户广播自己在线(为了客户端用户列表显示在线),在一个组里面所有MulticastSocket收到之后显示用户在线;<br>3.通讯协议,区分是心跳维持还是广播消息;<br>4.私聊采取DatagramSocket实现,新一个DatagramSocket在一个固定端口进行监听和发送;<br>5.用户列表的实现采取Jlist(重写cellRender),当双击某个Element的时候,代表需要私聊,此时获取用户的IPaddress,构造InetSocketAdrress,发送;<br>6.用户Model,主要就是包含Ip(私聊和唯一区别每一个用户),Ico(头像),chatFrame(聊天窗口,自己维护),lost(心跳检测失败次数,当达到一定次数后显示离线),为了Ip能唯一区分一个用户,则需要重写hashCode()和equals();<br>直接贴重要代码吧:</p>
<p>用户信息model:</p>
<p>`<br>public class UserInfo<br>{<br>    // 该用户的图标<br>    private String icon;<br>    // 该用户的名字<br>    private String name;<br>    // 该用户的MulitcastSocket所在的IP和端口<br>    private SocketAddress address;<br>    // 该用户失去联系的次数<br>    private int lost;<br>    // 该用户对应的交谈窗口<br>    private ChatFrame chatFrame;<br>    public UserInfo(){}<br>    // 有参数的构造器<br>    public UserInfo(String icon , String name<br>        , SocketAddress address , int lost)<br>    {<br>        this.icon = icon;<br>        this.name = name;<br>        this.address = address;<br>        this.lost = lost;<br>    }<br>        //省略setter和getter<br>        // 使用address作为该用户的标识，所以根据address作为<br>    // 重写hashCode()和equals方法的标准<br>    public int hashCode()<br>    {<br>        return address.hashCode();<br>    }<br>    public boolean equals(Object obj)<br>    {<br>        if (obj != null &amp;&amp; obj.getClass() == UserInfo.class)<br>        {<br>            UserInfo target = (UserInfo)obj;<br>            if (address != null)<br>            {<br>                return address.equals(target.getAddress());<br>            }<br>        }<br>        return false;<br>    }<br>}</p>
<p><code>简单协议类:</code></p>
<p>public interface Protocol<br>{<br>    String PRESENCE = “⊿⊿”;<br>    String SPLITTER = “▓”;<br>}</p>
<p>`</p>
<p>这是最重要的一个类,对于消息的接收,发送和处理</p>
<p>`</p>
<p>public class ComUtil<br>{<br>    // 使用常量作为本程序的多点广播IP地址<br>    private static final String BROADCAST_IP<br>        = “230.0.0.1”;<br>    // 使用常量作为本程序的多点广播目的的端口<br>    // DatagramSocket所用的的端口为该端口-1。<br>    public static final int BROADCAST_PORT = 30000;<br>    // 定义每个数据报的最大大小为4K<br>    private static final int DATA_LEN = 4096;<br>    // 定义本程序的MulticastSocket实例<br>    private MulticastSocket socket = null;<br>    // 定义本程序私聊的Socket实例<br>    private DatagramSocket singleSocket = null;<br>    // 定义广播的IP地址<br>    private InetAddress broadcastAddress = null;<br>    // 定义接收网络数据的字节数组<br>    byte[] inBuff = new byte[DATA_LEN];<br>    // 以指定字节数组创建准备接受数据的DatagramPacket对象<br>    private DatagramPacket inPacket =<br>        new DatagramPacket(inBuff , inBuff.length);<br>    // 定义一个用于发送的DatagramPacket对象<br>    private DatagramPacket outPacket = null;<br>    // 聊天的主界面程序<br>    private LanTalk lanTalk;<br>    // 构造器，初始化资源<br>    public ComUtil(LanTalk lanTalk) throws Exception<br>    {<br>        this.lanTalk = lanTalk;<br>        // 创建用于发送、接收数据的MulticastSocket对象<br>        // 因为该MulticastSocket对象需要接收，所以有指定端口<br>        socket = new MulticastSocket(BROADCAST_PORT);<br>        // 创建私聊用的DatagramSocket对象<br>        singleSocket = new DatagramSocket(BROADCAST_PORT + 1);<br>        broadcastAddress = InetAddress.getByName(BROADCAST_IP);<br>        // 将该socket加入指定的多点广播地址<br>        socket.joinGroup(broadcastAddress);<br>        // 设置本MulticastSocket发送的数据报被回送到自身<br>        socket.setLoopbackMode(false);<br>        // 初始化发送用的DatagramSocket，它包含一个长度为0的字节数组<br>        outPacket = new DatagramPacket(new byte[0]<br>            , 0 , broadcastAddress , BROADCAST_PORT);<br>        // 启动两个读取网络数据的线程<br>        new ReadBroad().start();<br>        Thread.sleep(1);<br>        new ReadSingle().start();<br>    }<br>    // 广播消息的工具方法<br>    public void broadCast(String msg)<br>    {<br>        try<br>        {<br>            // 将msg字符串转换字节数组<br>            byte[] buff = msg.getBytes();<br>            // 设置发送用的DatagramPacket里的字节数据<br>            outPacket.setData(buff);<br>            // 发送数据报<br>            socket.send(outPacket);<br>        }<br>        // 捕捉异常<br>        catch (IOException ex)<br>        {<br>            ex.printStackTrace();<br>            if (socket != null)<br>            {<br>                // 关闭该Socket对象<br>                socket.close();<br>            }<br>            JOptionPane.showMessageDialog(null<br>                , “发送信息异常，请确认30000端口空闲，且网络连接正常！”<br>                , “网络异常”, JOptionPane.ERROR_MESSAGE);<br>            System.exit(1);<br>        }<br>    }<br>    // 定义向单独用户发送消息的方法<br>    public void sendSingle(String msg , SocketAddress dest)<br>    {<br>        try<br>        {<br>            // 将msg字符串转换字节数组<br>            byte[] buff = msg.getBytes();<br>            DatagramPacket packet = new DatagramPacket(buff<br>                , buff.length , dest);<br>            singleSocket.send(packet);<br>        }<br>        // 捕捉异常<br>        catch (IOException ex)<br>        {<br>            ex.printStackTrace();<br>            if (singleSocket != null)<br>            {<br>                // 关闭该Socket对象<br>                singleSocket.close();<br>            }<br>            JOptionPane.showMessageDialog(null<br>                , “发送信息异常，请确认30001端口空闲，且网络连接正常！”<br>                , “网络异常”, JOptionPane.ERROR_MESSAGE);<br>            System.exit(1);<br>        }<br>    }<br>    // 不断从DatagramSocket中读取数据的线程<br>    class ReadSingle extends Thread<br>    {<br>        // 定义接收网络数据的字节数组<br>        byte[] singleBuff = new byte[DATA_LEN];<br>        private DatagramPacket singlePacket =<br>            new DatagramPacket(singleBuff , singleBuff.length);<br>        public void run()<br>        {<br>            while (true)<br>            {<br>                try<br>                {<br>                    // 读取Socket中的数据。<br>                    singleSocket.receive(singlePacket);<br>                    // 处理读到的信息<br>                    lanTalk.processMsg(singlePacket , true);<br>                }<br>                // 捕捉异常<br>                catch (IOException ex)<br>                {<br>                    ex.printStackTrace();<br>                    if (singleSocket != null)<br>                    {<br>                        // 关闭该Socket对象<br>                        singleSocket.close();<br>                    }<br>                    JOptionPane.showMessageDialog(null<br>                        , “接收信息异常，请确认30001端口空闲，且网络连接正常！”<br>                        , “网络异常”, JOptionPane.ERROR_MESSAGE);<br>                    System.exit(1);<br>                }<br>            }<br>        }<br>    }<br>    // 持续读取MulticastSocket的线程<br>    class ReadBroad extends Thread<br>    {<br>        public void run()<br>        {<br>            while (true)<br>            {<br>                try<br>                {<br>                    // 读取Socket中的数据。<br>                    socket.receive(inPacket);<br>                    // 打印输出从socket中读取的内容<br>                    String msg = new String(inBuff , 0<br>                        , inPacket.getLength());<br>                    // 读到的内容是在线信息<br>                    if (msg.startsWith(YeekuProtocol.PRESENCE)<br>                        &amp;&amp; msg.endsWith(YeekuProtocol.PRESENCE))<br>                    {<br>                        String userMsg = msg.substring(2<br>                            , msg.length() - 2);<br>                        String[] userInfo = userMsg.split(YeekuProtocol<br>                            .SPLITTER);<br>                        UserInfo user = new UserInfo(userInfo[1]<br>                            , userInfo[0] , inPacket.getSocketAddress(), 0);<br>                        // 控制是否需要添加该用户的旗标<br>                        boolean addFlag = true;<br>                        ArrayList<integer> delList = new ArrayList&lt;&gt;();<br>                        // 遍历系统中已有的所有用户,该循环必须循环完成<br>                        for (int i = 1 ; i &lt; lanTalk.getUserNum() ; i++ )<br>                        {<br>                            UserInfo current = lanTalk.getUser(i);<br>                            // 将所有用户失去联系的次数加1<br>                            current.setLost(current.getLost() + 1);<br>                            // 如果该信息由指定用户发送过来<br>                            if (current.equals(user))<br>                            {<br>                                current.setLost(0);<br>                                // 设置该用户无须添加<br>                                addFlag = false;<br>                            }<br>                            if (current.getLost() &gt; 2)<br>                            {<br>                                delList.add(i);<br>                            }<br>                        }<br>                        // 删除delList中的所有索引对应的用户<br>                        for (int i = 0; i &lt; delList.size() ; i++)<br>                        {<br>                            lanTalk.removeUser(delList.get(i));<br>                        }<br>                        if (addFlag)<br>                        {<br>                            // 添加新用户<br>                            lanTalk.addUser(user);<br>                        }<br>                    }<br>                    // 读到的内容是公聊信息<br>                    else<br>                    {<br>                        // 处理读到的信息<br>                        lanTalk.processMsg(inPacket , false);<br>                    }<br>                }<br>                // 捕捉异常<br>                catch (IOException ex)<br>                {<br>                    ex.printStackTrace();<br>                    if (socket != null)<br>                    {<br>                        // 关闭该Socket对象<br>                        socket.close();<br>                    }<br>                    JOptionPane.showMessageDialog(null<br>                        , “接收信息异常，请确认30000端口空闲，且网络连接正常！”<br>                        , “网络异常”, JOptionPane.ERROR_MESSAGE);<br>                    System.exit(1);<br>                }<br>            }<br>        }<br>    }<br>}</integer></p>
<p>`<br>消息的处理(当消息来的时候如何处理),此处只是让用户弹出一个窗口,为了简单实现.</p>
<p>`<br>public void processMsg(DatagramPacket packet , boolean single)<br>    {<br>        // 获取该发送该数据报的SocketAddress<br>        InetSocketAddress srcAddress = (InetSocketAddress)<br>            packet.getSocketAddress();<br>        // 如果是私聊信息，则该Packet获取的是DatagramSocket的地址，<br>        // 将端口减1才是对应的MulticastSocket的地址<br>        if (single)<br>        {<br>            srcAddress = new InetSocketAddress(srcAddress.getHostName()<br>                , srcAddress.getPort() - 1);<br>        }<br>        UserInfo srcUser = getUserBySocketAddress(srcAddress);<br>        if (srcUser != null)<br>        {<br>            // 确定消息将要显示到哪个用户对应窗口上。<br>            UserInfo alertUser = single ? srcUser : getUser(0);<br>            // 如果该用户对应的窗口为空，显示该窗口<br>            if (alertUser.getChatFrame() == null)<br>            {<br>                alertUser.setChatFrame(new ChatFrame(null , alertUser));<br>            }<br>            // 定义添加的提示信息<br>            String tipMsg = single ? “对您说：” : “对大家说：”;<br>            // 显示提示信息<br>            alertUser.getChatFrame().addString(srcUser.getName()</p>
<pre><code>            + tipMsg + <span class="string">"......................("</span>
            + formatter.format(<span class="keyword">new</span> <span class="type">Date</span><span class="literal">()</span>) + <span class="string">")\n"</span>
            + <span class="keyword">new</span> <span class="type">String</span>(packet.getData<span class="literal">()</span> , <span class="number">0</span> , packet.getLength<span class="literal">()</span>)
            + <span class="string">"\n"</span>);
        <span class="keyword">if</span> (!alertUser.getChatFrame<span class="literal">()</span>.isShowing<span class="literal">()</span>)
        {
            alertUser.getChatFrame<span class="literal">()</span>.setVisible(<span class="literal">true</span>);
        }
    }
}
</code></pre><p>`</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>由于UDP的优势,所以局域网内的聊天工具就采用的UDP实现,此聊天工具实现群聊+私聊</strong></p>
<p><strong>简单的分析下:</strong></p>
<p>1.群聊采取Java的类MulticastSocket实现多点广播,Mult]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[socket文件传送]]></title>
    <link href="http://donahue-ldz.github.io/2014/08/24/socket-e6-96-87-e4-bb-b6-e4-bc-a0-e9-80-81/"/>
    <id>http://donahue-ldz.github.io/2014/08/24/socket-e6-96-87-e4-bb-b6-e4-bc-a0-e9-80-81/</id>
    <published>2014-08-24T01:39:14.000Z</published>
    <updated>2015-03-07T04:42:44.000Z</updated>
    <content type="html"><![CDATA[<p>项目中有一个技术点用到了<strong>socket的文件传送功能</strong>,多线程文件传送.由于多线程文件传送在基于单线程传送的时候比较简单,本文就简单介绍基于单线程传送,顺便提下我自己实现的多线程文件传送功能<br><span style="color: #ff00ff;"><strong>涉及知识要点:</strong></span><br>1.传送协议:在传送的过程中,传送双发必须事先约定如何传送,比如先传文件名长度,传文件名,传文件长度,传文件内容…<br>2.多线程的情况,考虑线程同步,每个线程传送的内容,以及如何在接收方组装<br>…<br><strong><span style="color: #ff00ff;">主要涉及类Channel,Buffer,有了这两个类,操作文件变得十分简单了!</span></strong></p>
<p>简单设计如下:</p>
<h2 id=""><a href="http://www.donahueblogs.com/wp-content/uploads/2014/08/Selection_001.png" target="_blank" rel="external"><img src="http://www.donahueblogs.com/wp-content/uploads/2014/08/Selection_001-300x78.png" alt="Selection_001"></a></h2><p>Client Socket先发送文件名长度,文件名,然后flush();<br>Server ServerSocket接受,然后构造相应的文件名,然后在准备存储的路径下面新建一个文件,并且打开文件和文件流的关联,方便写入;<br><strong>注意:所有发送的数据全是字节,所以客户端和服务器端都必须将相应的整数转换成字节或者将相应字节转换成整数<strong></strong></strong></p>
<p>然后客户端通过Channel和Buffer类循环发送文件内容,<strong><span style="color: #ff00ff;">此时一定要注意服务器端如何接受文件,由于再接收文件的时候只知道了文件的饿大小,但是不能直接按照这个指标去接收文件大小,由于客户端发送文件有快有慢,所以必须考虑Socket流中可获得的实际字节</span></strong><br>贴关键代码如下:</p>
<p>`<br>public void run() {<br>    try {<br>        // 首先获取文件名的长度,约定是四个字节,所以就直接就在流里面读取四个字节<br>        byte[] fileNameSize = new byte[4];<br>        if (bis.read(fileNameSize) == -1) {<br>              return;<br>        }<br>        // 获得文件名的长度int字节<br>        int len = BasicTypeConverter.bytesToInt(fileNameSize);<br>        // 获得文件名<br>        ByteBuffer buffer = ByteBuffer.allocate(len);<br>        int i = 0;<br>        while (buffer.hasRemaining()) {<br>            byte[] b = new byte[len - i];<br>            i+= bis.read(b);<br>            buffer.put(b);<br>        }<br>        String fileName = new String(buffer.array(), “UTF-8”);<br>        // 文件的长度<br>        byte[]fileSize = new byte[8];<br>        bis.read(fileSize);<br>        long fileLen = BasicTypeConverter.byteToLong(fileSize);<br>        // 接收文件并保存<br>        long hasRead = 0;<br>        File file = new File(SAVEPATH + fileName);<br>        if (!file.exists()) {<br>            File dir = file.getParentFile();<br>            if (!dir.exists()) {<br>                dir.mkdirs();<br>            }<br>            file.createNewFile();<br>        }<br>        //将流和文件关联<br>        FileOutputStream fos = new FileOutputStream(file);<br>        while (hasRead &lt; fileLen) {<br>            int avail = bis.available();<br>            byte[] b = new byte[Math.min((int) (fileLen - hasRead), avail)];<br>            int read = bis.read(b);<br>            hasRead += read;<br>            fos.write(b, 0, read);<br>            fos.flush();<br>        }<br>        fos.close();</p>
<pre><code>} <span class="keyword">catch</span> (<span class="keyword">Exception</span> e) {
    e.printStackTrace();
} <span class="keyword">finally</span> {
    <span class="keyword">try</span> {
        socket.close();
        <span class="keyword">if</span> (bis != <span class="keyword">null</span>) {
            bis.close();
        }
        <span class="keyword">if</span> (bos != <span class="keyword">null</span>) {
            bos.close();
        }
    } <span class="keyword">catch</span> (IOException e) {
        e.printStackTrace();
    }
}
</code></pre><p>}<br>`</p>
<p>接下来是字节和整数的转换常用工具,我也把代码贴上分享下</p>
<p>`<br>public class BasicTypeConverter {</p>
<pre><code><span class="javadoc">/**
 * Convert Integer to byte array
 * 
 *<span class="javadoctag"> @param</span> i
 *<span class="javadoctag"> @return</span>
 * 
 * 
 */</span>
<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] intToByte(<span class="keyword">int</span> i) {
    <span class="keyword">byte</span>[] abyte0 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span>];
    abyte0[<span class="number">0</span>] = (<span class="keyword">byte</span>) (<span class="number">0xff</span> &amp; i);
    abyte0[<span class="number">1</span>] = (<span class="keyword">byte</span>) ((<span class="number">0xff00</span> &amp; i) &gt;&gt; <span class="number">8</span>);
    abyte0[<span class="number">2</span>] = (<span class="keyword">byte</span>) ((<span class="number">0xff0000</span> &amp; i) &gt;&gt; <span class="number">16</span>);
    abyte0[<span class="number">3</span>] = (<span class="keyword">byte</span>) ((<span class="number">0xff000000</span> &amp; i) &gt;&gt; <span class="number">24</span>);
    <span class="keyword">return</span> abyte0;
}

<span class="javadoc">/**
 * Convert byte array to Integer
 * 
 *<span class="javadoctag"> @param</span> i
 *<span class="javadoctag"> @return</span>
 * 
 * 
 */</span>
<span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">int</span> <span class="title">bytesToInt</span><span class="params">(<span class="keyword">byte</span>[] bytes)</span> </span>{
    <span class="keyword">int</span> addr = bytes[<span class="number">0</span>] &amp; <span class="number">0xFF</span>;
    addr |= ((bytes[<span class="number">1</span>] &lt;&lt; <span class="number">8</span>) &amp; <span class="number">0xFF00</span>);
    addr |= ((bytes[<span class="number">2</span>] &lt;&lt; <span class="number">16</span>) &amp; <span class="number">0xFF0000</span>);
    addr |= ((bytes[<span class="number">3</span>] &lt;&lt; <span class="number">24</span>) &amp; <span class="number">0xFF000000</span>);
    <span class="keyword">return</span> addr;
    }

<span class="javadoc">/**
 *  Convert long to byte arrray
 *<span class="javadoctag"> @param</span> v
 *<span class="javadoctag"> @return</span> 
 *
 *
 */</span>
<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] longToByte(<span class="keyword">long</span> v) {
    <span class="keyword">byte</span>[] writeBuffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">8</span>];
    writeBuffer[<span class="number">0</span>] = (<span class="keyword">byte</span>) (v &gt;&gt;&gt; <span class="number">56</span>);
    writeBuffer[<span class="number">1</span>] = (<span class="keyword">byte</span>) (v &gt;&gt;&gt; <span class="number">48</span>);
    writeBuffer[<span class="number">2</span>] = (<span class="keyword">byte</span>) (v &gt;&gt;&gt; <span class="number">40</span>);
    writeBuffer[<span class="number">3</span>] = (<span class="keyword">byte</span>) (v &gt;&gt;&gt; <span class="number">32</span>);
    writeBuffer[<span class="number">4</span>] = (<span class="keyword">byte</span>) (v &gt;&gt;&gt; <span class="number">24</span>);
    writeBuffer[<span class="number">5</span>] = (<span class="keyword">byte</span>) (v &gt;&gt;&gt; <span class="number">16</span>);
    writeBuffer[<span class="number">6</span>] = (<span class="keyword">byte</span>) (v &gt;&gt;&gt; <span class="number">8</span>);
    writeBuffer[<span class="number">7</span>] = (<span class="keyword">byte</span>) (v &gt;&gt;&gt; <span class="number">0</span>);
    <span class="keyword">return</span> writeBuffer;
}

<span class="javadoc">/**
 *<span class="javadoctag"> @param</span> readBuffer
 *<span class="javadoctag"> @return</span> 
 *
 */</span>
<span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">long</span> <span class="title">byteToLong</span><span class="params">(<span class="keyword">byte</span>[] readBuffer)</span> </span>{
    <span class="keyword">return</span> (((<span class="keyword">long</span>) readBuffer[<span class="number">0</span>] &lt;&lt; <span class="number">56</span>) + 
            ((<span class="keyword">long</span>) (readBuffer[<span class="number">1</span>] &amp; <span class="number">255</span>) &lt;&lt; <span class="number">48</span>) +
            ((<span class="keyword">long</span>) (readBuffer[<span class="number">2</span>] &amp; <span class="number">255</span>) &lt;&lt; <span class="number">40</span>) + 
            ((<span class="keyword">long</span>) (readBuffer[<span class="number">3</span>] &amp; <span class="number">255</span>) &lt;&lt; <span class="number">32</span>)+ 
            ((<span class="keyword">long</span>) (readBuffer[<span class="number">4</span>] &amp; <span class="number">255</span>) &lt;&lt; <span class="number">24</span>) + 
            ((readBuffer[<span class="number">5</span>] &amp; <span class="number">255</span>) &lt;&lt; <span class="number">16</span>) +
            ((readBuffer[<span class="number">6</span>] &amp; <span class="number">255</span>) &lt;&lt; <span class="number">8</span>) + 
            ((readBuffer[<span class="number">7</span>] &amp; <span class="number">255</span>) &lt;&lt; <span class="number">0</span>));
}
</code></pre><p>}</p>
<p>`<br><strong>我的多线程:</strong><br>我的多线程多文件传送是将每个文件存于List中,然后发送的时候,循环发送每一个文件,计算总大小,然后计算每个线程发送的大小<br>然后给每个线程发送的起始字节,发送长度,服务器端接受的时候,按照给出的起始字节组装文件.<br>每个线程负责一点字节传送…</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>项目中有一个技术点用到了<strong>socket的文件传送功能</strong>,多线程文件传送.由于多线程文件传送在基于单线程传送的时候比较简单,本文就简单介绍基于单线程传送,顺便提下我自己实现的多线程文件传送功能<br><span style="color: #ff]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[简述]]></title>
    <link href="http://donahue-ldz.github.io/2014/08/23/e7-ae-80-e8-bf-b0/"/>
    <id>http://donahue-ldz.github.io/2014/08/23/e7-ae-80-e8-bf-b0/</id>
    <published>2014-08-23T01:33:48.000Z</published>
    <updated>2015-03-07T04:42:44.000Z</updated>
    <content type="html"><![CDATA[<p>其实很早就想写关于这个分类的相关blog了,但是一直苦于没有时间,大家都知道,大学说长不长,说短也不短,时光匆匆,不知不觉就过去了<br>每次做完一个项目,姑且不论项目的大小,实用,和创新,都是一次新的收获很感悟,有些东西哪怕是自己认为很简单的细节,但是只有自己去code的时候才能发现很多自己都不敢相信的bug和意外.所以每次做完一个项目都有很多想说的和想记录的事情,不管技术难点,算法,心情还是感悟<br>可是每次感觉都没有时间,不知不觉就真的没有时间了…<br>总结一个项目:<br>1.能加深对项目的理解,毕竟是团队小组开发,很多东西不能像自己完全开发那样理解的透彻,所以总结能从中发现很多不足,优点,协作…<br>2.能追寻以前自己code的时候的一些思路,有些思路来的很快,走的也很匆忙…<br>3.发现自己当时没有注意到的东西,加深自己对代码架构的理解<br>…</p>
<blockquote>
<p>今天开始我将把我做过的项目,无论含金有多少(我认为都是值得学习),我都会花点时间去记录一些值得回忆的东西</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p>其实很早就想写关于这个分类的相关blog了,但是一直苦于没有时间,大家都知道,大学说长不长,说短也不短,时光匆匆,不知不觉就过去了<br>每次做完一个项目,姑且不论项目的大小,实用,和创新,都是一次新的收获很感悟,有些东西哪怕是自己认为很简单的细节,但是只有自己去code的]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[枚举--java自带]]></title>
    <link href="http://donahue-ldz.github.io/2014/08/20/e6-9e-9a-e4-b8-be-java-e8-87-aa-e5-b8-a6/"/>
    <id>http://donahue-ldz.github.io/2014/08/20/e6-9e-9a-e4-b8-be-java-e8-87-aa-e5-b8-a6/</id>
    <published>2014-08-20T01:04:08.000Z</published>
    <updated>2015-03-07T04:42:44.000Z</updated>
    <content type="html"><![CDATA[<p>之所以完整的再次学习枚举类,是由于在不断的编程中我才知道枚举不像我原来想象的那样简单,或者我根本就没有彻底理解枚举类的精髓<br>关键字enum<br>1.可以实现一个或者多个接口,但是枚举类默认继承的是Java.lang.Enum类,不是java.lang.object类,其中Enum类实现了serializable和comparable两个接口<br>2.使用enum定义的非抽象的枚举类默认使用final修饰,不能派生子类<br>3.枚举类的构造器只能被private修饰<br>4.枚举类的所有实例只能在第一行列出,列举这些实例的同时系统会自动添加public static final;多个以逗号分开,最后一个用;号<br>5.枚举类的实例只能是枚举值,不能new出来</p>
<p>引用实例变量的时候 枚举名.实例名</p>
<p>Enum类提供的方法有<br>int  compareTo() 比较实例下标<br>String toString() 实例的名称和name()相似<br>int Ordinal() 返回枚举值在枚举中的索引值<br>public static <t extends="" enum<t="">&gt;T valueof(Class<t>enumType,String name) 根据枚举实例的名字取得枚举实例对象</t></t></p>
<p>枚举实例通用类的函数例如<br>`</p>
<p>public enum Gender<br>{<br>    //此处的枚举值必须调用对应构造器来创建<br>    MALE(“男”),FEMALE(“女”);<br>    private final String name;<br>    //枚举类的构造器只能使用private修饰<br>    private Gender(String name)<br>    {<br>        this.name = name;<br>    }<br>    public String getName()<br>    {<br>        return this.name;<br>    }<br>}</p>
<p><code>上面的MALE和FEMALE都同用相同的Gender()和getName(),其实是MALE对象是new出来的,但是这里构造是私有罢了</code><br>public enum Operation2<br>{<br>    PLUS<br>    {<br>        public double eval(double x , double y)<br>        {<br>            return x + y;<br>        }<br>    },<br>    MINUS<br>    {<br>        public double eval(double x , double y)<br>        {<br>            return x - y;<br>        }<br>    },<br>    TIMES<br>    {<br>        public double eval(double x , double y)<br>        {<br>            return x * y;<br>        }<br>    },<br>    DIVIDE<br>    {<br>        public double eval(double x , double y)<br>        {<br>            return x / y;<br>        }<br>    };<br>    //为枚举类定义一个抽象方法，<br>    //这个抽象方法由不同枚举值提供不同的实现<br>    public abstract double eval(double x, double y);<br>    public static void main(String[] args)<br>    {<br>        System.out.println(Operation2.PLUS.eval(3, 4));<br>        System.out.println(Operation2.MINUS.eval(5, 4));<br>        System.out.println(Operation2.TIMES.eval(5, 4));<br>        System.out.println(Operation2.DIVIDE.eval(5, 4));<br>    }<br>}</p>
<p>`<br>每个独享重载父类的抽象eval函数,匿名重载…</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>之所以完整的再次学习枚举类,是由于在不断的编程中我才知道枚举不像我原来想象的那样简单,或者我根本就没有彻底理解枚举类的精髓<br>关键字enum<br>1.可以实现一个或者多个接口,但是枚举类默认继承的是Java.lang.Enum类,不是java.lang.object类]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[深入枚举--自定义枚举类]]></title>
    <link href="http://donahue-ldz.github.io/2014/08/19/e6-b7-b1-e5-85-a5-e6-9e-9a-e4-b8-be-e8-87-aa-e5-ae-9a-e4-b9-89-e6-9e-9a-e4-b8-be-e7-b1-bb/"/>
    <id>http://donahue-ldz.github.io/2014/08/19/e6-b7-b1-e5-85-a5-e6-9e-9a-e4-b8-be-e8-87-aa-e5-ae-9a-e4-b9-89-e6-9e-9a-e4-b8-be-e7-b1-bb/</id>
    <published>2014-08-19T03:22:46.000Z</published>
    <updated>2015-03-07T04:42:44.000Z</updated>
    <content type="html"><![CDATA[<p><span style="color: #ff00ff;"><strong>在某些情况下,一个类的对象是有限且固定的,比如季节(春,夏,秋,冬),在java里面对象有限且固定的类被称为枚举类.</strong></span><br><strong>手动实现枚举类的设子方式如下:</strong><br>1. private将构造器隐藏起来<br>2.把类所有可能实例都使用public static final 修饰<br>3.如果有必要提供静态方法,允许程序通过特点参数获取特定实例</p>
<p>&nbsp;</p>
<p>`<br>public class Season<br>{<br>    //把Season类定义成不可变的，将其Field也定义成final<br>    private final String name;<br>    private final String desc;<br>    public static final Season SPRING<br>        = new Season(“春天” , “趁春踏青”);<br>    public static final Season SUMMER<br>        = new Season(“夏天” , “夏日炎炎”);<br>    public static final Season FALL<br>        = new Season(“秋天” , “秋高气爽”);<br>    public static final Season WINTER<br>        = new Season(“冬天” , “围炉赏雪”);<br>    public static Season getSeason(int seasonNum)<br>    {<br>    switch(seasonNum)<br>    {<br>        case 1 :<br>            return SPRING;<br>        case 2 :<br>            return SUMMER;<br>        case 3 :<br>            return FALL;<br>        case 4 :<br>            return WINTER;<br>        default :<br>            return null;<br>        }<br>    }<br>    //将构造器定义成private访问权限<br>    private Season(String name , String desc)<br>    {<br>        this.name = name;<br>        this.desc = desc;<br>    }<br>    //只为name和desc提供getter方法<br>    public String getName()<br>    {<br>        return this.name;<br>    }<br>    public String getDesc()<br>    {<br>        return this.desc;<br>    }<br>}</p>
<p><code>我们可以通过Season.SPRING获得Season的一个对象叫SPRING,当然也可以自己定义静态工厂方法来获取相应的Season的类对象
可以使得程序更加健壮,避免创建对象的随意性.
测试代码</code><br>public class SeasonTest{<br>    public SeasonTest(Season s){<br>         System.out.println(s.getName()+”,这真是一个”+s.getDesc()+”的季节”);<br>         }<br>    public static void main(String args[]){<br>         new SeasonTest(Season.FALL);</p>
<pre><code>}
</code></pre><p>}<br>`</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><span style="color: #ff00ff;"><strong>在某些情况下,一个类的对象是有限且固定的,比如季节(春,夏,秋,冬),在java里面对象有限且固定的类被称为枚举类.</strong></span><br><strong>手动实现枚举类的设子方式如]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[属性和绑定  javafx]]></title>
    <link href="http://donahue-ldz.github.io/2014/08/18/e5-b1-9e-e6-80-a7-e5-92-8c-e7-bb-91-e5-ae-9a-javafx/"/>
    <id>http://donahue-ldz.github.io/2014/08/18/e5-b1-9e-e6-80-a7-e5-92-8c-e7-bb-91-e5-ae-9a-javafx/</id>
    <published>2014-08-18T08:09:40.000Z</published>
    <updated>2015-03-07T04:42:44.000Z</updated>
    <content type="html"><![CDATA[<p><strong>Java语言一直使用JavaBean来表示对象的属性</strong>，这种模式既包含API，也包含设计模式，它已经广泛地被Java应用程序开发者所熟知，开发工具也一直使用这种模式。 这个版本将属性支持引入到了JavaFX中，它基于经过验证的JavaBean的模式，但做了扩展和改进.<br><strong>JavaFX的属性经常通过绑定来综合，这是一种表达变量间关系的强大的机制</strong>。<strong><span style="color: #ff00ff;">当对象被绑定后，一个对象的改变会自动被反射到另一个对象</span></strong>。对应用程序来说，这是非常有用的。例如，绑定可以用在帐单票据跟踪程序中。在这种情况下，当一个独立的帐单改动后，总帐单将会自动改变。另外，绑定还可以应用到图形用户界面（GUI）中，用来将应用程序的基础数据的改变同步显示出来。<br>绑定集成了一个或多个资源，也称为“依赖关系”，绑定观察者保存依赖关系的列表，当检测到变化时自动更新列表</p>
<p><strong>绑定对象:就是在他的依赖对象的值发生改变之后,他自己的值也会发生改变</strong></p>
<p><strong>依赖对象:构成绑定对象值的属性对象</strong></p>
<p>什么是属性,定义一个属性<br><code>import javafx.beans.property.DoubleProperty;
class Bill {
    //定义一个变量来保存属性
    private DoubleProperty amountDue = new DoubleProperty();
    //定义一个getter方法来获取属性的值
    public final double getAmountDue(){return amountDue.get();}
    //定义一个setter来设定属性的值
    public final void setAmountDue(double value){amountDue.set(value);}
    //定义一个getter来访问属性
    public DoubleProperty amountDueProperty() {return amountDue;}
}</code></p>
<p>amountDue该对象的不是一个标准的Java基本数据类型，而是封装了Java基本数据类型，并增加了一些额外功能的封装类。（<span style="color: #ff0000;"><strong>javafx.beans.property包中的类都内置了观察和绑定作为设计的一部分</strong></span>）。<br>属性方法命名规则如下：<br>1. getAmountDue（）是一个标准的getter方法，返回当前值amountDue属性的值。按照惯例，它被声明为final。注意，此方法返回类型是双精度数值而不DoubleProperty类型。<br>2. setAmountDue（double）方法（也被声明为final）是一个标准的setter方法，用来设置属性的值。setter方法是可选的，其参数的类型也是双精度数值。<br><span style="color: #ff00ff;"><strong>3. 最后，amountDueProperty（）方法定义了属性的getter。这是一种新的命名约定，方法中包含了属性的名称（在本例中是amountDue），然后加上“Property”。 返回类型是属性本身的类型（本例中是DoubleProperty）</strong></span></p>
<p>用于绑定的API分为两大类：<br><strong>1.高级别的API：提供了一种简单的方法来创建最常见的绑定用例。它的语法很容易学习和使用，特别是在支持自动完成功能的环境中。比如NetBeans IDE中。(<span style="color: #ff00ff;">通过属性的API进行绑定)</span></strong><br><strong> 2.低级别的API：提供额外的灵活性，可供高级开发人员在高级别API不能满足需要时使用。低级别的API是专为快速执行和小内存占用设计的。(<span style="color: #ff00ff;">自己定义Bindings类的API进行绑定</span>)</strong></p>
<p>使用高级别绑定API:<br>高级别API是在你的应用程序中使用绑定的最快和最简单的方式。 它包括两个部分：Fluent API和绑定类。Fluent API将方法向各种依赖对象公开，而绑定类提供静态工厂方法。<br>要开始使用Fluent API，考虑一个简单的用例。其中两个整数是绑定的，以使他们的值观总是加在一起。在例3中，涉及三个变量：num1（依赖者），num2（依赖者）和sum（绑定）。依赖类型都IntegerProperty，绑定类型是NumberBinding。<br>1.使用fluentAPI<br><code>import javafx.beans.property.IntegerProperty;
import javafx.binding.NumberBinding;
public class Main {
   public static void main(String[] args) {
       IntegerProperty num1 = new IntegerProperty(1);
       IntegerProperty num2 = new IntegerProperty(2);
       NumberBinding sum = num1.add(num2); //注意
       System.out.println(sum.getValue());
       num1.set(2);
       System.out.println(sum.getValue());
      }
}</code><br>2.使用绑定类如下(使用绑定类Bindings的API):<br><code>import javafx.binding.NumberBinding;
import javafx.binding.Bindings;
public class Main {
   public static void main(String[] args) {
      IntegerProperty num1 = new IntegerProperty(1);
      IntegerProperty num2 = new IntegerProperty(2);
      NumberBinding sum = Bindings.add(num1,num2);
      System.out.println(sum.getValue());
      num1.setValue(2);
      System.err.println(sum.getValue());
      }
}</code><br><span style="color: #ff00ff;"><strong>使用低级别绑定API:(自定义Bindings)</strong></span><br>如果高级别API不够满足您的需求，你总是可以使用低级别的API来代替。低级别的API是为那些需要更多灵活性（或更好性能）的开发者准备的，这些特性在高级API中没有提供。<br>`<br>import javafx.beans.property.DoubleProperty;<br>import javafx.binding.DoubleBinding;</p>
<p>public class Main {<br>   public static void main(String[] args) {<br>      final DoubleProperty a = new DoubleProperty(1);<br>      final DoubleProperty b = new DoubleProperty(2);<br>      final DoubleProperty c = new DoubleProperty(3);<br>      final DoubleProperty d = new DoubleProperty(4);<br>       //当实现自定义Bindings时我们需要在构造器中super.bind(),同时覆盖父类的computeValue()已返回现在的值。你不需要判断是否invalid，父类会帮你做这些。<br>      DoubleBinding db = new DoubleBinding() {<br>      {<br>         super.bind(a, b, c, d);<br>      }<br>      @Override<br>      protected double computeValue() {<br>         return (a.get() <em> b.get()) + (c.get() </em> d.get());<br>      }<br>    };</p>
<pre><code>System.<span class="keyword">out</span>.println(<span class="keyword">db</span>.<span class="literal">get</span>());
b.<span class="keyword">set</span>(3);
System.<span class="keyword">out</span>.println(<span class="keyword">db</span>.<span class="literal">get</span>());
</code></pre><p>  }<br>}<br>`<br>使用低级别的API调用继承自绑定类的一个方法并且覆写了computeValue（）方法，返回当前绑定的值。通过这一个自定义的DoubleBinding子类完成这一工作。调用super.bind（）<span style="color: #ff00ff;">向上将依赖传递给DoubleBinding，以便默认无效行为被保留</span>。<strong><span style="color: #ff00ff;">它通常没有必要为你检查绑定是否无效，这些行为通过基类来提供</span></strong>。</p>
<p>探索ObservableValue，InvalidationListener和ChangeListener<br>1.InvalidationListener失效监听,就是当懒加载时候属性的值改变之后会触发listener,但是此时属性此时新的值还没有compute()<br>ChangeListener 改变监听,就是当属性的值彻底改变的时候触发,此时新的值已经compute了</p>
<p>2.Observable与ObservableValue接口负责fire触发property改变通知。Observable触发InvacationListener，而ObservableValue负责触发ChangeListener.<br>我们知道几乎所有的javafx.beans.property包中的类都实现了ObservableValue接口，而ObservableValue接口又是Observable的子接口。所以每一个property类又是一个Observable（Value）.<br><strong><span style="color: #ff0000;">几点需要注意的：</span></strong><br>Observable支持lazy compute懒提交。也就是当值改变之后，不会立即提交计算，只有当需要时在进行compute。<br>所以当值改变之后，该property就会处于invalid状态，会触发InvacationListener.<br>但是假如你的ObservableValue对象，添加的ChangeListener，这个lazy compute就会失效。<br>总结:就是实现了observableValue接口的就能changeListener也能添加InvalidationListener,但是实现Observable的只能添加InvalidationListener 实现了observableValue或者observable接口的类当属性改变的时候,这些接口回去负责通知相应的Listener</p>
<p>一个经典的例子<br>（一个绑定）在它检测到其中的一个依赖的第一时间被标记为无效。无论如何，只有当帐单总数被再次请求时，绑定对象才被重新计算。<br>`<br>import javafx.beans.property.DoubleProperty;<br>import javafx.binding.NumberBinding;<br>import javafx.binding.Bindings;<br>import javafx.beans.value.InvalidationListener;<br>import javafx.beans.value.ObservableValue;</p>
<p>public class Main {<br>   public static void main(String[] args) {<br>      Bill bill1 = new Bill();<br>      Bill bill2 = new Bill();<br>      Bill bill3 = new Bill();<br>      NumberBinding total = Bindings.add(bill1.amountDueProperty().add(bill2.amountDueProperty()),<br>         bill3.amountDueProperty());<br>      total.addListener(new InvalidationListener() {<br>      @Override public void invalidated(ObservableValue o) {<br>           System.out.println(“The binding is now invalid.”);<br>       }<br>});<br>    //第一次调用使绑定失效<br>    bill1.setAmountDue(200.00);<br>    //绑定现在无效<br>    bill2.setAmountDue(100.00);<br>    bill3.setAmountDue(75.00);<br>    //绑定现在有效<br>    System.out.println(total.getValue());<br>    //再次使用失效<br>    bill3.setAmountDue(150.00);<br>    //使它有效<br>    System.out.println(total.getValue());<br>  }<br>}</p>
<p>`<br>分析:<br>属性和绑定类都实现了ObservableValue接口，ObservableValue包装了值并允许它观察改变。JavaFX绑定和属性实现都支持懒惰计算，这意味着当变化发生时，该值不立即重新计算。重新计算稍后发生，也就时当再次请求时。</p>
<p>`</p>
<p>Bill electricBill = new Bill();</p>
<p>electricBill.amountDueProperty().addListener(new ChangeListener(){<br>   @Override public void changed(ObservableValue o,Object oldVal,<br>    Object newVal){<br>System.out.println(“Electric bill has changed!”);<br>    }<br>});<br>//改变立即得到反应,不是懒惰加载<br>electricBill.setAmountDue(100.00);<br>`</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>Java语言一直使用JavaBean来表示对象的属性</strong>，这种模式既包含API，也包含设计模式，它已经广泛地被Java应用程序开发者所熟知，开发工具也一直使用这种模式。 这个版本将属性支持引入到了JavaFX中，它基于经过验证的JavaBean]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[Parent类 javafx]]></title>
    <link href="http://donahue-ldz.github.io/2014/08/18/parent-e7-b1-bb-javafx/"/>
    <id>http://donahue-ldz.github.io/2014/08/18/parent-e7-b1-bb-javafx/</id>
    <published>2014-08-18T07:30:00.000Z</published>
    <updated>2015-03-07T04:42:44.000Z</updated>
    <content type="html"><![CDATA[<p>Parent类是抽象类在javafx里面,他的子类有Control, Group, Region, WebView,父类是Node类<br>parent类代表可以有child node的类,只有能有child node的Node 才能添加child node</p>
<p>这里有三个具体的子类:<br>group:可以对其的所有child节点应用effects 和transform<br>region: 他的child能被应用css和layout布局,region的节点的大小不能由应用程序指定,只能由其父节点负责指定(如getWidth()返回的是父节点的width属性….)如果真要自己指定的化可以重载  preferred size range by setting the minHeight, prefHeight, and maxHeight properties</p>
<p>base control:high-level skinnable nodes designed for user interaction 他的子类都是位于control包下面常见的Ui控件</p>
<p>1.Scene Graph体系结构浅析</p>
<p>javafx以tree的形式组织nodes,每一个node就是一个control,即UI组件。</p>
<p>node分为leaf node与branch node， root node。</p>
<p>scene体系中最关键的类：</p>
<p>Scene:代表包含所有UI组件的顶级容器</p>
<p>Node：是一个抽象类，代表UI组件的基类</p>
<p><strong>Parent:是一个抽象类，代表branch node的基类。<strong>要想自己定义branch node的话可以extends Parent类</strong></strong></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Parent类是抽象类在javafx里面,他的子类有Control, Group, Region, WebView,父类是Node类<br>parent类代表可以有child node的类,只有能有child node的Node 才能添加child node</p>
<p>]]>
    </summary>
    
  </entry>
  
</feed>