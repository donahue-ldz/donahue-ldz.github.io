<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[心缘冰河]]></title>
  <subtitle><![CDATA[写出我人生,coding]]></subtitle>
  <link href="//atom.xml" rel="self"/>
  <link href="http://donahue-ldz.github.io/"/>
  <updated>2015-04-06T03:22:01.000Z</updated>
  <id>http://donahue-ldz.github.io/</id>
  
  <author>
    <name><![CDATA[donahue]]></name>
    <email><![CDATA[ldz2012yn@gmail.com]]></email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[java内存模型]]></title>
    <link href="http://donahue-ldz.github.io/2015/04/06/java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
    <id>http://donahue-ldz.github.io/2015/04/06/java内存模型/</id>
    <published>2015-04-06T02:55:35.000Z</published>
    <updated>2015-04-06T03:22:01.000Z</updated>
    <content type="html"><![CDATA[<h3 id="Java虚拟机">Java虚拟机</h3><p>Java虚拟机（Java Virtual Machine 简称JVM）是运行所有Java程序的抽象计算机，是Java语言的运行环境，它是Java 最具吸引力的特性之一。<br>Java虚拟机有自己完善的硬体架构，如处理器、堆栈、寄存器等，还具有相应的指令系统。<br>JVM屏蔽了与具体操作系统平台相关的信息，使得Java程序只需生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。</p>
<p>一个运行时的Java虚拟机实例的天职是：负责运行一个java程序。当启动一个Java程序时，一个虚拟机实例也就诞生了。当该程序关闭退出，这个虚拟机实例也就随之消亡。如果同一台计算机上同时运行三个Java程序，将得到三个Java虚拟机实例。每个Java程序都运行于它自己的Java虚拟机实例中。</p>
<hr>
<h3 id="JVM的体系结构">JVM的体系结构</h3><p>如下图所示，JVM的体系结构包含几个主要的子系统和内存区：<br><img src="/img/jvm_memory.jpg" alt=""></p>
<ol>
<li>垃圾回收器（Garbage Collection）：负责回收堆内存（Heap）中没有被使用的对象，即这些对象已经没有被引用了。</li>
<li>类装载子系统（Classloader Sub-System）：除了要定位和导入二进制class文件外，还必须负责验证被导入类的正确性，为类变量分配并初始化内存，以及帮助解析符号引用。</li>
<li>执行引擎（Execution Engine）：负责执行那些包含在被装载类的方法中的指令。</li>
<li>运行时数据区（Java Memory Allocation Area）：<font color="red">又叫虚拟机内存或者Java内存，虚拟机运行时需要从整个计算机内存划分一块内存区域存储许多东西</font>。例如：字节码、从已装载的class文件中得到的其他信息、程序创建的对象、传递给方法的参数，返回值、局部变量等等。</li>
</ol>
<hr>
<h3 id="java内存分区">java内存分区</h3><p>运行时数据区即是java内存，而且数据区要存储的东西比较多，如果不对这块内存区域进行划分管理，会显得比较杂乱无章。程序喜欢有规律的东西，最讨厌杂乱无章的东西。<br>根据存储数据的不同，：<font color="red">java内存通常被划分为5个区域：程序计数器（Program Count Register）、本地方法栈（Native Stack）、方法区（Methon Area）、栈（Stack）、堆（Heap）</font>。</p>
<ol>
<li>程序计数器（Program Count Register）：又叫程序寄存器。JVM支持多个线程同时运行，当每一个新线程被创建时，它都将得到它自己的PC寄存器（程序计数器）。如果线程正在执行的是一个Java方法（非native），那么PC寄存器的值将总是指向下一条将被执行的指令，如果方法是 native的，程序计数器寄存器的值不会被定义。 JVM的程序计数器寄存器的宽度足够保证可以持有一个返回地址或者native的指针。</li>
<li>栈（Stack）：又叫堆栈。JVM为每个新创建的线程都分配一个栈。<font color="red">也就是说,对于一个Java程序来说，它的运行就是通过对栈的操作来完成的</font>.<strong>栈以帧为单位保存线程的状态</strong>。<code>JVM对栈只进行两种操作：以帧为单位的压栈和出栈操作</code>。我们知道,某个线程正在执行的方法称为此线程的当前方法。我们可能不知道，当前方法使用的帧称为当前帧。当线程激活一个Java方法，JVM就会在线程的 Java堆栈里新压入一个帧，这个帧自然成为了当前帧。在此方法执行期间，这个帧将用来保存参数、局部变量、中间计算过程和其他数据。从Java的这种分配机制来看,堆栈又可以这样理解：栈(Stack)是操作系统在建立某个进程时或者线程(在支持多线程的操作系统中是线程)为这个线程建立的存储区域，该区域具有先进后出的特性。其相关设置参数：<blockquote>
<p>-Xss –设置方法栈的最大值</p>
</blockquote>
</li>
<li>本地方法栈（Native Stack）：存储本地方方法的调用状态。<br><img src="/img/runtime_data_memory.png" alt=""></li>
<li>方法区（Method Area）：当虚拟机装载一个class文件时，它会从这个class文件包含的二进制数据中解析类型信息，然后把这些类型信息（包括类信息、常量、静态变量等）放到方法区中，该内存区域被所有线程共享，如下图所示。<font color="red">本地方法区存在一块特殊的内存区域，叫常量池（Constant Pool）</font></li>
<li>常量池<br>常量池指的是在编译期被确定，并被保存在已编译的.class文件中的一些数据。除了包含代码中所定义的各种基本数据类型和对象型（String及数组）的常量值（final）还包含一些以文本形式出现的符号引用，比如：<br>类和接口的全限定名<br>字段的名称和描述符<br>方法和名称和描述符<br>虚拟机必须在每个被装载的类型维护一个常量池。常量池就是该类型所用到常量的一个有序集合，包括直接常量（string、integer等）和其他类型，字段和方法的符号引用<br>对于String常量，它的值是在常量池中。而JVM中的常量池在内存当中是以表的形式存在的，对于String类型，有一张固定长度的CONSTANT_String_info表用来存储文件字符串值，注意：该表只存储文字字符串值，不存储符号引用。说到这里，对常量池中的字符串值的存储位置应该有一个比较明了的理解了<br>在程序执行的时候，常量池会存在Method Area，而不是堆中<br><img src="/img/method_areo.png" alt=""></li>
<li>堆（Heap）：Java堆（Java Heap）是Java虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域。在此区域的唯一目的就是存放对象实例，几乎所有的对象实例都是在这里分配内存，但是这个对象的引用却是在栈（Stack）中分配。因此，执行<code>String s = new String(“s”)</code>时，需要从两个地方分配内存：在堆中为String对象分配内存，在栈中为引用（这个堆对象的内存地址，即指针）分配内存，如下图所示。<br><img src="/img/heap.png" alt=""></li>
</ol>
<p>JAVA虚拟机有一条在堆中分配新对象的指令，却没有释放内存的指令，正如你无法用Java代码区明确释放一个对象一样。虚拟机自己负责决定如何以及何时释放不再被运行的程序引用的对象所占据的内存，通常，虚拟机把这个任务交给垃圾收集器（Garbage Collection）。其相关设置参数：</p>
<blockquote>
<p>-Xms — 设置堆内存初始大小<br>-Xmx — 设置堆内存最大值<br>-XX:MaxTenuringThreshold — 设置对象在新生代中存活的次数<br>-XX:PretenureSizeThreshold — 设置超过指定大小的大对象直接分配在旧生代中</p>
</blockquote>
<hr>
<h3 id="GC回收">GC回收</h3><p>Java堆是垃圾收集器管理的主要区域，因此又称为“GC 堆”（Garbage Collectioned Heap）。<br>现在的垃圾收集器基本都是采用的<code>分代收集</code>算法，所以Java堆还可以细分为：新生代（Young Generation）和老年代（Old Generation），如下图所示。<br>分代收集算法的思想：</p>
<ul>
<li>第一种说法，用较高的频率对年轻的对象(young generation)进行扫描和回收，这种叫做minor collection，而对老对象(old generation)的检查回收频率要低很多，称为major collection。这样就不需要每次GC都将内存中所有对象都检查一遍，以便让出更多的系统资源供应用系统使用；</li>
<li>另一种说法，在分配对象遇到内存不足时，先对新生代进行GC（Young GC）；当新生代GC之后仍无法满足内存空间分配需求时， 才会对整个堆空间以及方法区进行GC（Full GC）。<br><img src="/img/gc.jpg" alt=""></li>
</ul>
<p>在这里可能会有读者表示疑问：记得还有一个什么永久代（Permanent Generation）的啊，难道它不属于Java堆？亲，你答对了！其实传说中的永久代就是上面所说的方法区，存放的都是jvm初始化时加载器加载的一些类型信息（包括类信息、常量、静态变量等），这些信息的生存周期比较长，GC不会在主程序运行期对PermGen Space进行清理，所以如果你的应用中有很多CLASS的话,就很可能出现PermGen Space错误。</p>
<blockquote>
<p>其相关设置参数：<br>-XX:PermSize –设置Perm区的初始大小<br>-XX:MaxPermSize –设置Perm区的最大值</p>
</blockquote>
<p>新生代（Young Generation）又分为：Eden区和Survivor区，Survivor区有分为From Space和To Space。Eden区是对象最初分配到的地方；默认情况下，From Space和To Space的区域大小相等。<br>JVM进行Minor GC时，将Eden中还存活的对象拷贝到Survivor区中，还会将Survivor区中还存活的对象拷贝到Tenured区中。在这种GC模式下，JVM为了提升GC效率， 将Survivor区分为From Space和To Space，这样就可以将对象回收和对象晋升分离开来。新生代的大小设置有2个</p>
<blockquote>
<p>相关参数：<br>-Xmn — 设置新生代内存大小。<br>-XX:SurvivorRatio — 设置Eden与Survivor空间的大小比例</p>
</blockquote>
<p>老年代（Old Generation）： 当 OLD 区空间不够时， JVM 会在 OLD 区进行 major collection；完全垃圾收集后，若Survivor及OLD区仍然无法存放从Eden复制过来的部分对象，导致JVM无法在Eden区为新对象创建内存区域，则出现”Out of memory错误”  。</p>
<h2 id="参考资料">参考资料</h2><p><a href="http://www.importnew.com/15671.html?from=timeline&amp;isappinstalled=1&amp;nsukey=%2FF7sCOoegm7KjMmTGq2IlsGnrW%2F7YayNB0SWTB43sWRxMuo1A0J8mmzqI4nbPVNyZi6J%2B6xIuwOA%2FCtmoxQ0dQ%3D%3D" target="_blank" rel="external">http://www.importnew.com/15671.html</a></p>
<h2 id="感谢">感谢</h2><p>之前对这块有一定的理解，但是很模糊，看了参考的博文之后感觉收货相当多多呢，谢谢!</p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Java虚拟机">Java虚拟机</h3><p>Java虚拟机（Java Virtual Machine 简称JVM）是运行所有Java程序的抽象计算机，是Java语言的运行环境，它是Java 最具吸引力的特性之一。<br>Java虚拟机有自己完善的硬体架构，如处]]>
    </summary>
    
      <category term="jvm" scheme="http://donahue-ldz.github.io/tags/jvm/"/>
    
      <category term="java" scheme="http://donahue-ldz.github.io/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[mysql索引实现]]></title>
    <link href="http://donahue-ldz.github.io/2015/04/05/mysql%E7%B4%A2%E5%BC%95%E5%AE%9E%E7%8E%B0/"/>
    <id>http://donahue-ldz.github.io/2015/04/05/mysql索引实现/</id>
    <published>2015-04-05T15:15:41.000Z</published>
    <updated>2015-04-05T12:23:14.000Z</updated>
    <content type="html"><![CDATA[<p>在MySQL中，索引属于存储引擎级别的概念，不同存储引擎对索引的实现方式是不同的，本文主要讨论MyISAM和InnoDB两个存储引擎的索引实现方式。</p>
<h3 id="MyISAM索引实现">MyISAM索引实现</h3><p>MyISAM引擎使用B+Tree作为索引结构，叶节点的data域存放的是数据记录的地址。下图是MyISAM索引的原理图：</p>
<p><img src="/img/MyISAM.png" alt=""></p>
<p>这里设表一共有三列，假设我们以Col1为主键，则图是一个MyISAM表的主索引（Primary key）示意。可以看出MyISAM的索引文件仅仅保存数据记录的地址。在MyISAM中，主索引和辅助索引（Secondary key）在结构上没有任何区别，只是主索引要求key是唯一的，而辅助索引的key可以重复。如果我们在Col2上建立一个辅助索引，则此索引的结构如下图所示：<br><img src="/img/MyISAM2.png" alt=""></p>
<p>同样也是一颗B+Tree，data域保存数据记录的地址。因此，MyISAM中索引检索的算法为首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其data域的值，然后以data域的值为地址，读取相应数据记录。</p>
<p>MyISAM的索引方式也叫做<code>非聚集</code>的，之所以这么称呼是为了与InnoDB的聚集索引区分。</p>
<blockquote>
<p>只是存储地址，这样就能将数据和存储分开了，这样的话就算update数据（不是索引部分），索引可能就没有必要改变了，加快了速度呀</p>
</blockquote>
<h3 id="InnoDB索引实现">InnoDB索引实现</h3><p>虽然InnoDB也使用B+Tree作为索引结构，但具体实现方式却与MyISAM截然不同。</p>
<p>第一个重大区别是InnoDB的数据文件本身就是索引文件。从上文知道，MyISAM索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。而在InnoDB中，表数据文件本身就是按B+Tree组织的一个索引结构，这棵树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。</p>
<p><img src="/img/InnoDB.png" alt=""></p>
<p>图是InnoDB主索引（同时也是数据文件）的示意图，可以看到叶节点包含了完整的数据记录。这种索引叫做<code>聚集索引</code>。</p>
<h3 id="MyISAM_和_InnoDB区别">MyISAM 和 InnoDB区别</h3><ol>
<li><p>因为InnoDB的数据文件本身要按主键聚集，所以InnoDB要求表必须有主键（MyISAM可以没有），如果没有显式指定，则MySQL系统会自动选择一个可以唯一标识数据记录的列作为主键，如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整形。</p>
</li>
<li><p>第二个与MyISAM索引的不同是InnoDB的辅助索引data域存储相应记录主键的值而不是地址。换句话说，InnoDB的所有辅助索引都引用主键作为data域。例如，图11为定义在Col3上的一个辅助索引：</p>
</li>
</ol>
<p><img src="/img/InnoDB2.png" alt=""></p>
<p>这里以英文字符的ASCII码作为比较准则。聚集索引这种实现方式使得按主键的搜索十分高效，但是辅助索引搜索需要检索两遍索引：首先检索辅助索引获得主键，然后用主键到主索引中检索获得记录。</p>
<blockquote>
<p>总结：就是说InnoDB中必须包含主键索引，但是MyISAM可以没有主键索引<br>InnoDB中查找的时候先按照辅助索引查找，然后找到主键，然后再在主键索引中去找相关的记录，也就是辅助索引叶子节点中不包含整个记录的完全信息。只有主键索引中才包含所有的整个记录的信息，所以一般在InnoDB实现的时候主键一般不要太长，否则将占用大量的内存.</p>
</blockquote>
<p>了解不同存储引擎的索引实现方式对于正确使用和优化索引都非常有帮助，例如知道了InnoDB的索引实现后，就很容易明白为什么不建议使用过长的字段作为主键，因为所有辅助索引都引用主索引，过长的主索引会令辅助索引变得过大。再例如，用非单调的字段作为主键在InnoDB中不是个好主意，因为InnoDB数据文件本身是一颗B+Tree，非单调的主键会造成在插入新记录时数据文件为了维持B+Tree的特性而频繁的分裂调整，十分低效，而使用自增字段作为主键则是一个很好的选择。</p>
<hr>
<p>为了更好的学习索引相关的只是，让我一起来学习什么时候用索引，以及一些索引的注意事项，<a href="">点这里</a></p>
<h2 id="参考资料">参考资料</h2><p><a href="http://blog.jobbole.com/24006/" target="_blank" rel="external">http://blog.jobbole.com/24006/</a></p>
<p><a href="http://www.mb5u.com/biancheng/mssql/mssql_97413.html" target="_blank" rel="external">hhttp://www.mb5u.com/biancheng/mssql/mssql_97413.html</a></p>
<h2 id="鸣谢">鸣谢</h2><p>感谢两篇文章的作者的努力，才是我现在能较清楚的学习到相关的知识，也顺便引入作者的图片和文章，加上自己的理解</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在MySQL中，索引属于存储引擎级别的概念，不同存储引擎对索引的实现方式是不同的，本文主要讨论MyISAM和InnoDB两个存储引擎的索引实现方式。</p>
<h3 id="MyISAM索引实现">MyISAM索引实现</h3><p>MyISAM引擎使用B+Tree作为索引]]>
    </summary>
    
      <category term="InnoDB" scheme="http://donahue-ldz.github.io/tags/InnoDB/"/>
    
      <category term="MyISAM" scheme="http://donahue-ldz.github.io/tags/MyISAM/"/>
    
      <category term="数据库" scheme="http://donahue-ldz.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[mysql索引数据结构]]></title>
    <link href="http://donahue-ldz.github.io/2015/04/05/mysql%E7%B4%A2%E5%BC%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>http://donahue-ldz.github.io/2015/04/05/mysql索引数据结构/</id>
    <published>2015-04-05T09:16:33.000Z</published>
    <updated>2015-04-05T12:23:04.000Z</updated>
    <content type="html"><![CDATA[<p>MySQL支持诸多存储引擎，而各种存储引擎对索引的支持也各不相同，因此MySQL数据库支持多种索引类型，如BTree索引，哈希索引，全文索引等等，本文只是学习B*索引相关的知识。</p>
<hr>
<h3 id="索引的本质">索引的本质</h3><p>MySQL官方对索引的定义为：索引（Index）是帮助MySQL高效获取数据的数据结构。提取句子主干，就可以得到索引的本质：<font color="red">索引是数据结构</font>.</p>
<p>我们都希望查询数据的速度能尽可能的快，因此数据库系统的设计者会从查询算法的角度进行优化。最基本的查询算法当然是顺序查找（linear search），这种复杂度为O(n)的算法在数据量很大时显然是糟糕的，好在计算机科学的发展提供了很多更优秀的查找算法，例如二分查找（binary search）、二叉树查找（binary tree search）等。</p>
<p>每种查找算法都只能应用于特定的数据结构之上，例如二分查找要求被检索数据有序，而二叉树查找只能应用于二叉查找树上，但是数据本身的组织结构不可能完全满足各种数据结构（例如，理论上不可能同时将两列都按顺序进行组织），所以，<font color="red">在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法。这种数据结构，就是索引。</font></p>
<p><img src="/img/image2.png" alt=""></p>
<p>图1展示了一种可能的索引方式。左边是数据表，一共有两列七条记录，最左边的是数据记录的物理地址（注意逻辑上相邻的记录在磁盘上也并不是一定物理相邻的）。为了加快Col2的查找，可以维护一个右边所示的二叉查找树，每个节点分别包含索引键值和一个指向对应数据记录物理地址的指针，这样就可以运用二叉查找在O(log2n)的复杂度内获取到相应数据。</p>
<p>虽然这是一个货真价实的索引，但是实际的数据库系统几乎没有使用二叉查找树或其进化品种红黑树（red-black tree）实现的，原因会在下文介绍。</p>
<h3 id="B-Tree">B-Tree</h3><p>目前大部分数据库系统及文件系统都采用B-Tree或其变种B+Tree作为索引结构</p>
<p>B-树是一种平衡的多路查找树，它在文件系统中很有用。</p>
<p>定义：一棵m 阶的B-树，或者为空树，或为满足下列特性的m 叉树：</p>
<ul>
<li>树中每个结点至多有m 棵子树；</li>
<li>若根结点不是叶子结点，则至少有两棵子树；</li>
<li>除根结点之外的所有非终端结点至少有[m/2] 棵子树；</li>
<li>所有的非终端结点中包含以下信息数据：<br>（n，A0，K1，A1，K2，…，Kn，An）<br>其中：Ki（i=1,2,…,n）为关键码，且Ki&lt;Ki+1，<br>Ai 为指向子树根结点的指针(i=0,1,…,n)，且指针Ai-1 所指子树中所有结点的关键码均小于Ki (i=1,2,…,n)，An 所指子树中所有结点的关键码均大于Kn.<br>n   为关键码的个数。<br>所有的叶子结点都出现在同一层次上，并且不带信息（可以看作是外部结点或查找失败的结点，实际上这些结点不存在，指向这些结点的指针为空）。<br>即所有叶节点具有相同的深度，等于树高度。</li>
</ul>
<p><img src="/img/B-.png" alt=""></p>
<p>由于B-Tree的特性，在B-Tree中按key检索数据的算法非常直观：首先从根节点进行二分查找，如果找到则返回对应节点的data，否则对相应区间的指针指向的节点递归进行查找，直到找到节点或找到null指针，前者查找成功，后者查找失败。B-Tree上查找算法的伪代码如下：<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">BTree_Search(node, <span class="variable">key</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"> </span><br><span class="line">    foreach(node.<span class="variable">key</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(node.<span class="variable">key</span>[i] == <span class="variable">key</span>) <span class="keyword">return</span> node.data[i];</span><br><span class="line">        <span class="keyword">if</span>(node.<span class="variable">key</span>[i] &gt; <span class="variable">key</span>) <span class="keyword">return</span> BTree_Search(<span class="built_in">point</span>[i]-&gt;node);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> BTree_Search(<span class="built_in">point</span>[i+<span class="number">1</span>]-&gt;node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>data = BTree_Search(root, my_key);</p>
<blockquote>
<p>性质，例如一个度为d的B-Tree，设其索引N个key<br>假设<code>d = m/2    m是m阶B-树</code>则其树高h的上限为logd((N+1)/2)，检索一个key，其查找节点个数的渐进复杂度为O(logdN)。从这点可以看出，B-Tree是一个非常有效率的索引数据结构。 </p>
</blockquote>
<h3 id="B+Tree">B+Tree</h3><p>B-Tree有许多变种，其中最常见的是B+Tree，例如MySQL就普遍使用B+Tree实现其索引结构。</p>
<p>与B-Tree相比，B+Tree有以下不同点：</p>
<ol>
<li><p>每个节点的指针上限为m而不是m+1（更正：B-树多一个是为了指明有多少个关键字）。</p>
</li>
<li><p>内节点不存储data，只存储key；叶子节点不存储指针。</p>
</li>
</ol>
<p><img src="/img/B+.png" alt=""></p>
<p>由于并不是所有节点都具有相同的域，因此B+Tree中叶节点和内节点一般大小不同。这点与B-Tree不同，虽然B-Tree中不同节点存放的key和指针可能数量不一致，但是每个节点的域和上限是一致的，所以在实现中B-Tree往往对每个节点申请同等大小的空间。</p>
<p>一般来说，B+Tree比B-Tree更适合实现外存储索引结构，具体原因与外存储器原理及计算机存取原理有关，将在下面讨论。</p>
<p>带有顺序访问指针的B+Tree</p>
<p>一般在数据库系统或文件系统中使用的B+Tree结构都在经典B+Tree的基础上进行了优化，增加了顺序访问指针。</p>
<p>MySQL索引背后的数据结构及算法原理</p>
<p><img src="/img/image381.png" alt=""></p>
<p>如图所示，在B+Tree的每个叶子节点增加一个指向相邻叶子节点的指针，就形成了带有顺序访问指针的B+Tree。做这个优化的目的是为了提高区间访问的性能，例如图4中如果要查询key为从18到49的所有数据记录，当找到18后，只需顺着节点和指针顺序遍历就可以一次性访问到所有数据节点，极大提到了区间查询效率。</p>
<blockquote>
<p>备注: B+树有用于随机访问和顺序访问的两个指针，一个指针指向头部，用于随机访问，一个指针指向最小的节点，用于顺序访问，方便区间访问<br>在随机访问的时候，我们在内节点上找到key的时候我们不能返回，我们必须一直查找到叶子节点部分才能正式得出，原因是内节点上面不含数据信息只是含有key，只有叶子节点上面才能有相关的额外信息</p>
</blockquote>
<h3 id="为什么使用B-Tree（B+Tree）">为什么使用B-Tree（B+Tree）</h3><p>上文说过，红黑树等数据结构也可以用来实现索引，但是文件系统及数据库系统普遍采用B-/+Tree作为索引结构，这一节将结合计算机组成原理相关知识讨论B-/+Tree作为索引的理论基础。</p>
<p>一般来说，索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上。这样的话，索引查找过程中就要产生磁盘I/O消耗，相对于内存存取，I/O存取的消耗要高几个数量级，所以评价一个数据结构作为索引的优劣最重要的指标就是在查找过程中磁盘I/O操作次数的渐进复杂度。换句话说，索引的结构组织要尽量减少查找过程中磁盘I/O的存取次数。下面先介绍内存和磁盘存取原理，然后再结合这些原理分析B-/+Tree作为索引的效率。</p>
<blockquote>
<p>索引的查找效率主要是看和磁盘I/O的次数，找到之后将相关的东西读入内存之后在内存中采取 二分查找/或者顺序查找 就能找到相关的关键key了。</p>
</blockquote>
<h4 id="主存存取原理">主存存取原理</h4><p>目前计算机使用的主存基本都是随机读写存储器（RAM），现代RAM的结构和存取原理比较复杂，这里本文抛却具体差别，抽象出一个十分简单的存取模型来说明RAM的工作原理。</p>
<p>MySQL索引背后的数据结构及算法原理</p>
<p><img src="/img/image4_thumb.png" alt=""></p>
<p>从抽象角度看，主存是一系列的存储单元组成的矩阵，每个存储单元存储固定大小的数据。每个存储单元有唯一的地址，现代主存的编址规则比较复杂，这里将其简化成一个二维地址：通过一个行地址和一个列地址可以唯一定位到一个存储单元。图展示了一个4 x 4的主存模型。</p>
<p>主存的存取过程如下：</p>
<p>当系统需要读取主存时，则将地址信号放到地址总线上传给主存，主存读到地址信号后，解析信号并定位到指定存储单元，然后将此存储单元数据放到数据总线上，供其它部件读取。</p>
<p>写主存的过程类似，系统将要写入单元地址和数据分别放在地址总线和数据总线上，主存读取两个总线的内容，做相应的写操作。</p>
<p>这里可以看出，主存存取的时间仅与存取次数呈线性关系，因为不存在机械操作，两次存取的数据的“距离”不会对时间有任何影响，例如，先取A0再取A1和先取A0再取D3的时间消耗是一样的。</p>
<h4 id="磁盘存取原理">磁盘存取原理</h4><p>上文说过，索引一般以文件形式存储在磁盘上，索引检索需要磁盘I/O操作。与主存不同，磁盘I/O存在机械运动耗费，因此磁盘I/O的时间消耗是巨大的。</p>
<p>一个磁盘由大小相同且同轴的圆形盘片组成，磁盘可以转动（各个磁盘必须同步转动）。在磁盘的一侧有磁头支架，磁头支架固定了一组磁头，每个磁头负责存取一个磁盘的内容。磁头不能转动，但是可以沿磁盘半径方向运动（实际是斜切向运动），每个磁头同一时刻也必须是同轴的，即从正上方向下看，所有磁头任何时候都是重叠的（不过目前已经有多磁头独立技术，可不受此限制）。</p>
<p>盘片被划分成一系列同心环，圆心是盘片中心，每个同心环叫做一个磁道，所有半径相同的磁道组成一个柱面。磁道被沿半径线划分成一个个小的段，每个段叫做一个扇区，每个扇区是磁盘的最小存储单元。为了简单起见，我们下面假设磁盘只有一个盘片和一个磁头。</p>
<p>当需要从磁盘读取数据时，系统会将数据逻辑地址传给磁盘，磁盘的控制电路按照寻址逻辑将逻辑地址翻译成物理地址，即确定要读的数据在哪个磁道，哪个扇区。为了读取这个扇区的数据，需要将磁头放到这个扇区上方，为了实现这一点，磁头需要移动对准相应磁道，这个过程叫做寻道，所耗费时间叫做寻道时间，然后磁盘旋转将目标扇区旋转到磁头下，这个过程耗费的时间叫做旋转时间。</p>
<blockquote>
<p>柱面+磁盘+扇区（扇区是最小的存储单元）<br>寻道时间+旋转时间+读取时间</p>
</blockquote>
<h4 id="局部性原理与磁盘预读">局部性原理与磁盘预读</h4><p>由于存储介质的特性，磁盘本身存取就比主存慢很多，再加上机械运动耗费，磁盘的存取速度往往是主存的几百分分之一，因此为了提高效率，要尽量减少磁盘I/O。为了达到这个目的，磁盘往往不是严格按需读取，而是每次都会预读，即使只需要一个字节，磁盘也会从这个位置开始，顺序向后读取一定长度的数据放入内存。这样做的理论依据是计算机科学中著名的局部性原理：</p>
<p>当一个数据被用到时，其附近的数据也通常会马上被使用。</p>
<p>程序运行期间所需要的数据通常比较集中。</p>
<p>即使不需要也要多读一点，因为程序一般都是集中存放的呢</p>
<p>由于磁盘顺序读取的效率很高（不需要寻道时间，只需很少的旋转时间），因此对于具有局部性的程序来说，预读可以提高I/O效率。</p>
<p>预读的长度一般为页（page）的整倍数。页是计算机管理存储器的逻辑块，硬件及操作系统往往将主存和磁盘存储区分割为连续的大小相等的块，每个存储块称为一页（在许多操作系统中，页得大小通常为4k），主存和磁盘以页为单位交换数据。当程序要读取的数据不在主存中时，会触发一个缺页异常，此时系统会向磁盘发出读盘信号，磁盘会找到数据的起始位置并向后连续读取一页或几页载入内存中，然后异常返回，程序继续运行。</p>
<blockquote>
<p>缺页中断读取页，预读和局部性原理能加快效率，一次连续读取几个页</p>
</blockquote>
<h3 id="B-/+Tree的性能分析">B-/+Tree的性能分析</h3><p>到这里终于可以分析B-/+Tree索引的性能了。<br>上文说过一般使用磁盘I/O次数评价索引结构的优劣。先从B-Tree分析，根据B-Tree的定义，可知检索一次最多需要访问h(<code>公式见上面的最大高度</code>)个节点。数据库系统的设计者巧妙利用了磁盘预读原理，将一个节点的大小设为等于一个页，这样每个节点只需要一次I/O就可以完全载入。为了达到这个目的，在实际实现B-Tree还需要使用如下技巧：<br>每次新建节点时，直接申请一个页的空间，这样就保证一个节点物理上也存储在一个页里，加之计算机存储分配都是按页对齐的，就实现了一个node只需一次I/O。</p>
<p>B-Tree中一次检索最多需要h-1次I/O（根节点常驻内存），渐进复杂度为O(h)=O(logdN)。一般实际应用中，出度d是非常大的数字，通常超过100，因此h非常小（通常不超过3）。</p>
<p>综上所述，用B-Tree作为索引结构效率是非常高的。</p>
<blockquote>
<p>B*树每个节点就是一个页，每次新建一个节点就是开辟一个页的空间读取整数个页的内容 </p>
</blockquote>
<p>而红黑树这种结构，h明显要深的多。由于逻辑上很近的节点（父子）物理上可能很远，无法利用局部性，所以红黑树的I/O渐进复杂度也为O(h)，效率明显比B-Tree差很多。</p>
<p>上文还说过，B+Tree更适合外存索引，原因和内节点出度d有关。从上面分析可以看到，d越大索引的性能越好，而出度的上限取决于节点内key和data的大小：</p>
<p><code>dmax = floor(pagesize / (keysize + datasize + pointsize))   (pagesize – dmax &gt;= pointsize)</code></p>
<p>或</p>
<p><code>dmax = floor(pagesize / (keysize + datasize + pointsize)) – 1   (pagesize – dmax &lt; pointsize)</code></p>
<p>floor表示向下取整。由于B+Tree内节点去掉了data域，因此可以拥有更大的出度，拥有更好的性能。</p>
<blockquote>
<p>B+更好的原因是由于每个内节点不包含数据，所以每个页（也就是B树的节点）上存放的阶数将会更大，所以访问的深度将比B-树小呢</p>
</blockquote>
<p>为了不使得视觉疲劳，本篇文章就结束了，参见下篇文章<a href="http://donahue-ldz.github.io/2015/04/05/mysql%E7%B4%A2%E5%BC%95%E5%AE%9E%E7%8E%B0/" target="_blank" rel="external">MySQL索引实现</a></p>
<h2 id="参考资料">参考资料</h2><p><a href="http://blog.jobbole.com/24006/" target="_blank" rel="external">http://blog.jobbole.com/24006/</a></p>
<p><a href="http://www.mb5u.com/biancheng/mssql/mssql_97413.html" target="_blank" rel="external">http://www.mb5u.com/biancheng/mssql/mssql_97413.html</a></p>
<h2 id="鸣谢">鸣谢</h2><p>感谢两篇文章的作者的努力，才是我现在能较清楚的学习到相关的知识，也顺便引入作者的图片和文章，加上自己的理解</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>MySQL支持诸多存储引擎，而各种存储引擎对索引的支持也各不相同，因此MySQL数据库支持多种索引类型，如BTree索引，哈希索引，全文索引等等，本文只是学习B*索引相关的知识。</p>
<hr>
<h3 id="索引的本质">索引的本质</h3><p>MySQL官方对索引]]>
    </summary>
    
      <category term="mysql" scheme="http://donahue-ldz.github.io/tags/mysql/"/>
    
      <category term="索引" scheme="http://donahue-ldz.github.io/tags/%E7%B4%A2%E5%BC%95/"/>
    
      <category term="数据库" scheme="http://donahue-ldz.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[再看内部类]]></title>
    <link href="http://donahue-ldz.github.io/2015/04/01/%E5%86%8D%E7%9C%8B%E5%86%85%E9%83%A8%E7%B1%BB/"/>
    <id>http://donahue-ldz.github.io/2015/04/01/再看内部类/</id>
    <published>2015-04-01T07:54:03.000Z</published>
    <updated>2015-04-01T07:56:49.000Z</updated>
    <content type="html"><![CDATA[<p>  今天看spring源码的时候看见静态内部类，之前自己感觉关于内部类的知识掌握的还算可以的但是今天才发现，我还是需要好好的总结和梳理下内部类的相关知识了…</p>
<p>  如果一个类要被声明为static的，只有一种情况，就是静态内部类。如果在外部类声明为static，程序会编译都不会过。</p>
<h2 id="总结">总结</h2><ol>
<li>静态内部类跟静态方法一样，只能访问静态的<strong>外部</strong>成员变量和方法，不能访问非静态的方法和属性，但是普通内部类可以访问任意外部类的成员变量和方法</li>
<li>静态内部类可以声明普通成员变量和方法，而普通内部类不能声明static成员变量和方法(<font color="red"> 除了将变量声明成<code>final static</code></font>)</li>
<li>静态内部类可以单独初始化:<br><code>Inner i = new Outer.Inner();</code><br>备注：一定要记住静态类的实例化方法是这个样子的呢<br>普通内部类初始化：<br><code>Inner i = new Outer().Inner();</code></li>
<li><p>静态内部类的非静态方法也不能访问/静态方法：它们仅能调用其他的static 方法，它们只能访问static数据<br>它们不能以任何方式引用this 或super(this涉及到对象，super 与继承有关）</p>
</li>
<li><p>外部类不能随意访问内部类的变量，内部类是能访问外部类的变量</p>
</li>
</ol>
<p>总之：在分析的时候注意static是在类被classLoader加载的时候就初始化后被所有对象公用了，也就是此时即使没有对象也能访问。 但是普通成员就不是这个样子，必须要有相应的对象才能这样访问。</p>
<hr>
<h2 id="使用场景">使用场景</h2><p> 静态内部类使用场景一般是当外部类需要使用内部类，而内部类无需外部类资源，并且内部类可以单独创建的时候会考虑采用静态内部类的设计</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Outer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">Builder</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Builder</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.age = age;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">withName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">withAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.age = age;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Outer <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Outer(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Outer</span><span class="params">(Builder b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = b.age;</span><br><span class="line">        <span class="keyword">this</span>.name = b.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>静态内部类调用外部类的构造函数，来构造外部类，由于静态内部类可以被单独初始化说有在外部就有以下实现：</p>
<p>public Outer getOuter()<br>{<br>    Outer outer = new Outer.Builder(2).withName(“Yang Liu”).build();<br>    return outer;<br>}</p>
<p>对于静态类总结是：</p>
<ol>
<li>如果类的构造器或静态工厂中有多个参数，设计这样类时，最好使用Builder模式，特别是当大多数参数都是可选的时候。</li>
<li>如果现在不能确定参数的个数，最好一开始就使用构建器即Builder模式。</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>  今天看spring源码的时候看见静态内部类，之前自己感觉关于内部类的知识掌握的还算可以的但是今天才发现，我还是需要好好的总结和梳理下内部类的相关知识了…</p>
<p>  如果一个类要被声明为static的，只有一种情况，就是静态内部类。如果在外部类声明为static，]]>
    </summary>
    
      <category term="静态内部类" scheme="http://donahue-ldz.github.io/tags/%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB/"/>
    
      <category term="java" scheme="http://donahue-ldz.github.io/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[ClassLoader学习]]></title>
    <link href="http://donahue-ldz.github.io/2015/03/27/ClassLoader%E5%AD%A6%E4%B9%A0/"/>
    <id>http://donahue-ldz.github.io/2015/03/27/ClassLoader学习/</id>
    <published>2015-03-27T03:39:38.000Z</published>
    <updated>2015-03-27T03:48:21.000Z</updated>
    <content type="html"><![CDATA[<h3 id="ClassLoader作用">ClassLoader作用</h3><blockquote>
<p>ClassLoader负责载入系统的所有Resources（Class，文件，来自网络的字节流等），通过ClassLoader从而将资源载入JVM。<br>ClassLoader主要对类的请求提供服务，当JVM需要某类时，它根据名称向ClassLoader要求这个类，然后由ClassLoader返回这个类的class对象。 </p>
</blockquote>
<p><code>每个class都有一个reference，指向自己的ClassLoader。</code><br>array的ClassLoader就是其元素的ClassLoader，若是基本数据类型，则这个array没有ClassLoader 。 </p>
<hr>
<h3 id="主要方法">主要方法</h3><p>Java1.1及从前版本中，ClassLoader主要方法：<br>Class loadClass( String name, boolean resolve ) ClassLoader.loadClass() 是 ClassLoader 的入口点 。<br><code>defineClass</code> 方法是ClassLoader的主要诀窍。该方法接受由原始字节组成的数组并把它转换成 Class对象。原始数组包含如从文件系统或网络装入的数据。<br><code>findSystemClass</code> 方法从本地文件系统装入文件。它在本地文件系统中寻找类文件，如果存在，就使用 defineClass 将原始字节转换成 Class 对象，以将该文件转换成类。当运行 Java 应用程序时，这是 JVM 正常装入类的缺省机制。  </p>
<p><code>resolveClass</code>可以不完全地（不带解析）装入类，也可以完全地（带解析）装入类。当编写我们自己的 loadClass 时，可以调用 resolveClass，这取决于 loadClass 的 resolve 参数的值 </p>
<p><code>findLoadedClass</code> 充当一个缓存：当请求loadClass装入类时，它调用该方法来查看 ClassLoader是否已装入这个类，这样可以避免重新装入已存在类所造成的麻烦。应首先调用该方法  。</p>
<h3 id="工作过程">工作过程</h3><p>一般load方法过程如下：</p>
<ul>
<li>调用 findLoadedClass 来查看是否存在已装入的类。  </li>
<li>如果没有，那么采用某种特殊的神奇方式来获取原始字节。（通过IO从文件系统，来自网络的字节流等）  </li>
<li><p>如果已有原始字节，调用 defineClass 将它们转换成 Class 对象。<br>如果没有原始字节，然后调用 findSystemClass从本地文件系统获取类。  </p>
</li>
<li><p>如果 resolve 参数是 true，那么调用 resolveClass 解析 Class 对象。<br>如果还没有类，返回 ClassNotFoundException。  </p>
</li>
<li>否则，将类返回给调用程序。  </li>
</ul>
<h3 id="委托模型">委托模型</h3><p>自从JDK1.2以后，ClassLoader做了改进，使用了委托模型，所有系统中的ClassLoader组成一棵树，<font color="red">ClassLoader在载入类库时先让Parent寻找，Parent找不到才自己找</font>。<br>JVM在运行时会产生三个<br><code>ClassLoader，Bootstrap ClassLoader、Extension ClassLoader和App ClassLoader</code>。</p>
<blockquote>
<ul>
<li>Bootstrap ClassLoader是用C++编写的，在Java中看不到它，是null。它用来加载核心类库，就是在lib下的类库</li>
<li>Extension ClassLoader加载lib/ext下的类库</li>
<li>App ClassLoader加载Classpath里的类库</li>
</ul>
</blockquote>
<font color="red">三者的关系为:App ClassLoader的Parent是Extension ClassLoader，而Extension ClassLoader的Parent为Bootstrap ClassLoader。<br>加载一个类时，首先BootStrap进行寻找，找不到再由Extension ClassLoader寻找，最后才是App ClassLoader。</font>  

<h3 id="为什么要委托模型">为什么要委托模型</h3><p>将ClassLoader设计成委托模型的一个重要原因是出于<code>安全考虑</code>，比如在Applet中，如果编写了一个java.lang.String类并具有破坏性。假如不采用这种委托机制，就会将这个具有破坏性的String加载到了用户机器上，导致破坏用户安全。但采用这种委托机制则不会出现这种情况。因为要加载java.lang.String类时，系统最终会由Bootstrap进行加载，这个具有破坏性的String永远没有机会加载。  </p>
<hr>
<p>委托模型还带来了一些问题，在某些情况下会产生混淆，如下是Tomcat的ClassLoader结构图:  </p>
<pre><code>    Bootstrap 
      | 
    System 
      | 
    Common 
      |    
Catalina  Shared 
          |     
       Webapp1  Webapp2 <span class="keyword">...</span> 
</code></pre><p>由 Common 类装入器装入的类决不能（根据名称）直接访问由 Web 应用程序装入的类。使这些类联系在一起的唯一方法是通过使用这两个类集都可见的接口。在这个例子中，就是包含由 Java servlet 实现的 javax.servlet.Servlet。  </p>
<p>如果在lib或者lib/ext等类库有与应用中同样的类，那么应用中的类将无法被载入。通常在jdk新版本出现有类库移动时会出现问题，例如最初我们使用自己的xml解析器，而在jdk1.4中xml解析器变成标准类库，load的优先级也高于我们自己的xml解析器，我们自己的xml解析器永远无法找到，将可能导致我们的应用无法运行。  </p>
<p>相同的类，不同的ClassLoader，将导致ClassCastException异常  </p>
<hr>
<h3 id="线程中的ClassLoader">线程中的ClassLoader</h3><p> 每个运行中的线程都有一个成员<code>contextClassLoader</code>，用来在运行时动态地载入其它类，可以使用方法Thread.currentThread().setContextClassLoader(…);更改当前线程的contextClassLoader，来改变其载入类的行为；也可以通过方法Thread.currentThread().getContextClassLoader()来获得当前线程的ClassLoader。  </p>
<blockquote>
<p>实际上，在Java应用中所有程序都运行在线程里，如果在程序中没有手工设置过ClassLoader，对于一般的java类如下两种方法获得的ClassLoader通常都是同一个。</p>
</blockquote>
<p><code>this.getClass.getClassLoader()</code><br><code>Thread.currentThread().getContextClassLoader()</code></p>
<p>方法一得到的Classloader是静态的，表明类的载入者是谁；<br>方法二得到的Classloader是动态的，谁执行（某个线程），就是那个执行者的Classloader。<br><strong>对于单例模式的类，静态类等，载入一次后，这个实例会被很多程序（线程）调用，对于这些类，载入的Classloader和执行线程的Classloader通常都不同。</strong></p>
<h3 id="Web应用中的ClassLoader">Web应用中的ClassLoader</h3><p>回到上面的例子，在Tomcat里，WebApp的ClassLoader的工作原理有点不同，它先试图自己载入类（在ContextPath/WEB-INF/…中载入类），如果无法载入，再请求父ClassLoader完成。<br>由此可得：<br>对于WEB APP线程，它的contextClassLoader是WebAppClassLoader<br>对于Tomcat Server线程，它的contextClassLoader是CatalinaClassLoader  </p>
<p>获得ClassLoader的几种方法<br>可以通过如下3种方法得到ClassLoader：<br>this.getClass.getClassLoader(); // 使用当前类的ClassLoader<br>Thread.currentThread().getContextClassLoader(); // 使用当前线程的ClassLoader<br>ClassLoader.getSystemClassLoader(); // 使用系统ClassLoader，即系统的入口点所使用的ClassLoader。</p>
<blockquote>
<p>注意，system ClassLoader与根ClassLoader并不一样。JVM下system ClassLoader通常为App ClassLoader  </p>
</blockquote>
<h3 id="自定义ClassLoader">自定义ClassLoader</h3><ul>
<li>安全性<br>类进入JVM之前先经过ClassLoader，所以可以在这边检查是否有正确的数字签名等.  </li>
<li>加密<br>java字节码很容易被反编译，通过定制ClassLoader使得字节码先加密防止别人下载后反编译，这里的ClassLoader相当于一个动态的解码器  </li>
<li>归档<br>可能为了节省网络资源，对自己的代码做一些特殊的归档，然后用定制的ClassLoader来解档  </li>
<li>自展开程序<br>把java应用程序编译成单个可执行类文件，这个文件包含压缩的和加密的类文件数据，同时有一个固定的ClassLoader，当程序运行时它在内存中完全自行解开，无需先安装.  </li>
<li>动态生成<br>可以生成应用其他还未生成类的类，实时创建整个类并可在任何时刻引入JVM  </li>
</ul>
<h3 id="资源载入">资源载入</h3><p>所有资源都通过ClassLoader载入到JVM里，那么在载入资源时当然可以使用ClassLoader，只是对于不同的资源还可以使用一些别的方式载入，例如对于类可以直接new，对于文件可以直接做IO等。</p>
<h4 id="载入类">载入类</h4><p>假设有类A和类B，A在方法method里需要实例化B，可能的方法有3种。<br>对于载入类的情况，用户需要知道B类的完整名字（包括包名，例如”com.rain.B”)</p>
<ul>
<li><p>使用Class静态方法 Class.forName  </p>
<figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class <span class="keyword">cls</span> = Class.forName(<span class="string">"com.rain.B"</span>)<span class="comment">; </span></span><br><span class="line">B b = (B)<span class="keyword">cls</span>.newInstance()<span class="comment">;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用ClassLoader  </p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Step 1. Get ClassLoader */</span> </span><br><span class="line">ClassLoader <span class="keyword">cl</span>; <span class="comment">//具体获得ClassLoader </span></span><br><span class="line"><span class="comment">/* Step 2. Load the class */</span> </span><br><span class="line"><span class="keyword">Class</span> cls = <span class="keyword">cl</span>.loadClass(<span class="string">"com.rain.B"</span>); <span class="comment">// 使用第一步得到的ClassLoader来载入B </span></span><br><span class="line"><span class="comment">/* Step 3. new instance */</span> </span><br><span class="line">B b = (B)cls.newInstance(); <span class="comment">// 有B的类得到一个B的实例</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>直接new<br>  <code>B b = new B();</code> </p>
</li>
</ul>
<h4 id="文件载入">文件载入</h4><p>（例如配置文件等）假设在com.rain.A类里想读取文件夹 /com/rain/config 里的文件sys.properties，读取文件可以通过绝对路径或相对路径，绝对路径很简单，在Windows下以盘号开始，在Unix下以”/“开始<br>对于相对路径，<code>其相对值是相对于ClassLoader的</code>，<strong>因为ClassLoader是一棵树，所以这个相对路径和ClassLoader树上的任何一个ClassLoader相对比较后可以找到文件，那么文件就可以找到，</strong><font color="red">当然，读取文件也使用委托模型。</font>  </p>
<ul>
<li>直接IO  <figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/<span class="keyword">*</span><span class="keyword">*</span> </span><br><span class="line"> <span class="keyword">*</span> 假设当前位置是 <span class="string">"C:/test"</span>，通过执行如下命令来运行A <span class="string">"java com.rain.A"</span> </span><br><span class="line"> <span class="keyword">*</span> 1. 在程序里可以使用绝对路径，Windows下的绝对路径以盘号开始，Unix下以<span class="string">"/"</span>开始 </span><br><span class="line"> <span class="keyword">*</span> 2. 也可以使用相对路径，相对路径前面没有<span class="string">"/"</span> </span><br><span class="line"> <span class="keyword">*</span> 因为我们在 <span class="string">"C:/test"</span> 目录下执行程序，程序入口点是<span class="string">"C:/test"</span>，相对路径就 </span><br><span class="line"> <span class="keyword">*</span> 是 <span class="string">"com/rain/config/sys.properties"</span> </span><br><span class="line"> <span class="keyword">*</span> （例子中，当前程序的ClassLoader是App ClassLoader，system ClassLoader = 当前的 </span><br><span class="line"> <span class="keyword">*</span> 程序的ClassLoader，入口点是<span class="string">"C:/test"</span>） </span><br><span class="line"> <span class="keyword">*</span> 对于ClassLoader树，如果文件在jdk lib下，如果文件在jdk lib/ext下，如果文件在环境变量里， </span><br><span class="line"> <span class="keyword">*</span> 都可以通过相对路径<span class="string">"sys.properties"</span>找到，lib下的文件最先被找到 </span><br><span class="line"> <span class="keyword">*</span>/ </span><br><span class="line">File f = new File(<span class="string">"C:/test/com/rain/config/sys.properties"</span>); // 使用绝对路径 </span><br><span class="line">//File f = new File(<span class="string">"com/rain/config/sys.properties"</span>); // 使用相对路径 </span><br><span class="line">InputStream is = new FileInputStream(f);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>如果是配置文件，可以通过java.util.Properties.load(is)将内容读到Properties里，Properties默认认为is的编码是ISO-8859-1，如果配置文件是非英文的，可能出现乱码问题。 </p>
<ul>
<li>使用ClassLoader  </li>
</ul>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span><br><span class="line"> * 因为有3种方法得到ClassLoader，对应有如下3种方法读取文件 </span><br><span class="line"> * 使用的路径是相对于这个ClassLoader的那个点的相对路径，此处只能使用相对路径 </span><br><span class="line"> */</span> </span><br><span class="line">InputStream <span class="keyword">is</span> = <span class="literal">null</span>; </span><br><span class="line"><span class="keyword">is</span> = <span class="keyword">this</span>.getClass().getClassLoader().getResourceAsStream( </span><br><span class="line">       <span class="string">"com/rain/config/sys.properties"</span>); <span class="comment">//方法1 </span></span><br><span class="line"><span class="comment">//is = Thread.currentThread().getContextClassLoader().getResourceAsStream( </span></span><br><span class="line">       <span class="string">"com/rain/config/sys.properties"</span>); <span class="comment">//方法2 </span></span><br><span class="line"><span class="comment">//is = ClassLoader.getSystemResourceAsStream("com/rain/config/sys.properties"); //方法3</span></span><br></pre></td></tr></table></figure>
<p>如果是配置文件，可以通过java.util.Properties.load(is)将内容读到Properties里，这里要注意编码问题。  </p>
<ul>
<li>使用ResourceBundle  <figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ResourceBundle</span> bundle = ResourceBundle.getBoundle(<span class="string">"com.rain.config.sys"</span>);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>这种用法通常用来载入用户的配置文件，关于ResourceBunlde更详细的用法请参考其他文档<br>总结：有如下3种途径来载入文件  </p>
<pre><code><span class="number">1.</span> 绝对路径 <span class="comment">---&gt; IO </span>
<span class="number">2.</span> 相对路径 <span class="comment">---&gt; IO </span>
            <span class="comment">---&gt; ClassLoader </span>
<span class="number">3.</span> 资源文件 <span class="comment">---&gt; ResourceBundle </span>
</code></pre><h3 id="web应用里载入资源">web应用里载入资源</h3><p>在web应用里当然也可以使用ClassLoader来载入资源，但更常用的情况是使用ServletContex<br>用户程序通常在classes目录下，如果想读取classes目录里的文件，可以使用ClassLoader，如果想读取其他的文件，一般使用ServletContext.getResource()<br>如果使用ServletContext.getResource(path)方法，路径必须以”/“开始，路径被解释成相对于<code>ContextRoot</code>(<strong>web的根路径</strong>)的路径，此处载入文件的方法和ClassLoader不同</p>
<hr>
<h2 id="参考资料">参考资料</h2><p>ClassLoader 详解及用途 ,感谢作者，使得我第一次如此清楚的理解了类加载器机制！<br><a href="http://blog.chinaunix.net/uid-21227800-id-65885.html" target="_blank" rel="external">参考博客</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="ClassLoader作用">ClassLoader作用</h3><blockquote>
<p>ClassLoader负责载入系统的所有Resources（Class，文件，来自网络的字节流等），通过ClassLoader从而将资源载入JVM。<br>Class]]>
    </summary>
    
      <category term="ClassLoader，类加载器" scheme="http://donahue-ldz.github.io/tags/ClassLoader%EF%BC%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/"/>
    
      <category term="spring源码学习" scheme="http://donahue-ldz.github.io/categories/spring%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[NIO Buffer和Channel]]></title>
    <link href="http://donahue-ldz.github.io/2015/03/25/NIO-Buffer%E5%92%8CChannel/"/>
    <id>http://donahue-ldz.github.io/2015/03/25/NIO-Buffer和Channel/</id>
    <published>2015-03-25T14:57:08.000Z</published>
    <updated>2015-03-25T15:10:41.000Z</updated>
    <content type="html"><![CDATA[<p>所有语言运行时系统提供执行I/O较高级别的工具。</p>
<p>在java编程中，标准低版本IO使用流的方式完成I/O操作，所有的I/O都被视为单个的字节流动，称为一个Stream的对象一次移动一个字节。</p>
<p>NIO是在JDK1.4之后出现的一种新的IO，sun官方标榜的nio有如下特性：</p>
<blockquote>
<ul>
<li>为所有的原始类型提供（Buffer）缓存支持</li>
<li>字符集编码解决方案（Charset）</li>
<li>Channel : 一个新的原始I/O抽象</li>
<li>支持锁和内存映射文件的文件访问接口</li>
<li>提供多路（non-bloking）非阻塞式的高伸缩性网路I/O</li>
</ul>
</blockquote>
<p>NIO包（java.nio.*）引入了四个关键的抽象数据类型，它们共同解决传统的I/O类中的一些问题。</p>
<ol>
<li>Buffer：它是包含数据且用于读写的线形表结构。其中还提供了一个特殊类用于内存映射文件的I/O操作。<br>2． Charset：它提供Unicode字符串影射到字节序列以及逆影射的操作。<br>3． Channels：包含socket，file和pipe三种管道，它实际上是双向交流的通道。<br>4． Selector：它将多元异步I/O操作集中到一个或多个线程中。</li>
</ol>
<hr>
<p>本文先介绍chanel和buffer(通道和缓冲)</p>
<p><code>缓冲区和通道是NIO中的核心对象</code>，通道Channel是对原IO中流的模拟，所有数据都要通过通道进行传输；Buffer实质上是一个容器对象，发送给通道的所有对象都必须首先放到一个缓冲区中。</p>
<h3 id="Buffer是什么？">Buffer是什么？</h3><p>Bufer是一个对象，它包含要写入或者刚读出的数据。这是NIO与IO的一个重要区别，在面向流的I/O中您将数据直接写入或者将数据直接读到stream中。<br>在 NIO 库中，<code>所有数据都是用缓冲区处理的</code>。在读取数据时，它是直接读到缓冲区中的。在写入数据时，它是写入到缓冲区中的。任何时候访问NIO中的数据，您都是将它放到缓冲区中。</p>
<p><code>缓冲区实质上是一个数组</code>。通常它是一个字节数组，但是也可以使用其他种类的数组。<strong>但是一个缓冲区不仅仅是一个数组。缓冲区提供了对数据的结构化访问，而且还可以跟踪系统的读/写进程</strong>。</p>
<blockquote>
<p>简单的说Buffer是：一块连续的内存块，是NIO数据读或写的中转地。</p>
</blockquote>
<h3 id="Buffer的类图结构">Buffer的类图结构</h3><p><img src="/img/buffer.gif" alt="Alt Buffer类图"></p>
<p>Buffer在JDK中是如何实现的？</p>
<blockquote>
<p>JDK源码可以知道，Buffer类是一个抽象类，其中有五个属性，分别是mark、position、limit、capacity、address。并且可以看到这样一行注释：<br><code>//Invariants:mark&lt;=position&lt;=limit&lt;=capacity</code></p>
</blockquote>
<p>一个 buffer 主要由 position、limit、capacity 三个变量来控制读写的过程。这三个变量在读和写时分别代表的含义如下：<br><code>position    当前写入/读取的单位数据的数量</code><br><code>limit    代表最多能写入/读取多少单位的数据量，默认和capacity一致</code><br><code>capacity    Buffer的容量</code></p>
<p>Buffer抽象类并没有指定Buffer的实现方式，看其子类可以发现，比如ByteBuffer中多出几个属性<br><code>其中有个final byte[]类型的属性，可知Buffer其实是用数组实现的。</code></p>
<h3 id="Buffer中的一些方法？">Buffer中的一些方法？</h3><p>最基本的对应属性操作的方法，在JDK中不是使用set和get方法，查看源码知道要得到当前Buffer的limit值使用<br><code>public final int limit()</code>方法，<br>设定limit的值使用<br><code>public final Buffer limit(int)</code>方法，其它属性有对应的方法。</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用于将写模式转换成读模式</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="function">Buffer <span class="title">flip</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    limit = position;    <span class="comment">//将limit设置为刚才写入的位置</span></span><br><span class="line">    position = <span class="number">0</span>;         <span class="comment">//将position设置为0从头开始读</span></span><br><span class="line">    mark = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//用于清空缓冲区(并不是真正的清除里面的数据)</span></span><br><span class="line"><span class="comment">//准备再次被写入，limit设置为capacity，position设置为0</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> Buffer clear() : </span><br><span class="line"></span><br><span class="line">//源码实现为position=0,mark=-1。目的是为了重复读。</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> Buffer rewind() : </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> remaining() : //一句代码<span class="keyword">return</span> limit – position;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> hasRemaining() : //一句代码<span class="keyword">return</span> limit &gt; position;</span><br></pre></td></tr></table></figure>
<h3 id="ByteBuffer类">ByteBuffer类</h3><p>首先可以看到在ByteBuffer类中多了三个属性，一个byte数组型的，一个int型的offset，还有一个boolean型的isReadOnly，两个构造函数均是Package-private型的。</p>
<p>可以使用一下方法产生一个ByteBuffer对象：</p>
<ul>
<li>(新建一个buffer)：ByteBuffer bbuf = ByteBuffer.allocate(1024);</li>
</ul>
<p>查看源码知道allocate执行这样一句话：<br><code>return new HeapByteBuffer(int capacity, int capacity);</code></p>
<p>而HeapByteBuffer又是ByteBuffer的子类，并且在HeapByteBuffer的构造方法中执行的是这样一个语句：<br><code>super(-1, 0, lim, cap, new byte[cap], 0);</code></p>
<p>也就是说调用的还是ByteBuffer中的构造方法，包范围内使用。这个方法做了如下工作，首先调用Buffer的构造方法，依次初始化mark、position、limit、capacity，然后初始化ByteBuffer的属性byte数组，接着初始offset，这样使用allocate方法就可以构造出一个ByteBuffer对象了。</p>
<ul>
<li>(对一个存在的buffer进行wrap)：ByteBuffer bbuf = ByteBuffer.wrap(new Byte[1024] array, 0, 1024);</li>
</ul>
<p>这个方法比较好用的一点是当这个Byte数组已经存在的话，直接传入这个Byte数组，然后传入起始值和结束值即可。默认wrap实现是初始值传入为0，结束值传入为Byte数组的长度array.length。</p>
<hr>
<p>ByteBuffer类中其它重要方法：</p>
<p>取出:(将数据读入byte数组中)get(byte[] dst) 或者 get(byte[] dst, int offset, int len)<br>（该方法是用来获取当前ByteBuffer中的指定位置的数据并赋值给dst，最终返回当前对象本身。方法实现时第一步检查参数是否合法，调用的是checkBounds静态包范围私有方法。然后检查len是否大于remaining，接着对dst数组循环赋值，最终返回该对象。）</p>
<p>放入(将数组中的内容放在buffer中)put(byte[] src) 或者 put(byte[] src, int offerset, int len)</p>
<p>（该方法和上面的一对get方法类似，功能是将已有的byte数组从0位置开始放入当前的ByteBuffer中，最终返回ByteBuffer本身。）<br>put(ByteBuffer src)</p>
<p>（该方法将src的remaining逐个放入当前ByteBuffer中，最终返回当前ByteBuffer。）<br>除此之外还有类型化的get方法，例如getInt(), getFloat(), getShort()等。</p>
<h3 id="Buffer的更多内容？">Buffer的更多内容？</h3><p>缓冲区分片：slice()方法根据现有的缓冲区创建一种子缓冲区，新的缓冲区与原缓冲区共享部分数据。</p>
<p>只读缓冲区：可以通过调用缓冲区的 asReadOnlyBuffer() 方法，将任何常规缓冲区转换为只读缓冲区，这个方法返回一个与原缓冲区完全相同的缓冲区(并与其共享数据)，只不过它是只读的。只读缓冲区对于保护数据很有用。没有办法将只读缓冲区改变为可写的。</p>
<p>下面例子对缓冲区进行分片，并操作数据：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//产生一个ByteBuffer实例</span></span><br><span class="line">ByteBuffer buffer = ByteBuffer.allocate( <span class="number">10</span> );</span><br><span class="line"></span><br><span class="line"><span class="comment">//对该ByteBuffer实例进行初始化</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;buffer.capacity(); ++i) &#123;</span><br><span class="line">buffer.put( (<span class="keyword">byte</span>)i );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//修改buffer的position（起点）和limit（终点）</span></span><br><span class="line"></span><br><span class="line">buffer.position( <span class="number">3</span> );</span><br><span class="line"></span><br><span class="line">buffer.limit( <span class="number">7</span> );</span><br><span class="line"></span><br><span class="line"><span class="comment">//对缓冲区进行分片</span></span><br><span class="line"></span><br><span class="line">ByteBuffer slice = buffer.slice();</span><br><span class="line"></span><br><span class="line"><span class="comment">//对分片的数据进行操作</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;slice.capacity(); ++i) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">byte</span> b = slice.<span class="keyword">get</span>( i );</span><br><span class="line"></span><br><span class="line">b *= <span class="number">11</span>;</span><br><span class="line"></span><br><span class="line">slice.put( i, b );</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重新定位并输出结果</span></span><br><span class="line"></span><br><span class="line">buffer.position( <span class="number">0</span> );</span><br><span class="line"></span><br><span class="line">buffer.limit( buffer.capacity() );</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (buffer.remaining()&gt;<span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">System.<span class="keyword">out</span>.println( buffer.<span class="keyword">get</span>() );</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>直接或者间接缓冲区：直接缓冲区可以加快I/O的读写速度，使用allocateDirect(int capacity)产生一个直接缓冲区。</p>
<p>内存映射文件(将文件中的部分内容映射到内存中,加快读写)：下面代码将一个 FileChannel (它的全部或者部分)映射到内存</p>
<p>中。将文件的前1024个字节映射到内存中：</p>
<p><code>MappedByteBuffer mbb = fc.map( FileChannel.MapMode.READ_WRITE, 0, 1024 );</code></p>
<h3 id="Channel是什么？">Channel是什么？</h3><p><img src="/img/Channels.gif" alt="Alt Buffer类图"><br>Channel 是一个对象，可以通过它读取和写入数据(直接和底层的IO支持抽象)。拿 NIO 与原来的 I/O 做个比较，通道就像是流。</p>
<p>正如前面提到的，所有数据都通过 Buffer 对象来处理。您永远不会将字节直接写入通道中，相反，您是将数据写入包含一个或者多个字节的缓冲区。同样，您不会直接从通道中读取字节，而是将数据从通道读入缓冲区，再从缓冲区获取这个字节。</p>
<p>简单的说Channel是：数据的源头或者数据的目的地(写入就是目的地,读取就是源头,直接和底层IO交道)，用于向buffer提供数据或者读取buffer数据，并且对I/O提供异步支持。</p>
<h3 id="Channel的类图结构？">Channel的类图结构？</h3><p>java.nio.channels.Channel是一个公共的接口，所有子Channel均实现了该接口<br>在java.nio.channels包中还实现了Channels、FileLock、SelectionKey、Selector、Pipe等比较好用的类。</p>
<p><code>channel包含三种分别是包含socket，file和pipe三种管道，它实际上是双向交流的通道</code>。</p>
<p>Channel在JDK中是如何实现的？</p>
<p>在Channel接口中共定义了两个方法</p>
<p><code>public boolean isOpen();   //Tells whether or not this channel is open</code></p>
<p><code>public void close() throws IOException();     //Close this channel</code></p>
<h4 id="FileChannel">FileChannel</h4><p>使用以下三个方法可以得到一个FileChannel的实例</p>
<blockquote>
<p>FileInputStream.getChannel()<br>FileOutputStream.getChannel()<br>RandomAccessFile.getChannel()</p>
</blockquote>
<p>上面提到Channel是数据的源头或者数据的目的地，用于向buffer提供数据或者从buffer读取数据。那么在实现了该接口的子类中应该有相应的read和write方法。</p>
<p>在FileChannel中有以下方法可以使用：</p>
<blockquote>
<p>public long read(ByteBuffer[] dsts)<br>//Reads a sequence of bytes from this channel into the given buffers.<br>public long write(ByteBuffer[] srcs)<br>//Writes a sequence of bytes to this channel from the given buffers.</p>
</blockquote>
<h4 id="文件锁定">文件锁定</h4><p>FileChannel提供两种方法获得FileLock</p>
<blockquote>
<p>FileLock lock();<br>FileLock lock(long position, long size, boolean size);</p>
</blockquote>
<p>要获取文件的一部分上的锁，您要调用一个打开的 FileChannel 上的 lock() 方法。<code>注意，如果要获取一个排它锁，您必须以写方式打开文件</code>。<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">RandomAccessFile raf = new RandomAccessFile( “filelocks.txt”, “rw” );</span><br><span class="line"></span><br><span class="line">FileChannel fc = raf.getChannel();</span><br><span class="line"></span><br><span class="line">FileLock <span class="operator"><span class="keyword">lock</span> = fc.<span class="keyword">lock</span>( <span class="keyword">start</span>, <span class="keyword">end</span>, <span class="literal">false</span> );</span></span><br><span class="line"></span><br><span class="line">//原始Stream获取channel,然后获取channel的FileLock</span><br><span class="line">//然后操作FileLock的<span class="operator"><span class="keyword">Lock</span>和<span class="keyword">release</span></span><br><span class="line">//在拥有锁之后，您可以执行需要的任何敏感操作，然后再释放锁：</span><br><span class="line"></span><br><span class="line"><span class="keyword">lock</span>.<span class="keyword">release</span>();</span></span><br></pre></td></tr></table></figure></p>
<h4 id="SocketChannel">SocketChannel</h4><p>使用以下两个方法得到一个SocketChannel的实例</p>
<blockquote>
<p>SocketChannel.open();      //打开一个socket channel<br>SocketChannel.open(SocketAddress remote);</p>
</blockquote>
<p>//调用上面的方法，并connect(remote)<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">InetSocketAddress socketAddress = newbInetSocketAddress(“www.baidu.<span class="keyword">com</span>”,<span class="number">80</span>);</span><br><span class="line"></span><br><span class="line">SocketChannel sc = SocketChannel.<span class="keyword">open</span>(socketAddress);</span><br><span class="line"></span><br><span class="line">sc.<span class="keyword">read</span>(<span class="keyword">buffer</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">buffer</span>.flip();</span><br><span class="line"></span><br><span class="line"><span class="keyword">buffer</span>.clear();</span><br><span class="line"></span><br><span class="line">sc.<span class="keyword">write</span>(bufer);</span><br></pre></td></tr></table></figure></p>
<h4 id="DatagramChannel">DatagramChannel</h4><p>与其它的Channel有相同或者相似的方法。</p>
<hr>
<h2 id="参考资料">参考资料</h2><p><a href="https://www.ibm.com/developerworks/java/tutorials/j-nio/" target="_blank" rel="external">Java nio入门教程 IBM开发者园地</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>所有语言运行时系统提供执行I/O较高级别的工具。</p>
<p>在java编程中，标准低版本IO使用流的方式完成I/O操作，所有的I/O都被视为单个的字节流动，称为一个Stream的对象一次移动一个字节。</p>
<p>NIO是在JDK1.4之后出现的一种新的IO，sun官]]>
    </summary>
    
      <category term="Buffer" scheme="http://donahue-ldz.github.io/tags/Buffer/"/>
    
      <category term="Channel" scheme="http://donahue-ldz.github.io/tags/Channel/"/>
    
      <category term="NIO" scheme="http://donahue-ldz.github.io/tags/NIO/"/>
    
      <category term="java" scheme="http://donahue-ldz.github.io/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[spring多事务管理]]></title>
    <link href="http://donahue-ldz.github.io/2015/03/15/spring%E5%A4%9A%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/"/>
    <id>http://donahue-ldz.github.io/2015/03/15/spring多事务管理/</id>
    <published>2015-03-15T02:01:36.000Z</published>
    <updated>2015-03-15T02:16:11.000Z</updated>
    <content type="html"><![CDATA[<p>最近在梳理项目的时候对事务控制进行了梳理，深入了解了spring的事务，结合相关资料整理如下</p>
<hr>
<p>Spring抽象的DAO体系兼容多种数据访问技术，它们各有特色，各有千秋。像Hibernate是非常优秀的ORM实现方案，但对底层SQL的控制不太方便；而iBatis则通过模板化技术让你方便地控制SQL，但没有Hibernate那样高的开发效率；自由度最高的当然是直接使用SpringJDBC了，但它也是底层的，灵活的代价是代码的繁复。很难说哪种数据访问技术是最优秀的，只有在某种特定的场景下才能给出答案。</p>
<blockquote>
<p>所以在一个应用中，往往采用多个数据访问技术：一般是两种，一种采用ORM技术框架，而另一种采用偏JDBC的底层技术，两者珠联璧合，形成联合军种，共同御敌。 </p>
</blockquote>
<p>但是，这种联合军种如何应对事务管理的问题呢？我们知道Spring为每种数据访问技术提供了相应的事务管理器，难道需要分别为它们配置对应的事务管理器吗？它们到底是如何协作和工作的呢？这些层出不穷的问题往往压制了开发人员使用联合军种的想法。<br>其实，在这个问题上，我们低估了Spring事务管理的能力。如果你采用了一个高端ORM技术（Hibernate、JPA、JDO），同时采用一个JDBC技术（Spring JDBC、iBatis），由于前者的会话（Session）是对后者连接（Connection）的封装，Spring会“足够智能地”在同一个事务线程让前者的会话封装后者的连接。所以，我们只要直接采用前者的事务管理器就可以了。</p>
<blockquote>
<p>组合: Hibernate+ Spring JDBC或iBatis<br>事务管理: org.springframework.orm.hibernate3.HibernateTransactionManager</p>
<p>组合: JPA+Spring JDBC或iBatis<br>事务管理: org.springframework.orm.jpa.JpaTransactionManager</p>
<p>组合：JDO+Spring JDBC或iBatis<br>事务管理：org.springframework.orm.jdo.JdoTransactionManager</p>
</blockquote>
<hr>
<p>举例：<br><code>Hibernate+Spring JDBC混合框架的事务管理</code>                </p>
<p>由于一般不会出现同时使用多个ORM框架的情况（如Hibernate+JPA），我们不拟对此命题展开论述，只重点研究ORM框架+JDBC框架的情况。Hibernate+Spring JDBC可能是被使用得最多的组合，本节我们通过实例观察事务管理的运作情况。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Service</span>(<span class="string">"userService"</span>)  </span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">BaseService</span> &#123;</span>  </span><br><span class="line">    <span class="annotation">@Autowired</span>  </span><br><span class="line">    <span class="keyword">private</span> <span class="type">HibernateTemplate</span> hibernateTemplate;  </span><br><span class="line">  </span><br><span class="line">    <span class="annotation">@Autowired</span>  </span><br><span class="line">    <span class="keyword">private</span> <span class="type">ScoreService</span> scoreService;  </span><br><span class="line">  </span><br><span class="line">    public void logon(<span class="type">String</span> userName) &#123;  </span><br><span class="line">         </span><br><span class="line">        <span class="comment">//①通过Hibernate技术访问数据  </span></span><br><span class="line">        <span class="type">System</span>.out.println(<span class="string">"before updateLastLogonTime().."</span>);  </span><br><span class="line">        updateLastLogonTime(userName);  </span><br><span class="line">        <span class="type">System</span>.out.println(<span class="string">"end updateLastLogonTime().."</span>);  </span><br><span class="line">          </span><br><span class="line">        <span class="comment">//②通过JDBC技术访问数据  </span></span><br><span class="line">        <span class="type">System</span>.out.println(<span class="string">"before scoreService.addScore().."</span>);  </span><br><span class="line">        scoreService.addScore(userName, <span class="number">20</span>);  </span><br><span class="line">        <span class="type">System</span>.out.println(<span class="string">"end scoreService.addScore().."</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    public void updateLastLogonTime(<span class="type">String</span> userName) &#123;  </span><br><span class="line">        <span class="type">User</span> user = hibernateTemplate.get(<span class="type">User</span>.<span class="keyword">class</span>,userName);  </span><br><span class="line">        user.setLastLogonTime(<span class="type">System</span>.currentTimeMillis());  </span><br><span class="line">        hibernateTemplate.update(user);  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">//③这句很重要，请看下文的分析  </span></span><br><span class="line">        hibernateTemplate.flush();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>①处，使用Hibernate操作数据<br>②处调用ScoreService#addScore()，该方法内部使用Spring JDBC操作数据。<br>③处，我们显式调用了flush()方法，将Session中的缓存同步到数据库中（即马上向数据库发送一条更新记录的SQL语句）。之所以要显式执行flush()方法，原因是在默认情况下，Hibernate对数据的更改只是记录在一级缓存中，要等到事务提交或显式调用flush()方法时才会将一级缓存中的数据同步到数据库中，而提交事务的操作发生在logon()方法返回前。如果所有针对数据库的更改操作都使用Hibernate，这种数据同步的延迟机制并不会产生任何问题。但是，我们在logon()方法中同时采用了Hibernate和SpringJDBC混合数据访问技术，Spring JDBC无法自动感知Hibernate一级缓存，所以如果不及时调用flush()方法将记录数据更改的一级缓存同步到数据库中，则②处通过SpringJDBC进行数据更改的结果将被Hibernate一级缓存中的更改覆盖掉，因为Hibernate一级缓存要等到logon()方法返回前才同步到数据库！<br>ScoreService使用Spring JDBC数据访问技术，其代码如下所示：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.<span class="type">Autowired</span>;  </span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.core.<span class="type">JdbcTemplate</span>;  </span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.<span class="type">Service</span>;  </span><br><span class="line"><span class="keyword">import</span> org.apache.commons.dbcp.<span class="type">BasicDataSource</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="annotation">@Service</span>(<span class="string">"scoreService"</span>)  </span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">ScoreService</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">BaseService</span>&#123;</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="annotation">@Autowired</span>  </span><br><span class="line">    <span class="keyword">private</span> <span class="type">JdbcTemplate</span> jdbcTemplate;  </span><br><span class="line">  </span><br><span class="line">    public void addScore(<span class="type">String</span> userName, int toAdd) &#123;  </span><br><span class="line">        <span class="type">String</span> sql = <span class="string">"UPDATE t_user u SET u.score = u.score + ? WHERE user_name =?"</span>;  </span><br><span class="line">        jdbcTemplate.update(sql, toAdd, userName);  </span><br><span class="line">        <span class="type">BasicDataSource</span> basicDataSource = (<span class="type">BasicDataSource</span>) jdbcTemplate.getDataSource();  </span><br><span class="line">        <span class="comment">//①查看此处数据库激活的连接数量  </span></span><br><span class="line">        <span class="type">System</span>.out.println(<span class="string">"[scoreUserService.addScore]激活连接数量："</span>  </span><br><span class="line">                         +basicDataSource.getNumActive());  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Spring关键的配置文件代码如下所示：<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--①使用<span class="type">Hibernate</span>事务管理器 --&gt;  </span><br><span class="line">&lt;bean id=<span class="string">"hiberManager"</span>  </span><br><span class="line">      class=<span class="string">"org.springframework.orm.hibernate3.HibernateTransactionManager"</span>  </span><br><span class="line">      p:sessionFactory-<span class="keyword">ref</span>=<span class="string">"sessionFactory"</span>/&gt;  </span><br><span class="line">  </span><br><span class="line">&lt;!--②使<span class="type">UserService</span>及<span class="type">ScoreService</span>的公用方法都拥有事务 --&gt;  </span><br><span class="line">&lt;aop:config proxy-target-class=<span class="string">"true"</span>&gt;  </span><br><span class="line">    &lt;aop:pointcut id=<span class="string">"serviceJdbcMethod"</span>  </span><br><span class="line">                  expression=<span class="string">"within(com.baobaotao.mixdao.BaseService+)"</span>/&gt;  </span><br><span class="line">    &lt;aop:advisor pointcut-<span class="keyword">ref</span>=<span class="string">"serviceJdbcMethod"</span>  </span><br><span class="line">                 advice-<span class="keyword">ref</span>=<span class="string">"hiberAdvice"</span>/&gt;  </span><br><span class="line">&lt;/aop:config&gt;  </span><br><span class="line">&lt;tx:advice id=<span class="string">"hiberAdvice"</span> transaction-manager=<span class="string">"hiberManager"</span>&gt;  </span><br><span class="line">    &lt;tx:attributes&gt;  </span><br><span class="line">        &lt;tx:<span class="keyword">method</span> name=<span class="string">"*"</span>/&gt;  </span><br><span class="line">    &lt;/tx:attributes&gt;  </span><br><span class="line">&lt;/tx:advice&gt;  </span><br><span class="line">  </span><br><span class="line">/beans&gt;</span><br></pre></td></tr></table></figure></p>
<p>启动Spring容器，执行UserService#logon()方法，可以查看到如下的执行日志：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">before userService.logon().. </span><br><span class="line"></span><br><span class="line">①在执行userService.logon()后，Spring开启一个事务 </span><br><span class="line">Creating new transaction with name [com.baobaotao.mixdao.UserService.logon]: PROPAGATION_REQUIRED,ISOLATION_DEFAULT </span><br><span class="line">opened session at timestamp: 13009379637 </span><br><span class="line">Opened new Session [org.hibernate.impl.SessionImpl@c5f468] for Hibernate transaction </span><br><span class="line">… </span><br><span class="line">Exposing Hibernate transaction as JDBC transaction [jdbc:mysql://localhost:3306/sampledb, UserName=root@localhost, MySQL-AB JDBC Driver] </span><br><span class="line">before userService.updateLastLogonTime().. </span><br><span class="line"></span><br><span class="line">②userService.updateLastLogonTime()执行时自动绑定到①处开启的Session中 </span><br><span class="line">Found thread-bound Session for HibernateTemplate </span><br><span class="line">loading entity: [com.baobaotao.User#tom] </span><br><span class="line">about to open PreparedStatement (open PreparedStatements: 0, globally: 0) </span><br><span class="line">… </span><br><span class="line">about to close PreparedStatement (open PreparedStatements: 1, globally: 1) </span><br><span class="line">Not closing pre-bound Hibernate Session after HibernateTemplate </span><br><span class="line"><span class="operator"><span class="keyword">end</span> updateLastLogonTime().. </span><br><span class="line"></span><br><span class="line"><span class="keyword">before</span> scoreService.addScore().. </span><br><span class="line"></span><br><span class="line">③scoreService.addScore()执行时绑定到①处开启的<span class="keyword">Session</span>中，并加入其所对应的事务中 </span><br><span class="line"><span class="keyword">Found</span> thread-bound <span class="keyword">Session</span> [org.hibernate.impl.SessionImpl@c5f468] <span class="keyword">for</span> Hibernate </span><br><span class="line"><span class="keyword">transaction</span> </span><br><span class="line">Participating <span class="keyword">in</span> existing <span class="keyword">transaction</span> </span><br><span class="line">… </span><br><span class="line"><span class="keyword">SQL</span> <span class="keyword">update</span> affected <span class="number">1</span> <span class="keyword">rows</span> </span><br><span class="line"></span><br><span class="line">④此时数据源只打开了一个连接 </span><br><span class="line">[scoreUserService.addScore]激活连接数量：<span class="number">1</span> </span><br><span class="line"><span class="keyword">end</span> scoreService.addScore().. </span><br><span class="line">Initiating <span class="keyword">transaction</span> <span class="keyword">commit</span> </span><br><span class="line"></span><br><span class="line">⑤提交Hibernate的事务，它将触发一级缓存到数据库的同步 </span><br><span class="line">Committing Hibernate <span class="keyword">transaction</span> <span class="keyword">on</span> <span class="keyword">Session</span> [org.hibernate.impl.SessionImpl@c5f468] </span><br><span class="line"><span class="keyword">commit</span> </span><br><span class="line">processing <span class="keyword">flush</span>-<span class="keyword">time</span> cascades </span><br><span class="line">dirty checking collections </span><br><span class="line">Flushed: <span class="number">0</span> insertions, <span class="number">0</span> updates, <span class="number">0</span> deletions <span class="keyword">to</span> <span class="number">1</span> objects </span><br><span class="line">Flushed: <span class="number">0</span> (re)creations, <span class="number">0</span> updates, <span class="number">0</span> removals <span class="keyword">to</span> <span class="number">0</span> collections </span><br><span class="line">listing entities: </span><br><span class="line">com.baobaotao.<span class="keyword">User</span>&#123;lastLogonTime=<span class="number">1300937963882</span>, score=<span class="number">10</span>, userName=tom, <span class="keyword">password</span>=<span class="number">123456</span>&#125; </span><br><span class="line">re-enabling autocommit </span><br><span class="line"></span><br><span class="line">⑥提效<span class="keyword">Session</span>底层所绑定的JDBC <span class="keyword">Connection</span>所对应的事务 </span><br><span class="line">committed JDBC <span class="keyword">Connection</span> </span><br><span class="line"><span class="keyword">transaction</span> completed <span class="keyword">on</span> <span class="keyword">session</span> <span class="keyword">with</span> on_close <span class="keyword">connection</span> <span class="keyword">release</span> <span class="keyword">mode</span>;</span> be sure to close the session to <span class="operator"><span class="keyword">release</span> JDBC resources! </span><br><span class="line">Closing Hibernate <span class="keyword">Session</span> [org.hibernate.impl.SessionImpl@c5f468] <span class="keyword">after</span> <span class="keyword">transaction</span> </span><br><span class="line">Closing Hibernate <span class="keyword">Session</span> </span><br><span class="line">releasing JDBC <span class="keyword">connection</span> [ (<span class="keyword">open</span> PreparedStatements: <span class="number">0</span>, globally: <span class="number">0</span>) (<span class="keyword">open</span> ResultSets: <span class="number">0</span>, globally: <span class="number">0</span>)] </span><br><span class="line"><span class="keyword">transaction</span> completed <span class="keyword">on</span> <span class="keyword">session</span> <span class="keyword">with</span> on_close <span class="keyword">connection</span> <span class="keyword">release</span> <span class="keyword">mode</span>;</span> be sure to close the session to <span class="operator"><span class="keyword">release</span> JDBC resources! </span><br><span class="line"><span class="keyword">after</span> userService.logon()..</span></span><br></pre></td></tr></table></figure></p>
<p>仔细观察这段输出日志，<br>①处UserService#logon()开启一个新的事务。<br>②处的UserService# updateLastLogonTime()绑定到事务上下文的Session中。<br>③处ScoreService#addScore()方法加入到①处开启的事务上下文中。<br>④处的输出是ScoreService#addScore()方法内部的输出信息，汇报此时数据源激活的连接数为1，这清楚地告诉我们Hibernate和JDBC这两种数据访问技术在同一事务上下文中“共用”一个连接。<br>⑤处，提交Hibernate事务，接着在⑥处触发调用底层的Connection提交事务。 </p>
<p>从以上的运行结果，我们可以得出这样的结论：使用Hibernate事务管理器后，可以混合使用Hibernate和SpringJDBC数据访问技术，它们将工作于同一事务上下文中。但是使用SpringJDBC访问数据时，Hibernate的一级或二级缓存得不到同步，此外，一级缓存延迟数据同步机制可能会覆盖SpringJDBC数据更改的结果。 </p>
<p>   由于混合数据访问技术方案存在“事务同步而缓存不同步”的情况，所以最好用Hibernate进行读写操作，而只用Spring JDBC进行读操作。如用Spring JDBC进行简要列表的查询，而用Hibernate对查询出的数据进行维护。<br>   如果确实要同时使用Hibernate和SpringJDBC读写数据，则必须充分考虑到Hibernate缓存机制引发的问题：必须整体分析数据维护逻辑，根据需要及时调用Hibernate的flush()方法，以免覆盖Spring JDBC的更改，在Spring JDBC更改数据库时，维护Hibernate的缓存。由于方法调用顺序的不同都可能影响数据的同步性，因此很容易发生问题，这会极大提高数据访问程序的复杂性。所以笔者郑重建议不要同时使用Spring JDBC和Hibernate对数据进行写操作。 </p>
<blockquote>
<p>可以将以上结论推广到其他混合数据访问技术的方案中，如Hibernate+iBatis、JPA+Spring JDBC、JDO+Spring JDBC等。 </p>
</blockquote>
<p>参考资料：《Spring 3.x企业应用开发实战》</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>最近在梳理项目的时候对事务控制进行了梳理，深入了解了spring的事务，结合相关资料整理如下</p>
<hr>
<p>Spring抽象的DAO体系兼容多种数据访问技术，它们各有特色，各有千秋。像Hibernate是非常优秀的ORM实现方案，但对底层SQL的控制不太方便；而i]]>
    </summary>
    
      <category term="spring" scheme="http://donahue-ldz.github.io/tags/spring/"/>
    
      <category term="事务管理" scheme="http://donahue-ldz.github.io/tags/%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/"/>
    
      <category term="spring" scheme="http://donahue-ldz.github.io/categories/spring/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[redis持久化]]></title>
    <link href="http://donahue-ldz.github.io/2015/03/14/redis%E6%8C%81%E4%B9%85%E5%8C%96/"/>
    <id>http://donahue-ldz.github.io/2015/03/14/redis持久化/</id>
    <published>2015-03-14T12:14:23.000Z</published>
    <updated>2015-03-14T12:24:58.000Z</updated>
    <content type="html"><![CDATA[<h2 id="redis持久化">redis持久化</h2><p>redis提供了两种持久化的方式，分别是RDB（Redis DataBase）和AOF（Append Only File）。</p>
<blockquote>
<p>如果你没有数据持久化的需求，也完全可以关闭RDB和AOF方式，这样的话，redis将变成一个纯内存数据库，就像memcache一样。</p>
</blockquote>
<hr>
<h3 id="redis持久化_–_RDB">redis持久化 – RDB</h3><p>RDB方式，是将redis某一时刻的数据持久化到磁盘中，是一种快照式的持久化方法。</p>
<p>redis在进行数据持久化的过程中，会先将数据写入到一个临时文件中，待持久化过程都结束了，才会用这个临时文件替换上次持久化好的文件。正是这种特性，让我们可以随时来进行备份，因为快照文件总是完整可用的。</p>
<blockquote>
<p>对于RDB方式，redis会单独创建（fork）一个子进程来进行持久化，而主进程是不会进行任何IO操作的，这样就确保了redis极高的性能。</p>
</blockquote>
<p>如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那RDB方式要比AOF方式更加的高效。</p>
<p>虽然RDB有不少优点，但它的缺点也是不容忽视的。如果你对数据的完整性非常敏感，那么RDB方式就不太适合你，因为即使你每5分钟都持久化一次，当redis故障时，仍然会有近5分钟的数据丢失。所以，redis还提供了另一种持久化方式，那就是AOF。</p>
<hr>
<h3 id="redis持久化_–_AOF">redis持久化 – AOF</h3><p>AOF，英文是Append Only File，即只允许追加不允许改写的文件。</p>
<p>如前面介绍的，AOF方式是将执行过的写指令记录下来，在数据恢复时按照从前到后的顺序再将指令都执行一遍，就这么简单。</p>
<p>我们通过配置redis.conf中的appendonly yes就可以打开AOF功能。如果有写操作（如SET等），redis就会被追加到AOF文件的末尾。</p>
<blockquote>
<p>默认的AOF持久化策略是每秒钟fsync一次（fsync是指把缓存中的写指令记录到磁盘中），因为在这种情况下，redis仍然可以保持很好的处理性能，即使redis故障，也只会丢失最近1秒钟的数据。</p>
</blockquote>
<p>如果在追加日志时，恰好遇到磁盘空间满、inode满或断电等情况导致日志写入不完整，也没有关系，redis提供了<code>redis-check-aof</code>工具，可以用来进行日志修复。</p>
<p>因为采用了追加方式，如果不做任何处理的话，AOF文件会变得越来越大，为此，redis提供了AOF文件重写（rewrite）机制，即当AOF文件的大小超过所设定的阈值时，redis就会启动AOF文件的内容压缩，只保留可以恢复数据的最小指令集。举个例子或许更形象，假如我们调用了100次INCR指令，在AOF文件中就要存储100条指令，但这明显是很低效的，完全可以把这100条指令合并成一条SET指令，这就是重写机制的原理。</p>
<p>在进行AOF重写时，仍然是采用先写临时文件，全部完成后再替换的流程，所以断电、磁盘满等问题都不会影响AOF文件的可用性，这点大家可以放心。</p>
<p>AOF方式的另一个好处，我们通过一个“场景再现”来说明。某同学在操作redis时，不小心执行了FLUSHALL，导致redis内存中的数据全部被清空了，这是很悲剧的事情。不过这也不是世界末日，只要redis配置了AOF持久化方式，且AOF文件还没有被重写（rewrite），我们就可以用最快的速度暂停redis并编辑AOF文件，将最后一行的FLUSHALL命令删除，然后重启redis，就可以恢复redis的所有数据到FLUSHALL之前的状态了。是不是很神奇，这就是AOF持久化方式的好处之一。但是如果AOF文件已经被重写了，那就无法通过这种方法来恢复数据了。</p>
<p>虽然优点多多，但AOF方式也同样存在缺陷，比如在同样数据规模的情况下，AOF文件要比RDB文件的体积大。而且，AOF方式的恢复速度也要慢于RDB方式。</p>
<p>如果你直接执行BGREWRITEAOF命令，那么redis会生成一个全新的AOF文件，其中便包括了可以恢复现有数据的最少的命令集。</p>
<p>如果运气比较差，AOF文件出现了被写坏的情况，也不必过分担忧，redis并不会贸然加载这个有问题的AOF文件，而是报错退出。这时可以通过以下步骤来修复出错的文件：</p>
<blockquote>
<p>备份被写坏的AOF文件<br>运行redis-check-aof –fix进行修复<br>用diff -u来看下两个文件的差异，确认问题点<br>重启redis，加载修复后的AOF文件</p>
</blockquote>
<hr>
<h3 id="redis持久化_–_AOF重写">redis持久化 – AOF重写</h3><p>在重写即将开始之际，redis会创建（fork）一个“重写子进程”，这个子进程会首先读取现有的AOF文件，并将其包含的指令进行分析压缩并写入到一个临时文件中。</p>
<p>与此同时，主工作进程会将新接收到的写指令一边累积到内存缓冲区中，一边继续写入到原有的AOF文件中，这样做是保证原有的AOF文件的可用性，避免在重写过程中出现意外。</p>
<p>当“重写子进程”完成重写工作后，它会给父进程发一个信号，父进程收到信号后就会将内存中缓存的写指令追加到新AOF文件中。</p>
<p>当追加结束后，redis就会用新AOF文件来代替旧AOF文件，之后再有新的写指令，就都会追加到新的AOF文件中了。</p>
<hr>
<h3 id="如何选择RDB和AOF">如何选择RDB和AOF</h3><p>对于我们应该选择RDB还是AOF，官方的建议是两个同时使用。这样可以提供更可靠的持久化方案。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="redis持久化">redis持久化</h2><p>redis提供了两种持久化的方式，分别是RDB（Redis DataBase）和AOF（Append Only File）。</p>
<blockquote>
<p>如果你没有数据持久化的需求，也完全可以关闭RD]]>
    </summary>
    
      <category term="redis" scheme="http://donahue-ldz.github.io/tags/redis/"/>
    
      <category term="redis" scheme="http://donahue-ldz.github.io/categories/redis/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[lucene基础]]></title>
    <link href="http://donahue-ldz.github.io/2015/03/13/lucene%E5%9F%BA%E7%A1%80/"/>
    <id>http://donahue-ldz.github.io/2015/03/13/lucene基础/</id>
    <published>2015-03-13T12:29:02.000Z</published>
    <updated>2015-03-13T12:39:07.000Z</updated>
    <content type="html"><![CDATA[<h2 id="简介">简介</h2><p>Lucene 是一个基于 Java 的全文信息检索工具包，它不是一个完整的搜索应用程序，而是为你的应用程序提供索引和搜索功能。Lucene 目前是 Apache Jakarta 家族中的一个开源项目。也是目前最为流行的基于 Java 开源全文检索工具包。</p>
<p><img src="https://www.ibm.com/developerworks/cn/java/j-lo-lucene1/fig001.jpg" alt="lucene结构"></p>
<h2 id="索引和搜索">索引和搜索</h2><p>索引和搜索<br>索引是现代搜索引擎的核心，建立索引的过程就是把源数据处理成非常方便查询的索引文件的过程。为什么索引这么重要呢，试想你现在要在大量的文档中搜索含有某个关键词的文档，那么如果不建立索引的话你就需要把这些文档顺序的读入内存，然后检查这个文章中是不是含有要查找的关键词，这样的话就会耗费非常多的时间，想想搜索引擎可是在毫秒级的时间内查找出要搜索的结果的。这就是由于建立了索引的原因，你可以把索引想象成这样一种数据结构，他能够使你快速的随机访问存储在索引中的关键词，进而找到该关键词所关联的文档。Lucene采用的是一种称为<code>反向索引（inverted index）的机制</code>。反向索引就是说我们维护了一个词 / 短语表，对于这个表中的每个词 / 短语，都有一个链表描述了有哪些文档包含了这个词 / 短语。这样在用户输入查询条件的时候，就能非常快的得到搜索结果<br>对文档建立好索引后，就可以在这些索引上面进行搜索了。搜索引擎首先会对搜索的关键词进行解析，然后再在建立好的索引上面进行查找，最终返回和用户输入的关键词相关联的文档。</p>
<h2 id="建立索引">建立索引</h2><h3 id="Document">Document</h3><p>Document 是用来描述文档的，这里的文档可以指一个 HTML 页面，一封电子邮件，或者是一个文本文件。一个 Document 对象由多个 Field 对象组成的。可以把一个 Document 对象想象成数据库中的一个记录，而每个 Field 对象就是记录的一个字段。</p>
<h3 id="Field">Field</h3><p>Field 对象是用来描述一个文档的某个属性的，比如一封电子邮件的标题和内容可以用两个 Field 对象分别描述。</p>
<h3 id="Analyzer">Analyzer</h3><p>在一个文档被索引之前，首先需要对文档内容进行分词处理，这部分工作就是由 Analyzer 来做的。Analyzer类是一个抽象类，它有多个实现。针对不同的语言和应用需要选择适合的 Analyzer。Analyzer 把分词后的内容交给 IndexWriter来建立索引。</p>
<h3 id="IndexWriter">IndexWriter</h3><p>IndexWriter 是 Lucene 用来创建索引的一个核心的类，他的作用是把一个个的 Document 对象加到索引中来。<br><code>IndexWriter indexWriter = new IndexWriter(indexDir,luceneAnalyzer,true);</code></p>
<p>true表示新建，false表示原来的索引更新</p>
<h3 id="Directory">Directory</h3><p>这个类代表了 Lucene 的索引的存储的位置，这是一个抽象类，它目前有两个实现，第一个是 FSDirectory，它表示一个存储在文件系统中的索引的位置。第二个是 RAMDirectory，它表示一个存储在内存当中的索引的位置。</p>
<h2 id="搜索">搜索</h2><h3 id="Query">Query</h3><p>这是一个抽象类，他有多个实现，比如 TermQuery, BooleanQuery, PrefixQuery. 这个类的目的是把用户输入的查询字符串封装成 Lucene 能够识别的 Query。</p>
<h3 id="Term">Term</h3><p>Term 是搜索的基本单位，一个 Term 对象有两个 String 类型的域组成。生成一个 Term 对象可以有如下一条语句来完成：</p>
<p><code>Term term = new Term(“fieldName”,”queryWord”);</code></p>
<p>其中第一个参数代表了要在文档的哪一个Field上进行查找，第二个参数代表了要查询的关键词。</p>
<h3 id="TermQuery">TermQuery</h3><p>TermQuery 是抽象类 Query 的一个子类，它同时也是 Lucene 支持的最为基本的一个查询类。生成一个 TermQuery 对象由如下语句完成：</p>
<p><code>TermQuery termQuery = new TermQuery(new Term(“fieldName”,”queryWord”));</code></p>
<p>它的构造函数只接受一个参数，那就是一个 Term 对象。</p>
<h3 id="IndexSearcher">IndexSearcher</h3><p>IndexSearcher 是用来在建立好的索引上进行搜索的。它只能以只读的方式打开一个索引，所以可以有多个 IndexSearcher 的实例在一个索引上进行操作,如。<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">FSDirectory</span> directory = FSDirectory.getDirectory(indexDir,<span class="built_in">false</span>); </span><br><span class="line"><span class="title">IndexSearcher</span> searcher = new IndexSearcher(directory);</span><br></pre></td></tr></table></figure></p>
<h3 id="Hits">Hits</h3><p>Hits 是用来保存搜索的结果的。<code>hits.doc()</code>获得文档<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Hits hits = searcher.search(luceneQuery); </span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; hits.length(); i++)&#123; </span><br><span class="line">    Document <span class="built_in">document</span> = hits.doc(i); </span><br><span class="line">    System.out.println(<span class="built_in">document</span>.<span class="literal">get</span>(<span class="string">""</span>)); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="简介">简介</h2><p>Lucene 是一个基于 Java 的全文信息检索工具包，它不是一个完整的搜索应用程序，而是为你的应用程序提供索引和搜索功能。Lucene 目前是 Apache Jakarta 家族中的一个开源项目。也是目前最为流行的基于 Java 开]]>
    </summary>
    
      <category term="lucene，搜索" scheme="http://donahue-ldz.github.io/tags/lucene%EF%BC%8C%E6%90%9C%E7%B4%A2/"/>
    
      <category term="lucene" scheme="http://donahue-ldz.github.io/categories/lucene/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[java序列化]]></title>
    <link href="http://donahue-ldz.github.io/2015/03/13/java%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <id>http://donahue-ldz.github.io/2015/03/13/java序列化/</id>
    <published>2015-03-13T12:29:02.000Z</published>
    <updated>2015-04-01T08:18:58.000Z</updated>
    <content type="html"><![CDATA[<p>Java 提供了一种对象序列化的机制，该机制中，一个对象可以被表示为一个字节序列，该字节序列包括该对象的数据、有关对象的类型的信息和存储在对象中数据的类型。</p>
<p>将序列化对象写入文件之后，可以从文件中读取出来，并且对它进行反序列化，也就是说，对象的类型信息、对象的数据，还有对象中的数据类型可以用来在内存中新建对象。</p>
<p><span style="color: #ff00ff;">由于序列化都是由jvm实现 所以可以跨平台在不同的地点序列化</span></p>
<p>java的序列化有两种方法</p>
<h2 id="Serializable达到自动序列化">Serializable达到自动序列化</h2><p>记住有些东西是不能或者不方便实例话的（密码，银行卡等敏感信息），此时要是自动序列化的话将是不安全的表现，但是java提供了一个关键字transient，<code>`被transient修饰的变量将不会被序列话，也就不能被反序列化</code>。</p>
<p><code>被static修饰的变量也不会被序列化</code>，但是反序列化时候，如果当前内存中存在静态变量的值的时候，反序列化的时候被修饰的类成员将还是会看见值，此时的值就是现在内存中的值</p>
<hr>
<h2 id="Externalizable手动序列化">Externalizable手动序列化</h2><p>在里面重写相关的方法实现自定义序列化，此时不管是否被transient修饰都使可以哦～～～</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeExternal</span><span class="params">(ObjectOutput <span class="keyword">out</span>)</span> throws IOException </span>&#123;</span><br><span class="line">        <span class="keyword">out</span>.writeObject(content);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @<span class="function">Override</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readExternal</span><span class="params">(ObjectInput <span class="keyword">in</span>)</span> throws IOException,</span><br><span class="line">            ClassNotFoundException </span>&#123;</span><br><span class="line">        content = (String) <span class="keyword">in</span>.readObject();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>本文只是介绍jdk自带的序列化，还有更多更好的序列化方法将比jdk带的更加方便和效率高</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Java 提供了一种对象序列化的机制，该机制中，一个对象可以被表示为一个字节序列，该字节序列包括该对象的数据、有关对象的类型的信息和存储在对象中数据的类型。</p>
<p>将序列化对象写入文件之后，可以从文件中读取出来，并且对它进行反序列化，也就是说，对象的类型信息、对象的]]>
    </summary>
    
      <category term="序列化" scheme="http://donahue-ldz.github.io/tags/%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    
      <category term="java" scheme="http://donahue-ldz.github.io/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[lucene开篇]]></title>
    <link href="http://donahue-ldz.github.io/2015/03/13/lucene%E5%BC%80%E7%AF%87/"/>
    <id>http://donahue-ldz.github.io/2015/03/13/lucene开篇/</id>
    <published>2015-03-13T12:17:24.000Z</published>
    <updated>2015-03-13T12:20:08.000Z</updated>
    <content type="html"><![CDATA[<p>最近由于项目中有用lucene，由于之前时间一直很忙，所以没有将相关的技术整理出来，今天决定将项目中的lucene整理，对lucene进行整体的学习和研究，会将项目中的部分源码分享目的为了便于分析！<br>渐渐的发现很多技术由于长时间没有再次接触很快就能忘记，汗～<br>反思：再忙也不能忘记更新博客，笨～</p>
<hr>
<p><code>go ~ ~ ~ ~ ~ ~</code></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>最近由于项目中有用lucene，由于之前时间一直很忙，所以没有将相关的技术整理出来，今天决定将项目中的lucene整理，对lucene进行整体的学习和研究，会将项目中的部分源码分享目的为了便于分析！<br>渐渐的发现很多技术由于长时间没有再次接触很快就能忘记，汗～<br>反]]>
    </summary>
    
      <category term="lucene" scheme="http://donahue-ldz.github.io/categories/lucene/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[MarkDown语法入门]]></title>
    <link href="http://donahue-ldz.github.io/2015/02/15/MarkDown%E8%AF%AD%E6%B3%95%E5%85%A5%E9%97%A8/"/>
    <id>http://donahue-ldz.github.io/2015/02/15/MarkDown语法入门/</id>
    <published>2015-02-15T02:32:21.000Z</published>
    <updated>2015-03-07T05:15:56.000Z</updated>
    <content type="html"><![CDATA[<h2 id="MarkDown_理念">MarkDown 理念</h2><blockquote>
<p>让文档更容易读、写和随意改。HTML 是一种发布的格式，Markdown 是一种书写的格式。就这样，Markdown 的格式语法只涵盖纯文本可以涵盖的范围.</p>
</blockquote>
<hr>
<h2 id="注意">注意</h2><blockquote>
<p>不在 Markdown 涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写。不需要额外标注这是 HTML 或是 Markdown；只要直接加标签就可以了。<br>要制约的只有一些 HTML 区块元素――比如 <code>&lt;div&gt;、&lt;table&gt;、&lt;pre&gt;、&lt;p&gt;</code>等标签，必须在 <strong>前后</strong> 加上 <strong>空行</strong> 与其它内容区隔开，还要求它们的开始标签与结尾标签不能用制表符或空格来缩进。Markdown 的生成器有足够智能，不会在 HTML 区块标签外加上不必要的 <code>&lt;p&gt;</code> 标签。</p>
</blockquote>
<hr>
<h1 id="常见的使用">常见的使用</h1><h3 id="标题">标题</h3><p>Markdown 支持两种标题的语法，类 Setext 和类 atx 形式。</p>
<blockquote>
<ol>
<li>类 Setext 形式是用底线的形式(在需要成为标题的文字下方加入…)，利用 = （最高阶标题）和 - （第二阶标题)</li>
<li>类 Atx 形式则是在行首插入 1 到 6 个 # ，对应到标题 1 到 6 阶</li>
</ol>
</blockquote>
<p><strong><em>你可以选择性地「闭合」类 atx 样式的标题，这纯粹只是美观用的若是觉得这样看起来比较舒适，你就可以在行尾加上<br>而行尾的 # 数量也不用和开头一样（行首的井字符数量决定标题的阶数）</em></strong></p>
<hr>
<h3 id="区块引用_Blockquotes">区块引用 Blockquotes</h3><ul>
<li>Markdown 标记区块引用是使用类似 email 中用 &gt; 的引用方式。</li>
<li>Markdown 也允许你偷懒只在整个段落的第一行最前面加上 &gt; </li>
<li>区块引用可以嵌套（例如：引用内的引用），只要根据层次加上不同数量的 &gt; </li>
<li>引用的区块内也可以使用其他的 Markdown 语法，包括标题、列表、代码区块等</li>
</ul>
<hr>
<h3 id="列表">列表</h3><p>Markdown 支持有序列表和无序列表。</p>
<ul>
<li>无序列表使用星号、加号或是减号作为列表标记 : <code>*+空格</code></li>
<li>有序列表则使用数字接着一个英文句点：<code>数字+句点+空格</code>  <strong>可以完全不在意数字的正确和顺序</strong></li>
<li>列表项目可以包含多个段落，每个项目下的段落都必须缩进 4 个空格或是 1 个制表符</li>
<li>如果要在列表项目内放进引用，那 &gt; 就需要缩进</li>
<li><code>如果要放代码区块的话，该区块就需要缩进两次，也就是 8 个空格或是 2 个制表符</code></li>
<li>在行首出现数字-句点-空白，要避免这样的状况，你可以在句点前面加上反斜杠     </li>
</ul>
<hr>
<h3 id="代码区块">代码区块</h3><p>Markdown 会用<code>&lt;pre&gt;</code> 和 <code>&lt;code&gt;</code> 标签来把代码区块包起来.<br>要在 Markdown 中建立代码区块很简单，只要简单地缩进 4 个空格或是 1 个制表符就可以(<strong>中间需要一行空行隔开</strong>)，一个代码区块会一直持续到没有缩进的那一行（或是文件结尾）。例如，下面的输入：</p>
<p>这是一个普通段落：</p>
<pre><code><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[]args)
</code></pre><ul>
<li>在代码区块里面， &amp; 、 &lt; 和 &gt; 会自动转成 HTML 实体，这样的方式让你非常容易使用 Markdown 插入范例用的 HTML 原始码，只需要复制贴上，再加上缩进就可以了，剩下的 Markdown 都会帮你处理</li>
<li>代码区块中，一般的 Markdown 语法不会被转换，像是星号便只是星号，这表示你可以很容易地以 Markdown 语法撰写 Markdown 语法相关的文件</li>
</ul>
<hr>
<h3 id="分割线">分割线</h3><p>你可以在一行中用三个以上的<code>星号、减号、底线</code>来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线.</p>
<hr>
<h3 id="链接">链接</h3><p>Markdown 支持两种形式的链接语法： 行内式和参考式两种形式。</p>
<p>不管是哪一种，链接文字都是用 [方括号] 来标记。</p>
<ul>
<li>要建立一个行内式的链接，只要在方块括号后面紧接着圆括号并插入网址链接即可，如果你还想要加上链接的 title 文字，只要在网址后面，用双引号把 title 文字包起来即可，例如：<blockquote>
<p><code>This is [an example](http://example.com/ &quot;Title&quot;) inline link.</code><br><code>[This link](http://example.net/) has no title attribute.</code></p>
</blockquote>
</li>
</ul>
<p><code>如果你是要链接到同样主机的资源，你可以使用相对路径：See my [About](/about/) page for details.</code></p>
<ul>
<li>参考式的链接是在链接文字的括号后面再接上另一个方括号，而在第二个方括号里面要填入用以辨识链接的标记：<blockquote>
<p><code>This is [an example] [id] reference-style link</code>.<br>你也可以选择性地在两个方括号中间加上一个空格：<br><code>This is [an example] [id] reference-style link</code>.<br>接着，在文件的任意处，你可以把这个标记的链接内容定义出来：</p>
</blockquote>
</li>
</ul>
<p><code>[id]: http://example.com/  &quot;Optional Title Here&quot;</code> </p>
<h3 id="强调">强调</h3><p>Markdown 使用星号（<em>）和底线（_）作为标记强调字词的符号，被 </em> 或 <em> 包围的字词会被转成用 <code>&lt;em&gt;</code> 标签包围，用两个 * 或 </em> 包起来的话，则会被转成 <code>&lt;strong&gt;</code></p>
<h3 id="代码">代码</h3><ul>
<li>如果要标记一小段行内代码，你可以用反引号把它包起来（`）</li>
<li>如果要在代码区段内插入反引号，你可以用多个反引号来开启和结束代码区段：</li>
</ul>
<h3 id="图片">图片</h3><p>markdown 使用一种和链接很相似的语法来标记图片，同样也允许两种样式： 行内式和参考式。<br>行内式的图片语法看起来像是：</p>
<p><code>![Alt text](/path/to/img.jpg)</code></p>
<p><code>![Alt text](/path/to/img.jpg &quot;Optional title&quot;)</code><br>详细叙述如下：</p>
<p>一个惊叹号 !<br>接着一个方括号，里面放上图片的替代文字<br>接着一个普通括号，里面放上图片的网址，最后还可以用引号包住并加上 选择性的 ‘title’ 文字。<br>参考式的图片语法则长得像这样：</p>
<p><code>![Alt text][id]</code><br>「id」是图片参考的名称，图片参考的定义方式则和连结参考一样：</p>
<p><code>[id]: url/to/image  &quot;Optional title attribute&quot;</code><br>到目前为止， Markdown 还没有办法指定图片的宽高，如果你需要的话，你可以使用普通的 <code>&lt;img&gt;</code> 标签。</p>
<hr>
<h3 id="自动链接">自动链接</h3><blockquote>
<p>Markdown 支持以比较简短的自动链接形式来处理网址和电子邮件信箱，只要是用尖括号包起来， Markdown 就会自动把它转成链接。一般网址的链接文字就和链接地址一样，例如：<br><code>&lt;http://example.com/&gt;</code><br>Markdown 会转为：<br><code>&lt;a href=&quot;http://example.com/&quot;&gt;http://example.com/&lt;/a&gt;</code><br>邮址的自动链接也很类似，只是 Markdown 会先做一个编码转换的过程，把文字字符转成 16 进位码的 HTML 实体，这样的格式可以糊弄一些不好的邮址收集机器人<br><code>&lt;address@example.com&gt;</code></p>
</blockquote>
<hr>
<h3 id="反斜杠">反斜杠</h3><p><strong>也就是程序员所熟悉的转义符号</strong></p>
<hr>
<p><a href="http://wowubuntu.com/markdown/" target="_blank" rel="external">参考资料</a><a href="http://wowubuntu.com/markdown/" target="_blank" rel="external">http://wowubuntu.com/markdown/</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="MarkDown_理念">MarkDown 理念</h2><blockquote>
<p>让文档更容易读、写和随意改。HTML 是一种发布的格式，Markdown 是一种书写的格式。就这样，Markdown 的格式语法只涵盖纯文本可以涵盖的范围.</p>
</bl]]>
    </summary>
    
      <category term="MarkDown" scheme="http://donahue-ldz.github.io/tags/MarkDown/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[log4j常见日志级别的选用]]></title>
    <link href="http://donahue-ldz.github.io/2015/01/17/log4j%E5%B8%B8%E8%A7%81%E6%97%A5%E5%BF%97%E7%BA%A7%E5%88%AB%E7%9A%84%E9%80%89%E7%94%A8/"/>
    <id>http://donahue-ldz.github.io/2015/01/17/log4j常见日志级别的选用/</id>
    <published>2015-01-17T05:24:44.000Z</published>
    <updated>2015-03-15T05:30:12.000Z</updated>
    <content type="html"><![CDATA[<h2 id="RootLogger">RootLogger</h2><p><code>log4j.rootLogger = [ level ] , appenderName1, appenderName2,...</code><br><code>log4j.additivity.org.apache=false</code>表示Logger不会在父Logger的appender里输出，默认为true。<br>level ：设定日志记录的最低级别，可设的值有:<br><code>OFF、FATAL、ERROR、WARN、INFO、DEBUG、ALL</code>或者自定义的级别，Log4j建议只使用中间四个级别。<strong>通过在这里设定级别</strong>，您可以控制应用程序中相应级别的日志信息的开关，比如在这里设定了INFO级别，则应用程序中所有DEBUG级别的日志信息将不会被打印出来。<br>appenderName：就是指定日志信息要输出到哪里。可以同时指定多个输出目的地，用逗号隔开。<br>具体详见：<a href="http://donahue-ldz.github.io/2015/01/05/%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95/" target="_blank" rel="external">日志记录</a></p>
<hr>
<blockquote>
<p>这里主要针对什么时候选择相关的打印级别帮助系统能很好运行做简单介绍</p>
</blockquote>
<hr>
<h2 id="日志级别">日志级别</h2><h3 id="ERROR">ERROR</h3><p>系统发生了严重的错误, 必须马上进行处理, 否则系统将无法继续运行. 比如数据库不可用等</p>
<h3 id="WARN">WARN</h3><p>系统能继续运行, 但是必须引起关注. 对于存在的问题一般可以分为两类: 一种系统存在明显的问题(比如, 数据不可用),另一种就是系统存在潜在的问题, 需要引起注意或者给出一些建议(比如,系统运行在安全模式或者访问当前系统的账号存在安全隐患). 总之就是系统仍然可用, 但是最好进行检查和调整。</p>
<h3 id="INFO">INFO</h3><p>重要的业务逻辑处理完成。在理想情况下,INFO的日志信息要能让高级用户和系统管理员理解, 并从日志信息中能知道系统当前的运行状态。理解系统的运行状态和流程…</p>
<h3 id="DEBUG">DEBUG</h3><p>主要用于调试、测试时使用，一般是在程序中不是非常重要的地方,这部分的日志较多，但是在线上运行时我们一般会将日志级别设置为INFO，避免DEBUG日志过多影响性。</p>
<h3 id="TRACE">TRACE</h3><p>系统详细信息, 主要给开发人员用,一般来说,如果是线上系统的话,可以认为是临时输出, 而且随时可以通过开关将其关闭.有时候我们很难将DEBUG和TRACE区分开, 一般情况下, 如果是一个已经开发测试完成的系统,再往系统中添加日志输出, 那么应该设为TRACE级别。</p>
<h2 id="日志的好处">日志的好处</h2><p>帮助分析了解系统运行</p>
<h2 id="日志缺点">日志缺点</h2><p>打印日志将会降低程序的性能和响应，尤其是在高并发等实时相应的系统中</p>
<h2 id="日志输出原则">日志输出原则</h2><p>Log4j建议只使用四个级别，优先级从高到低分别是 ERROR、WARN、INFO、DEBUG。通过在这里定义的级别，您可以控制到应用程序中相应级别的日志信息的开关。</p>
<ul>
<li>对程序的输入输出要以DEBUG记录下来，常包括从文件、数据库、网络、用户等输入的信息，向文件、数据库、网络输出的信息。</li>
<li>对重要对象或程序状态的修改，要以INFO记录修改前的信息和修改后的状态。</li>
<li>不能忽视每个调用错误，异常日志的内容要能清晰描述运行上下文，这样有助于排查错误，输出异常日志时，第一个参数一定是一个字符串,一般都是对问题的描述信息, 而不能是异常message(因为堆栈里面会有),第二个参数才是具体的异常实例. 例如：log.error(“导入数据失败，错误信息为：”, e) 。</li>
<li>记下打印信息时所在的文件名和函数名（必须能区分开重载函数）,有行数最好。</li>
<li>对于高并发系统，能不打印日志就不打印日志，输出的日志数量、级别、内容都要经过评估，避免日志输出影响性能,可以采用初期上线时多打印一些日志，上线运行一段时间后，通过观察方法调用次数，响应性能来决定减少那些日志的打印或者改变打印日志的级别。</li>
<li>对于异常日志的内容要能清晰描述运行上下文，这样有助于排查错误。 </li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="RootLogger">RootLogger</h2><p><code>log4j.rootLogger = [ level ] , appenderName1, appenderName2,...</code><br><code>log4j.additivity]]>
    </summary>
    
      <category term="log4j" scheme="http://donahue-ldz.github.io/tags/log4j/"/>
    
      <category term="日志" scheme="http://donahue-ldz.github.io/tags/%E6%97%A5%E5%BF%97/"/>
    
      <category term="log" scheme="http://donahue-ldz.github.io/categories/log/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[log4j常见配置]]></title>
    <link href="http://donahue-ldz.github.io/2015/01/15/log4j%E5%B8%B8%E8%A7%81%E9%85%8D%E7%BD%AE/"/>
    <id>http://donahue-ldz.github.io/2015/01/15/log4j常见配置/</id>
    <published>2015-01-15T07:27:41.000Z</published>
    <updated>2015-03-15T05:30:18.000Z</updated>
    <content type="html"><![CDATA[<h2 id="xml类型的配置">xml类型的配置</h2><p>Log4j配置文件实现了输出到控制台、文件、固定大小文件、发送日志邮件、输出到数据库日志表、自定义标签等全套功能。 </p>
<pre><code><span class="pi">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span>  
<span class="doctype">&lt;!DOCTYPE log4j:configuration SYSTEM "log4j.dtd"&gt;</span>  

<span class="tag">&lt;<span class="title">log4j:configuration</span>&gt;</span>  

 <span class="comment">&lt;!--自定义输出到控制台--&gt;</span>
 <span class="tag">&lt;<span class="title">appender</span> <span class="attribute">name</span>=<span class="value">"CONSOLE"</span> <span class="attribute">class</span>=<span class="value">"org.apache.log4j.ConsoleAppender"</span>&gt;</span>
  <span class="tag">&lt;<span class="title">layout</span> <span class="attribute">class</span>=<span class="value">"org.apache.log4j.PatternLayout"</span>&gt;</span>  
   <span class="tag">&lt;<span class="title">param</span> <span class="attribute">name</span>=<span class="value">"ConversionPattern"</span>  
    <span class="attribute">value</span>=<span class="value">"%d - %c -%-4r [%t] %-5p %x - %m%n"</span> /&gt;</span>  
  <span class="tag">&lt;/<span class="title">layout</span>&gt;</span>  

  <span class="comment">&lt;!--限制输出级别--&gt;</span>  
  <span class="tag">&lt;<span class="title">filter</span> <span class="attribute">class</span>=<span class="value">"org.apache.log4j.varia.LevelRangeFilter"</span>&gt;</span>  
   <span class="tag">&lt;<span class="title">param</span> <span class="attribute">name</span>=<span class="value">"LevelMax"</span> <span class="attribute">value</span>=<span class="value">"ERROR"</span>/&gt;</span>  
   <span class="tag">&lt;<span class="title">param</span> <span class="attribute">name</span>=<span class="value">"LevelMin"</span> <span class="attribute">value</span>=<span class="value">"TRACE"</span>/&gt;</span>  
  <span class="tag">&lt;/<span class="title">filter</span>&gt;</span>  
 <span class="tag">&lt;/<span class="title">appender</span>&gt;</span>  

 <span class="comment">&lt;!--输出到文件--&gt;</span>
 <span class="tag">&lt;<span class="title">appender</span> <span class="attribute">name</span>=<span class="value">"FILE"</span> <span class="attribute">class</span>=<span class="value">"org.apache.log4j.FileAppender"</span>&gt;</span>  
  <span class="tag">&lt;<span class="title">param</span> <span class="attribute">name</span>=<span class="value">"File"</span> <span class="attribute">value</span>=<span class="value">"log4j.log"</span>/&gt;</span>  
  <span class="tag">&lt;<span class="title">layout</span> <span class="attribute">class</span>=<span class="value">"org.apache.log4j.PatternLayout"</span>&gt;</span>  
   <span class="tag">&lt;<span class="title">param</span> <span class="attribute">name</span>=<span class="value">"ConversionPattern"</span>  
    <span class="attribute">value</span>=<span class="value">"%d - %c -%-4r [%t] %-5p %x - %m%n"</span> /&gt;</span>  
  <span class="tag">&lt;/<span class="title">layout</span>&gt;</span>  
 <span class="tag">&lt;/<span class="title">appender</span>&gt;</span>    

 <span class="comment">&lt;!--输出到数据库--&gt;</span>
 <span class="tag">&lt;<span class="title">appender</span> <span class="attribute">name</span>=<span class="value">"DATABASE"</span> <span class="attribute">class</span>=<span class="value">"org.apache.log4j.jdbc.JDBCAppender"</span>&gt;</span>  
  <span class="tag">&lt;<span class="title">param</span> <span class="attribute">name</span>=<span class="value">"URL"</span> <span class="attribute">value</span>=<span class="value">"jdbc:oracle:thin:@192.168.0.59:1521:oanet"</span>/&gt;</span>  
  <span class="tag">&lt;<span class="title">param</span> <span class="attribute">name</span>=<span class="value">"driver"</span> <span class="attribute">value</span>=<span class="value">"oracle.jdbc.driver.OracleDriver"</span>/&gt;</span>  
  <span class="tag">&lt;<span class="title">param</span> <span class="attribute">name</span>=<span class="value">"user"</span> <span class="attribute">value</span>=<span class="value">"user"</span>/&gt;</span>  
  <span class="tag">&lt;<span class="title">param</span> <span class="attribute">name</span>=<span class="value">"password"</span> <span class="attribute">value</span>=<span class="value">"password"</span>/&gt;</span>      
  <span class="tag">&lt;<span class="title">layout</span> <span class="attribute">class</span>=<span class="value">"org.apache.log4j.PatternLayout"</span>&gt;</span>  
   <span class="tag">&lt;<span class="title">param</span> <span class="attribute">name</span>=<span class="value">"ConversionPattern"</span> 
   <span class="attribute">value</span>=<span class="value">"INSERT INTO hdczoa.LOG4J(stamp,thread,info_level,class,message) VALUES ('%d', '%t', '%p', '%c', %m)"</span> /&gt;</span>  
  <span class="tag">&lt;/<span class="title">layout</span>&gt;</span>  
 <span class="tag">&lt;/<span class="title">appender</span>&gt;</span>  

 <span class="comment">&lt;!-- 发邮件（只有ERROR时才会发送！） --&gt;</span>  
 <span class="tag">&lt;<span class="title">appender</span> <span class="attribute">name</span>=<span class="value">"MAIL"</span>  <span class="attribute">class</span>=<span class="value">"org.apache.log4j.net.SMTPAppender"</span>&gt;</span>  
  <span class="tag">&lt;<span class="title">param</span> <span class="attribute">name</span>=<span class="value">"threshold"</span> <span class="attribute">value</span>=<span class="value">"debug"</span> /&gt;</span>  
  <span class="comment">&lt;!-- 日志的错误级别  
   &lt;param name="threshold" value="fatal"/&gt;  
  --&gt;</span>  
  <span class="comment">&lt;!-- 缓存文件大小，日志达到512K时发送Email --&gt;</span>  
  <span class="tag">&lt;<span class="title">param</span> <span class="attribute">name</span>=<span class="value">"BufferSize"</span> <span class="attribute">value</span>=<span class="value">"512"</span> /&gt;</span><span class="comment">&lt;!-- 单位K --&gt;</span>  
  <span class="tag">&lt;<span class="title">param</span> <span class="attribute">name</span>=<span class="value">"From"</span> <span class="attribute">value</span>=<span class="value">"test@163.com"</span> /&gt;</span>  
  <span class="tag">&lt;<span class="title">param</span> <span class="attribute">name</span>=<span class="value">"SMTPHost"</span> <span class="attribute">value</span>=<span class="value">"smtp.163.com"</span> /&gt;</span>  
  <span class="tag">&lt;<span class="title">param</span> <span class="attribute">name</span>=<span class="value">"Subject"</span> <span class="attribute">value</span>=<span class="value">"juyee-log4jMessage"</span> /&gt;</span>  
  <span class="comment">&lt;!--收件人--&gt;</span>
  <span class="tag">&lt;<span class="title">param</span> <span class="attribute">name</span>=<span class="value">"To"</span> <span class="attribute">value</span>=<span class="value">"reciever@163.com"</span> /&gt;</span>
  <span class="comment">&lt;!--发件人登陆邮箱服务器--&gt;</span>
  <span class="tag">&lt;<span class="title">param</span> <span class="attribute">name</span>=<span class="value">"SMTPUsername"</span> <span class="attribute">value</span>=<span class="value">"user"</span> /&gt;</span>  
  <span class="tag">&lt;<span class="title">param</span> <span class="attribute">name</span>=<span class="value">"SMTPPassword"</span> <span class="attribute">value</span>=<span class="value">"password"</span> /&gt;</span>  
  <span class="tag">&lt;<span class="title">layout</span> <span class="attribute">class</span>=<span class="value">"org.apache.log4j.PatternLayout"</span>&gt;</span>  
   <span class="tag">&lt;<span class="title">param</span> <span class="attribute">name</span>=<span class="value">"ConversionPattern"</span>  
    <span class="attribute">value</span>=<span class="value">"%-d{yyyy-MM-dd HH:mm:ss.SSS} [%p]-[%c] %m%n"</span> /&gt;</span>  
  <span class="tag">&lt;/<span class="title">layout</span>&gt;</span>  
 <span class="tag">&lt;/<span class="title">appender</span>&gt;</span>  

 <span class="tag">&lt;<span class="title">appender</span> <span class="attribute">name</span>=<span class="value">"ASYNC"</span> <span class="attribute">class</span>=<span class="value">"org.apache.log4j.AsyncAppender"</span>&gt;</span>  
  <span class="tag">&lt;<span class="title">param</span> <span class="attribute">name</span>=<span class="value">"BufferSize"</span> <span class="attribute">value</span>=<span class="value">"256"</span> /&gt;</span>  
  <span class="tag">&lt;<span class="title">appender-ref</span> <span class="attribute">ref</span>=<span class="value">"DATABASE"</span> /&gt;</span>  
 <span class="tag">&lt;/<span class="title">appender</span>&gt;</span>  

 <span class="comment">&lt;!--通过&lt;logger&gt;&lt;/logger&gt;的定义可以将各个包中的类日志输出到不同的日志文件中--&gt;</span>  
 <span class="tag">&lt;<span class="title">logger</span> <span class="attribute">name</span>=<span class="value">"packageName"</span> <span class="attribute">additivity</span>=<span class="value">"false"</span>&gt;</span>     
        <span class="tag">&lt;<span class="title">level</span> <span class="attribute">value</span>=<span class="value">"WARN"</span> /&gt;</span>     
        <span class="tag">&lt;<span class="title">appender-ref</span> <span class="attribute">ref</span>=<span class="value">"CONSOLE"</span> /&gt;</span>     
    <span class="tag">&lt;/<span class="title">logger</span>&gt;</span>  

 <span class="comment">&lt;!--通过&lt;category&gt;&lt;/category&gt;的定义可以将各个包中的类日志输出到不同的日志文件中--&gt;</span>  
 <span class="tag">&lt;<span class="title">category</span> <span class="attribute">name</span>=<span class="value">"com.litt3"</span>&gt;</span>     
    <span class="tag">&lt;<span class="title">level</span> <span class="attribute">value</span>=<span class="value">"DEBUG"</span> /&gt;</span>   
       <span class="tag">&lt;<span class="title">appender-ref</span> <span class="attribute">ref</span>=<span class="value">"CONSOLE"</span> /&gt;</span>  
       <span class="tag">&lt;<span class="title">appender-ref</span> <span class="attribute">ref</span>=<span class="value">"MAIL"</span> /&gt;</span>  
  <span class="tag">&lt;/<span class="title">category</span>&gt;</span>  

 <span class="tag">&lt;<span class="title">root</span>&gt;</span>  
  <span class="tag">&lt;<span class="title">priority</span> <span class="attribute">value</span>=<span class="value">"debug"</span> /&gt;</span>  
  <span class="tag">&lt;<span class="title">appender-ref</span> <span class="attribute">ref</span>=<span class="value">"CONSOLE"</span> /&gt;</span>  
  <span class="tag">&lt;<span class="title">appender-ref</span> <span class="attribute">ref</span>=<span class="value">"FILE"</span> /&gt;</span>  
 <span class="tag">&lt;/<span class="title">root</span>&gt;</span>  


<span class="tag">&lt;/<span class="title">log4j:configuration</span>&gt;</span>  
</code></pre><hr>
<h2 id="属性文件配置">属性文件配置</h2><p>Log4j配置文件实现了输出到控制台、文件、固定大小文件、发送日志邮件、输出到数据库日志表、自定义标签等全套功能。 </p>
<pre><code>log4j.rootLogger=DEBUG,console,dailyFile,im 
log4j<span class="class">.additivity</span><span class="class">.org</span><span class="class">.apache</span>=true 
</code></pre><h3 id="控制台(console)">控制台(console)</h3><pre><code>log4j<span class="class">.appender</span><span class="class">.console</span>=org<span class="class">.apache</span><span class="class">.log4j</span><span class="class">.ConsoleAppender</span> 
log4j<span class="class">.appender</span><span class="class">.console</span><span class="class">.Threshold</span>=DEBUG 
log4j<span class="class">.appender</span><span class="class">.console</span><span class="class">.ImmediateFlush</span>=true 
log4j<span class="class">.appender</span><span class="class">.console</span><span class="class">.Target</span>=System<span class="class">.err</span> 
log4j<span class="class">.appender</span><span class="class">.console</span><span class="class">.layout</span>=org<span class="class">.apache</span><span class="class">.log4j</span><span class="class">.PatternLayout</span> 
log4j<span class="class">.appender</span><span class="class">.console</span><span class="class">.layout</span><span class="class">.ConversionPattern</span>=[%-<span class="number">5</span>p] %<span class="function"><span class="title">d</span><span class="params">(%r)</span></span> --&gt; [%t] %l: %m %x %n 
</code></pre><h3 id="日志文件(logFile)">日志文件(logFile)</h3><pre><code>log4j<span class="class">.appender</span><span class="class">.logFile</span>=org<span class="class">.apache</span><span class="class">.log4j</span><span class="class">.FileAppender</span> 
log4j<span class="class">.appender</span><span class="class">.logFile</span><span class="class">.Threshold</span>=DEBUG 
log4j<span class="class">.appender</span><span class="class">.logFile</span><span class="class">.ImmediateFlush</span>=true 
log4j<span class="class">.appender</span><span class="class">.logFile</span><span class="class">.Append</span>=true 
log4j<span class="class">.appender</span><span class="class">.logFile</span><span class="class">.File</span>=log<span class="class">.log4j</span> 
log4j<span class="class">.appender</span><span class="class">.logFile</span><span class="class">.layout</span>=org<span class="class">.apache</span><span class="class">.log4j</span><span class="class">.PatternLayout</span> 
log4j<span class="class">.appender</span><span class="class">.logFile</span><span class="class">.layout</span><span class="class">.ConversionPattern</span>=[%-<span class="number">5</span>p] %<span class="function"><span class="title">d</span><span class="params">(%r)</span></span> --&gt; [%t] %l: %m %x %n 
</code></pre><h3 id="指定大小文件(rollingFile)">指定大小文件(rollingFile)</h3><p><code>文件大小到达指定尺寸的时候产生一个新的文件</code></p>
<pre><code>log4j<span class="class">.appender</span><span class="class">.rollingFile</span>=org<span class="class">.apache</span><span class="class">.log4j</span><span class="class">.RollingFileAppender</span> 
log4j<span class="class">.appender</span><span class="class">.rollingFile</span><span class="class">.Threshold</span>=DEBUG 
log4j<span class="class">.appender</span><span class="class">.rollingFile</span><span class="class">.ImmediateFlush</span>=true 
log4j<span class="class">.appender</span><span class="class">.rollingFile</span><span class="class">.Append</span>=true 
log4j<span class="class">.appender</span><span class="class">.rollingFile</span><span class="class">.File</span>=log<span class="class">.log4j</span> 
#文件达到多大开始重新开始记录新文件
log4j<span class="class">.appender</span><span class="class">.rollingFile</span><span class="class">.MaxFileSize</span>=<span class="number">200</span>KB 
log4j<span class="class">.appender</span><span class="class">.rollingFile</span><span class="class">.MaxBackupIndex</span>=<span class="number">50</span> 
log4j<span class="class">.appender</span><span class="class">.rollingFile</span><span class="class">.layout</span>=org<span class="class">.apache</span><span class="class">.log4j</span><span class="class">.PatternLayout</span> 
log4j<span class="class">.appender</span><span class="class">.rollingFile</span><span class="class">.layout</span><span class="class">.ConversionPattern</span>=[%-<span class="number">5</span>p] %<span class="function"><span class="title">d</span><span class="params">(%r)</span></span> --&gt; [%t] %l: %m %x %n 
</code></pre><h3 id="每天产生一个文件(dailyFile)">每天产生一个文件(dailyFile)</h3><pre><code>log4j<span class="class">.appender</span><span class="class">.dailyFile</span>=org<span class="class">.apache</span><span class="class">.log4j</span><span class="class">.DailyRollingFileAppender</span> 
log4j<span class="class">.appender</span><span class="class">.dailyFile</span><span class="class">.Threshold</span>=DEBUG 
log4j<span class="class">.appender</span><span class="class">.dailyFile</span><span class="class">.ImmediateFlush</span>=true 
log4j<span class="class">.appender</span><span class="class">.dailyFile</span><span class="class">.Append</span>=true 
log4j<span class="class">.appender</span><span class="class">.dailyFile</span><span class="class">.File</span>=log<span class="class">.log4j</span> 
log4j<span class="class">.appender</span><span class="class">.dailyFile</span><span class="class">.DatePattern</span>=<span class="string">'.'</span>yyyy-MM-<span class="tag">dd</span> 
log4j<span class="class">.appender</span><span class="class">.dailyFile</span><span class="class">.layout</span>=org<span class="class">.apache</span><span class="class">.log4j</span><span class="class">.PatternLayout</span> 
log4j<span class="class">.appender</span><span class="class">.dailyFile</span><span class="class">.layout</span><span class="class">.ConversionPattern</span>=[%-<span class="number">5</span>p] %<span class="function"><span class="title">d</span><span class="params">(%r)</span></span> --&gt; [%t] %l: %m %x %n 
</code></pre><h3 id="发送日志到指定邮件">发送日志到指定邮件</h3><pre><code>log4j<span class="class">.appender</span><span class="class">.mail</span>=org<span class="class">.apache</span><span class="class">.log4j</span><span class="class">.net</span><span class="class">.SMTPAppender</span> 
log4j<span class="class">.appender</span><span class="class">.mail</span><span class="class">.Threshold</span>=FATAL 
log4j<span class="class">.appender</span><span class="class">.mail</span><span class="class">.BufferSize</span>=<span class="number">10</span> 
log4j<span class="class">.appender</span><span class="class">.mail</span><span class="class">.From</span> = xxx@mail<span class="class">.com</span> 
log4j<span class="class">.appender</span><span class="class">.mail</span><span class="class">.SMTPHost</span>=mail<span class="class">.com</span> 
log4j<span class="class">.appender</span><span class="class">.mail</span><span class="class">.Subject</span>=Log4J Message 
log4j<span class="class">.appender</span><span class="class">.mail</span><span class="class">.To</span>= xxx@mail<span class="class">.com</span> 
log4j<span class="class">.appender</span><span class="class">.mail</span><span class="class">.layout</span>=org<span class="class">.apache</span><span class="class">.log4j</span><span class="class">.PatternLayout</span> 
log4j<span class="class">.appender</span><span class="class">.mail</span><span class="class">.layout</span><span class="class">.ConversionPattern</span>=[%-<span class="number">5</span>p] %<span class="function"><span class="title">d</span><span class="params">(%r)</span></span> --&gt; [%t] %l: %m %x %n 
</code></pre><h3 id="应用于数据库">应用于数据库</h3><pre><code>log4j<span class="class">.appender</span><span class="class">.database</span>=org<span class="class">.apache</span><span class="class">.log4j</span><span class="class">.jdbc</span><span class="class">.JDBCAppender</span> 
log4j<span class="class">.appender</span><span class="class">.database</span><span class="class">.URL</span>=jdbc:mysql:<span class="comment">//localhost:3306/test </span>
log4j<span class="class">.appender</span><span class="class">.database</span><span class="class">.driver</span>=com<span class="class">.mysql</span><span class="class">.jdbc</span><span class="class">.Driver</span> 
log4j<span class="class">.appender</span><span class="class">.database</span><span class="class">.user</span>=root 
log4j<span class="class">.appender</span><span class="class">.database</span><span class="class">.password</span>= 
log4j<span class="class">.appender</span><span class="class">.database</span><span class="class">.sql</span>=INSERT INTO LOG4J (Message) <span class="function"><span class="title">VALUES</span><span class="params">(<span class="string">'=[%-5p] %d(%r) --&gt; [%t] %l: %m %x %n'</span>)</span></span> 
log4j<span class="class">.appender</span><span class="class">.database</span><span class="class">.layout</span>=org<span class="class">.apache</span><span class="class">.log4j</span><span class="class">.PatternLayout</span> 
log4j<span class="class">.appender</span><span class="class">.database</span><span class="class">.layout</span><span class="class">.ConversionPattern</span>=[%-<span class="number">5</span>p] %<span class="function"><span class="title">d</span><span class="params">(%r)</span></span> --&gt; [%t] %l: %m %x %n 
</code></pre><h3 id="自定义Appender">自定义Appender</h3><pre><code>log4j<span class="class">.appender</span><span class="class">.im</span> = net<span class="class">.cybercorlin</span><span class="class">.util</span><span class="class">.logger</span><span class="class">.appender</span><span class="class">.IMAppender</span> 
log4j<span class="class">.appender</span><span class="class">.im</span><span class="class">.host</span> = mail<span class="class">.cybercorlin</span><span class="class">.net</span> 
log4j<span class="class">.appender</span><span class="class">.im</span><span class="class">.username</span> = username 
log4j<span class="class">.appender</span><span class="class">.im</span><span class="class">.password</span> = password 
log4j<span class="class">.appender</span><span class="class">.im</span><span class="class">.recipient</span> = 
log4j<span class="class">.appender</span><span class="class">.im</span><span class="class">.layout</span>=org<span class="class">.apache</span><span class="class">.log4j</span><span class="class">.PatternLayout</span> 
log4j<span class="class">.appender</span><span class="class">.im</span><span class="class">.layout</span><span class="class">.ConversionPattern</span>=[%-<span class="number">5</span>p] %<span class="function"><span class="title">d</span><span class="params">(%r)</span></span> --&gt; [%t] %l: %m %x %n 
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<h2 id="xml类型的配置">xml类型的配置</h2><p>Log4j配置文件实现了输出到控制台、文件、固定大小文件、发送日志邮件、输出到数据库日志表、自定义标签等全套功能。 </p>
<pre><code><span class="pi">&lt;?xml versio]]>
    </summary>
    
      <category term="log4j配置" scheme="http://donahue-ldz.github.io/tags/log4j%E9%85%8D%E7%BD%AE/"/>
    
      <category term="log" scheme="http://donahue-ldz.github.io/categories/log/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[日志记录]]></title>
    <link href="http://donahue-ldz.github.io/2015/01/05/%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95/"/>
    <id>http://donahue-ldz.github.io/2015/01/05/日志记录/</id>
    <published>2015-01-05T06:42:11.000Z</published>
    <updated>2015-03-15T05:30:37.000Z</updated>
    <content type="html"><![CDATA[<h2 id="日志服务">日志服务</h2><p>三个目的 ：</p>
<ul>
<li>监视代码中变量的变化情况，周期性的记录到文件中供其他应用进行统计分析工作</li>
<li>跟踪代码运行时轨迹，作为日后审计的依据</li>
<li><p>担当集成开发环境中的调试器的作用，向文件或控制台打印代码的调试信息</p>
<hr>
</li>
</ul>
<h2 id="log4j简介">log4j简介</h2><blockquote>
<p>Log4j是Apache的一个开放源代码项目，通过使用Log4j，我们可以控制日志信息输送的目的地为控制台、文件、GUI组件、甚至可以为套接口服务器、NT的事件记录器、UNIX Syslog守护进程等；我们也可以控制每一条日志的输出格式；通过定义每一条日志信息的级别，我们能够更加细致地控制日志的生成过程。这些可以通过一个配置文件来灵活地进行配置，而不需要修改应用的代码。</p>
<p>此外，通过 Log4j 其他语言接口，您可以在 C 、 C+ + 、 .Net 、 PL/SQL 程序中使用 Log4j ，其语法和用法与在 Java 程序中一样，使得多语言分布式系统得到一个统一一致的日志组件模块。而且，通 过使用各种第三方扩展，您可以很方便地将 Log4j 集成到 J2EE 、 JINI 甚至是 SNMP 应用中。</p>
</blockquote>
<hr>
<h2 id="Log4j三大类构成">Log4j三大类构成</h2><h3 id="Logger">Logger</h3><p>负责输出日志信息，并能够对日志信息进行分类筛选，即决定哪些日志信息应该被输出，哪些该被忽略。Loggers组件输出日志信息时分为5个级别：DEBUG、INFO、WARN、ERROR、FATAL。这五个级别的顺序是：DEBUG&lt;INFO&lt;WARN&lt;ERROR&lt;FATAL。如果设置某个Logger组件的级别是P，则只有级别比P高的日志信息才能输出。Logger是有继承关系的，最上层是rootLogger，定义的其他Logger都会继承rootLogger。</p>
<h3 id="Appender">Appender</h3><p>定义了日志输出目的地，指定日志信息应该被输出到什么地方。输出的目的地可以是控制台、文件或网络设备。<br>格式为：log4j.appender.appenderName =  其中， Log4j提供的appender有以下几种:</p>
<blockquote>
<ol>
<li>org.apache.log4j.ConsoleAppender （控制台）</li>
<li>org.apache.log4j.FileAppender （文件）</li>
<li>org.apache.log4j.DailyRollingFileAppender （每天产生一个日志文件）， </li>
<li>org.apache.log4j.RollingFileAppender （文件大小到达指定尺寸的时候产生一个新的文件） </li>
<li>org.apache.log4j.WriterAppender（将日志信息以流格式发送到任意指定的地方）</li>
<li>org.apache.log4j.JdbcAppender(将日志讯息保存到数据库中) </li>
</ol>
</blockquote>
<p>此外还可以自己定义</p>
<h3 id="Layout">Layout</h3><p>通过在Appender的后面附加Layout来实现格式化输出。</p>
<p>一个Logger可以有多个Appender，每个Appender对应一个Layout。<br>配置日志信息的格式（布局），其语法为：<br>log4j.appender.appenderName.layout = 其中， Log4j 提供的 layout 有以几种：</p>
<blockquote>
<ol>
<li>org.apache.log4j.HTMLLayout （以 HTML 表格形式布局）</li>
<li>org.apache.log4j.SimpleLayout （包含日志信息的级别和信息字符串）</li>
<li>org.apache.log4j.TTCCLayout （包含日志产生的时间、线程、类别等等信息） </li>
<li>org.apache.log4j.PatternLayout （可以灵活地指定布局模式）</li>
</ol>
</blockquote>
<p><code>org.apache.log4j.PatternLayout （可以灵活地指定布局模式）</code></p>
<blockquote>
<p>Log4J 采用类似 C 语言中的 printf 函数的打印格式格式化日志信息，打印参数如下：<br>%m 输出代码中指定的消息<br>%p 输出优先级，即 DEBUG ， INFO ， WARN ， ERROR ， FATAL<br>%r 输出自应用启动到输出该 log 信息耗费的毫秒数<br>%c 输出所属的类目，通常就是所在类的全名<br>%t 输出产生该日志事件的线程名<br>%n 输出一个回车换行符， Windows 平台为 “rn” ， Unix 平台为 “n”<br>%d 输出日志时间点的日期或时间，默认格式为 ISO8601，也可以在其后指定格式，比如： %d{yyy MMM dd HH:mm:ss,SSS} </p>
</blockquote>
<hr>
<h2 id="常见优秀配置配置">常见优秀配置配置</h2><p>详见博文，<a href="http://donahue-ldz.github.io/2015/01/15/log4j%E5%B8%B8%E8%A7%81%E9%85%8D%E7%BD%AE/" target="_blank" rel="external">log4j常见配置</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="日志服务">日志服务</h2><p>三个目的 ：</p>
<ul>
<li>监视代码中变量的变化情况，周期性的记录到文件中供其他应用进行统计分析工作</li>
<li>跟踪代码运行时轨迹，作为日后审计的依据</li>
<li><p>担当集成开发环境中的调试器的作用]]>
    </summary>
    
      <category term="log4j" scheme="http://donahue-ldz.github.io/tags/log4j/"/>
    
      <category term="日志记录" scheme="http://donahue-ldz.github.io/tags/%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95/"/>
    
      <category term="log" scheme="http://donahue-ldz.github.io/categories/log/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[finalize理解]]></title>
    <link href="http://donahue-ldz.github.io/2014/09/28/finalize%E7%90%86%E8%A7%A3/"/>
    <id>http://donahue-ldz.github.io/2014/09/28/finalize理解/</id>
    <published>2014-09-28T09:30:28.000Z</published>
    <updated>2015-03-07T05:15:56.000Z</updated>
    <content type="html"><![CDATA[<p><strong>Object类声明了protect finalize方法</strong></p>
<blockquote>
<p>我们都知道程序初始化的重要性，但是通常会忘记清除工作的重要性，我们知道在c++中有构造函数初始化，有相应的析构函数完成收尾清楚工作</p>
</blockquote>
<p>在java中，有c++样构造函数却没有其相应的析构函数，但是却有一个和析构函数相似的一个finalize方法，很多人容易混淆他们两个，下面是区别：</p>
<ol>
<li><p>c++中析构函数在对象声明周期结束时会被调用，数组等new出来时候，delete等函数时候析构会被调用，如果忘记调用这些函数的时候就会造成内存泄露</p>
</li>
<li><p>java中的finalize方法在GC进行回收之前在做<code>第二次标记</code>的时候会被调用。<br>如果对象没有覆盖finalize()或者已经被调用了一次之后，将不再调用了，如果需要调用的话会被加入一个称为F-queue队列中，然后由虚拟机去自动开一条低优先权的线程去执行，<strong>但是不一定会等待其去执行完</strong>。<br>我们知道对于GC什么时候调用，以及什么时候调用对象的finalize方法这些都是不确定的，一般情况下当内存比较充足时候GC不会去时刻调用的<br>因Gc调用也要消耗资源嘛，对于有些程序而言，有可能某些对象的没有调用GC时候程序已经结束，此时交给<strong>操作系统去回收内存</strong>。</p>
</li>
</ol>
<hr>
<p>所以finalize方法并不总是调用。但是这个方法还是比较有用的，我们知道：<br><code>java的GC之后回收new 出来的对象内存</code><br><code>对于有些时候我们使用native方法，如才c/c++时候采取malloc分配的内存此时GC就不能回收了</code><br>我们也不希望这些内存一直存在，我们可以在finalize方法中去调用native方法的free等函数去试着回收，当finalize方法被调用时候，就象的finalize方法被调用时候，我们可以在里面实现和析构函数相同的功能<br>但是如果没能呗回收了，最起码被回收的机会由原来的0变成大于0了</p>
<p>就是当对有被调用的时候，就不能同等去看待了<br>在现实的使用中我们完全可以忘掉这个方法，她所做的事情完全可以有finally模块去完成，不要使用他吧</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>Object类声明了protect finalize方法</strong></p>
<blockquote>
<p>我们都知道程序初始化的重要性，但是通常会忘记清除工作的重要性，我们知道在c++中有构造函数初始化，有相应的析构函数完成收尾清楚工作</p>
<]]>
    </summary>
    
      <category term="finalize" scheme="http://donahue-ldz.github.io/tags/finalize/"/>
    
      <category term="内存回收" scheme="http://donahue-ldz.github.io/tags/%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6/"/>
    
      <category term="java" scheme="http://donahue-ldz.github.io/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[线程等待]]></title>
    <link href="http://donahue-ldz.github.io/2014/09/15/%E7%BA%BF%E7%A8%8B%E7%AD%89%E5%BE%85/"/>
    <id>http://donahue-ldz.github.io/2014/09/15/线程等待/</id>
    <published>2014-09-15T02:32:21.000Z</published>
    <updated>2015-03-07T05:15:56.000Z</updated>
    <content type="html"><![CDATA[<p><strong>在多线程程序设计中，经常会遇到一个线程等待一个或多个线程的场景<br>遇到这样的场景应该如何解决？</strong></p>
<blockquote>
<ul>
<li>如果是一个线程等待一个线程，则可以通过await()和notify()来实现；</li>
<li>如果是一个线程等待多个线程，则就可以使用CountDownLatch和CyclicBarrier来实现比较好的控制。</li>
</ul>
</blockquote>
<hr>
<h2 id="CountDownLatch应用">CountDownLatch应用</h2><p><code>场景：主要是:一个线程等待多个其他线程</code></p>
<p>例如：百米赛跑：8名运动员同时起跑，由于速度的快慢，肯定有会出现先到终点和晚到终点的情况，而终点有个统计成绩的仪器，当所有选手到达终点时，它会统计所有人的成绩并进行排序，然后把结果发送到汇报成绩的系统。</p>
<p>其实这就是一个CountDownLatch的应用场景：一个线程或多个线程等待其他线程运行达到某一目标后进行自己的下一步工作，而被等待的“其他线程”达到这个目标后继续自己下面的任务。</p>
<p>这个场景中：</p>
<p>被等待的“其他线程”——&gt;8名运动员<br>等待“其他线程”的这个线程——&gt;终点统计成绩的仪器<br>那么，如何来通过CountDownLatch来实现上述场景的线程控制和调度呢？</p>
<blockquote>
<p>jdk中CountDownLatch类有一个常用的构造方法：CountDownLatch(int count)<br>两个常用的方法：await()和countdown()</p>
</blockquote>
<p>其中count是一个计数器中的初始化数字，比如初始化的数字是2，当一个线程里调用了countdown()，则这个计数器就减一，当线程调用了await()，则这个线程就等待这个计数器变为0，当这个计数器变为0时，这个线程继续自己下面的工作。下面是上述CountDownLatch场景的实现：</p>
<p>Work类（运动员）：</p>
<pre><code><span class="keyword">import</span> java.util.concurrent.CountDownLatch;

<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Work</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>{
    <span class="keyword">private</span> <span class="keyword">int</span> id;
    <span class="keyword">private</span> CountDownLatch beginSignal;
    <span class="keyword">private</span> CountDownLatch endSignal;

    <span class="function"><span class="keyword">public</span> <span class="title">Work</span><span class="params">(<span class="keyword">int</span> id, CountDownLatch begin, CountDownLatch end)</span> </span>{
        <span class="keyword">this</span>.id = id;
        <span class="keyword">this</span>.beginSignal = begin;
        <span class="keyword">this</span>.endSignal = end;
    }

    <span class="annotation">@Override</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{
        <span class="keyword">try</span> {
              beginSignal.await();
              System.out.println(<span class="string">"起跑..."</span>);
              System.out.println(<span class="string">"work"</span> + id + <span class="string">"到达终点"</span>);
              endSignal.countDown();
              System.out.println(<span class="string">"work"</span> + id + <span class="string">"继续干其他事情"</span>);
            } <span class="keyword">catch</span> (InterruptedException e) {
                <span class="comment">// TODO Auto-generated catch block</span>
                e.printStackTrace();
            }
    }
</code></pre><p>}<br>Main类（终点统计仪器）：</p>
<pre><code>import java.util.concurrent.CountDownLatch;
<span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Main</span> {

    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{
        CountDownLatch begSignal = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);
        CountDownLatch endSignal = <span class="keyword">new</span> CountDownLatch(<span class="number">8</span>);
        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) {
            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Work(i, begSignal, endSignal)).start();
        }

    <span class="keyword">try</span> {
        begSignal.countDown();  <span class="comment">//统一起跑</span>
        endSignal.await();      <span class="comment">//等待运动员到达终点</span>
        System.<span class="keyword">out</span>.println(<span class="string">"结果发送到汇报成绩的系统"</span>);
        } <span class="keyword">catch</span> (InterruptedException e) {
            e.printStackTrace();
        }
     }
</code></pre><p>}</p>
<hr>
<h2 id="CyclicBarrier的应用">CyclicBarrier的应用</h2><p><code>场景：主要是多个线程之间相互等待，循环等待</code></p>
<p> 例如：有四个游戏玩家玩游戏，游戏有三个关卡，每个关卡必须要所有玩家都到达后才能允许通关。</p>
<p>其实这个场景里的玩家中如果有玩家A先到了关卡1，他必须等待其他所有玩家都到达关卡1时才能通过，也就是说：<br><code>线程之间需要互相等待，这和CountDownLatch的应用场景有区别。</code><br><code>CountDownLatch里的线程是到了运行的目标后继续干自己的其他事情</code><br><code>而这里的线程需要等待其他线程后才能继续完成下面的工作</code>。   </p>
<blockquote>
<p>jdk中CyclicBarrier类有两个常用的构造方法：</p>
<ol>
<li>CyclicBarrier(int parties)<br>这里的parties也是一个计数器，例如，初始化时parties里的计数是3，于是拥有该CyclicBarrier对象的线程当parties的计数为3时就唤醒，注：这里parties里的计数在运行时当调用CyclicBarrier:await()时,计数就加1，一直加到初始的值。</li>
<li>CyclicBarrier(int parties, Runnable barrierAction)<br>这里的parties与上一个构造方法的解释是一样的，这里需要解释的是第二个入参（Runnable barrierAction）,这个参数是一个实现Runnable接口的类的对象，也就是说当parties加到初始值时就出发barrierAction的内容。</li>
</ol>
</blockquote>
<p>下面来实现上述的应用场景：</p>
<p>Player类（玩家类）</p>
<pre><code><span class="keyword">import</span> java.util.concurrent.BrokenBarrierException;
<span class="keyword">import</span> java.util.concurrent.CyclicBarrier;

<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Player</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>{

    <span class="keyword">private</span> CyclicBarrier cyclicBarrier;
    <span class="keyword">private</span> <span class="keyword">int</span> id;

    <span class="function"><span class="keyword">public</span> <span class="title">Player</span><span class="params">(<span class="keyword">int</span> id, CyclicBarrier cyclicBarrier)</span> </span>{
        <span class="keyword">this</span>.cyclicBarrier = cyclicBarrier;
        <span class="keyword">this</span>.id = id;
    }

    <span class="annotation">@Override</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{
        <span class="keyword">try</span> {
            System.out.println(<span class="string">"玩家"</span> + id + <span class="string">"正在玩第一关..."</span>);
            cyclicBarrier.await();
            System.out.println(<span class="string">"玩家"</span> + id + <span class="string">"进入第二关..."</span>);
            } <span class="keyword">catch</span> (InterruptedException e) {
              e.printStackTrace();
        } <span class="keyword">catch</span> (BrokenBarrierException e) {
             e.printStackTrace();
    }
  }
}
</code></pre><p>GameBarrier类（关卡类，这里控制玩家必须全部到达第一关结束的关口才能进入第二关）</p>
<pre><code><span class="keyword">import</span> java.util.concurrent.CyclicBarrier;

<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GameBarrier</span> </span>{

    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{
    CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">4</span>, <span class="keyword">new</span> Runnable() {

        <span class="annotation">@Override</span>
        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{
             System.out.println(<span class="string">"所有玩家进入第二关！"</span>);
        }
     });

    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) {
        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Player(i, cyclicBarrier)).start();
     }
  }
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p><strong>在多线程程序设计中，经常会遇到一个线程等待一个或多个线程的场景<br>遇到这样的场景应该如何解决？</strong></p>
<blockquote>
<ul>
<li>如果是一个线程等待一个线程，则可以通过await()和notify()来实现；</li>]]>
    </summary>
    
      <category term="CyclicBarrier" scheme="http://donahue-ldz.github.io/tags/CyclicBarrier/"/>
    
      <category term="线程" scheme="http://donahue-ldz.github.io/tags/%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="线程等待，CountDownLatch" scheme="http://donahue-ldz.github.io/tags/%E7%BA%BF%E7%A8%8B%E7%AD%89%E5%BE%85%EF%BC%8CCountDownLatch/"/>
    
      <category term="java" scheme="http://donahue-ldz.github.io/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[vim 配色知识]]></title>
    <link href="http://donahue-ldz.github.io/2014/03/23/vim-%E9%85%8D%E8%89%B2/"/>
    <id>http://donahue-ldz.github.io/2014/03/23/vim-配色/</id>
    <published>2014-03-23T08:31:51.000Z</published>
    <updated>2015-03-07T05:17:49.000Z</updated>
    <content type="html"><![CDATA[<p>在vimcolorschemetest站点上，有数以千计的vim主题插件，然而每款主题或多或少都有我们不满意的地方，这就需要我们自己动手来进行扩展。</p>
<hr>
<h2 id="基础知识">基础知识</h2><p>在vim中，主题也是以插件形式存在的。其中系统自带的主题，存放在$VIMRUNTIME/colors文件夹下，以*.vim命名。（注：查看$VIMRUNTIME请在vim中执行 :echo $VIMRUNTIME）<br>用户自定义的主题一般不放在系统目录下，而是放在<code>~/.vim/colors</code>目录下，这样不会干扰到其他用户，同时也方便备份自己的vim配置。<br>更换vim主题的命令为：<br><code>:colorscheme 主题插件名称</code><br>但是这样只能临时改变vim主题，退出后又会恢复原样，如果想永久改变，请在~/.vimrc中添加：<br><code>colorscheme 主题插件名称</code></p>
<p>由于我不使用Windows下的gvim，而是在linux下或远程ssh使用终端下的vim，因此首先需要在~/.vimrc中添加开启256颜色支持：<br><code>set t_Co=256</code><br>为了能在编辑程序时高亮显示关键字，还需要在~/.vimrc中开启语法高亮显示：<br><code>syntax enable</code><br><code>syntax on</code><br>做完上述的准备工作后，让我们正式开始定制主题之旅吧！</p>
<h3 id="主题色调">主题色调</h3><p>在配置其他属性前，首先要配置主题整体的色调，只有两个选择：dark和light（暗色调和亮色调）。对于经常阅读和编写代码的程序员来说，暗色调是更好的选择：</p>
<p><code>set background=dark</code><br><strong><span style="color: #ff00ff;">接下来，需要重新设置一下语法高亮，否则设置不会生效：</span></strong><br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">version</span> &gt; <span class="number">580</span></span><br><span class="line"><span class="keyword">hi</span> clear</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">exists</span>(<span class="string">"syntax_on"</span>)</span><br><span class="line"><span class="keyword">syntax</span> reset</span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure></p>
<h3 id="主题名称">主题名称</h3><p>主题名称是无参数调用 :colorscheme 时返回的信息，用于分辨不同主题，其设置如下：</p>
<p><code>let g:colors_name=&quot;nslib_color256&quot;</code></p>
<h4 id="基础属性">基础属性</h4><p>由于vim可以在黑白终端、彩色终端、GUI界面下运行，所以需要对其分贝进行配置，下面给出一个简要的文档说明：</p>
<blockquote>
<p>term 黑白终端的属性<br>cterm  彩色终端的属性<br>ctermfg 彩色终端前景色<br>ctermbg 彩色终端背景色<br>gui GUI属性<br>guifg GUI前景色<br>guibg GUI背景色</p>
</blockquote>
<p>对于黑白终端，我们没有配置的必要，因此主要的配置工作集中在彩色终端与GUI界面上，又由于彩色终端与GUI界面的配置只是关键字不同，因此这里只选取彩色终端进行说明。</p>
<a id="more"></a>
<p>由于不是所有终端都支持256色，因此使用一些安全色会使我们的主题更有移植性，而GUI可以支持所有颜色，不在考虑范围之内，vim文档给出的安全色如下：</p>
<blockquote>
<p>“0 Black<br>“1 DarkBlue<br>“2 DarkGreen<br>“3 DarkCyan<br>“4 DarkRed<br>“5 DarkMagenta<br>“6 Brown, DarkYellow<br>“7 LightGray, LightGrey, Gray, Grey<br>“8 DarkGray, DarkGrey<br>“9 Blue, LightBlue<br>“10 Green, LightGreen<br>“11 Cyan, LightCyan<br>“12 Red, LightRed<br>“13 Magenta, LightMagenta<br>“14 Yellow, LightYellow<br>“15 White</p>
</blockquote>
<!--more-->
<h3 id="配色语法">配色语法</h3><p>下面举例说明配色语法：<br><code>hi Type ctermfg=LightYellow ctermbg=Black cterm=bold</code><br>其中，hi是highlight命令的缩写，用于高亮配置；Type是要配色的元素名称；参数采用的是Key=Value的形式。</p>
<p>元素列表<br>配置颜色的语法非常简单，无需累赘，下面将分类介绍常用的元素标签：</p>
<h4 id="状态栏提示信息">状态栏提示信息</h4><blockquote>
<p>hi StatusLine 状态栏<br>hi StatusLineNC 非当前窗口的状态栏<br>ErrorMsg 错误信息<br>WarningMsg 警告信息<br>ModeMsg 当前模式<br>MoreMsg 其他文本<br>Question 询问用户<br>Error 错误</p>
</blockquote>
<h4 id="文本搜索">文本搜索</h4><blockquote>
<p>hi IncSearch 增量搜索时匹配的文本符串<br>hi Search 匹配的文本串</p>
</blockquote>
<h4 id="弹出菜单">弹出菜单</h4><blockquote>
<p>Pmenu 弹出菜单<br>PmenuSel 菜单当前选择项</p>
</blockquote>
<h4 id="窗体边框相关">窗体边框相关</h4><blockquote>
<p>VertSplit 垂直分割窗口的边框<br>LineNr 行号<br>Cursor 光标所在字符<br>CursorLine 光标所在行<br>ColorColumn 光标所在列<br>ColorColumn 标尺<br>NonText 窗口尾部的~和@，以及文本里实际不显示的字符</p>
</blockquote>
<h4 id="diff模式">diff模式</h4><blockquote>
<p>DiffAdd diff模式增加的行<br>DiffChange diff模式改变的行<br>DiffDelete diff模式删除的行<br>DiffText diff模式插入文本</p>
</blockquote>
<h4 id="C/C++语法">C/C++语法</h4><blockquote>
<p>Comment 注释<br>PreProc 预处理<br>Type 数据类型<br>Constant 常量<br>Statement 控制语句<br>Special 字符串中的中的特殊字符<br>String 字符串<br>cCppString Cpp字符串<br>Number 数字<br>Todo TODO、HACK、FIXME等标签</p>
</blockquote>
<h3 id="我的主题">我的主题</h3><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">set <span class="variable">background=</span>dark</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> version &amp;gt; <span class="number">580</span></span><br><span class="line">hi clear</span><br><span class="line"><span class="keyword">if</span> exists(<span class="string">"syntax_on"</span>)</span><br><span class="line">syntax reset</span><br><span class="line">endif</span><br><span class="line">endif</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> g:<span class="variable">colors_name=</span><span class="string">"nslib_color256"</span></span><br><span class="line"></span><br><span class="line">hi Normal <span class="variable">ctermfg=</span>Grey <span class="variable">ctermbg=</span>Black</span><br><span class="line">hi ColorColumn <span class="variable">ctermfg=</span>White <span class="variable">ctermbg=</span>Grey</span><br><span class="line">·</span><br><span class="line">hi ErrorMsg <span class="variable">term=</span>standout</span><br><span class="line">hi ErrorMsg <span class="variable">ctermfg=</span>LightBlue <span class="variable">ctermbg=</span>DarkBlue</span><br><span class="line">hi WarningMsg <span class="variable">term=</span>standout</span><br><span class="line">hi WarningMsg <span class="variable">ctermfg=</span>LightBlue <span class="variable">ctermbg=</span>DarkBlue</span><br><span class="line">hi ModeMsg <span class="variable">term=</span>bold <span class="variable">cterm=</span>bold</span><br><span class="line">hi ModeMsg <span class="variable">ctermfg=</span>LightBlue <span class="variable">ctermbg=</span>Black</span><br><span class="line">hi MoreMsg <span class="variable">term=</span>bold <span class="variable">ctermfg=</span>LightGreen</span><br><span class="line">hi MoreMsg <span class="variable">ctermfg=</span>LightBlue <span class="variable">ctermbg=</span>Black</span><br><span class="line">hi Question <span class="variable">term=</span>standout <span class="variable">gui=</span>bold</span><br><span class="line">hi Question <span class="variable">ctermfg=</span>LightBlue <span class="variable">ctermbg=</span>Black</span><br><span class="line">hi Error <span class="variable">term=</span>bold <span class="variable">cterm=</span>bold</span><br><span class="line">hi Error <span class="variable">ctermfg=</span>LightBlue <span class="variable">ctermbg=</span>Black</span><br><span class="line">·</span><br><span class="line">hi LineNr <span class="variable">ctermfg=</span>LightBlue <span class="variable">ctermbg=</span>Black</span><br><span class="line">hi CursorColumn <span class="variable">ctermfg=</span>White <span class="variable">ctermbg=</span>Grey</span><br><span class="line">hi CursorLine <span class="variable">ctermfg=</span>LightBlue <span class="variable">ctermbg=</span>Black</span><br><span class="line">hi ColorColumn <span class="variable">ctermfg=</span>White <span class="variable">ctermbg=</span>Grey</span><br><span class="line">·</span><br><span class="line">hi IncSearch <span class="variable">ctermfg=</span>Black <span class="variable">ctermbg=</span>DarkGrey</span><br><span class="line">hi Search <span class="variable">ctermfg=</span>Black <span class="variable">ctermbg=</span>DarkGrey</span><br><span class="line">hi StatusLine <span class="variable">term=</span>bold <span class="variable">cterm=</span>bold</span><br><span class="line">hi StatusLine <span class="variable">ctermfg=</span>Black <span class="variable">ctermbg=</span>Grey</span><br><span class="line">hi StatusLineNC <span class="variable">term=</span>bold <span class="variable">cterm=</span>bold</span><br><span class="line">hi StatusLineNC <span class="variable">ctermfg=</span>Black <span class="variable">ctermbg=</span>Grey</span><br><span class="line">·</span><br><span class="line">hi VertSplit <span class="variable">ctermfg=</span>Grey <span class="variable">ctermbg=</span>Grey</span><br><span class="line">hi Visual <span class="variable">term=</span>bold <span class="variable">cterm=</span>bold</span><br><span class="line">hi Visual <span class="variable">ctermfg=</span>Black <span class="variable">ctermbg=</span>Grey</span><br><span class="line">·</span><br><span class="line">highlight Pmenu <span class="variable">ctermfg=</span>Black <span class="variable">ctermbg=</span>Grey</span><br><span class="line">highlight PmenuSel <span class="variable">ctermfg=</span>LightBlue <span class="variable">ctermbg=</span>DarkBlue</span><br><span class="line">·</span><br><span class="line">hi Comment <span class="variable">ctermfg=</span>DarkCyan <span class="variable">ctermbg=</span>Black</span><br><span class="line">hi PreProc <span class="variable">ctermfg=</span>Blue <span class="variable">ctermbg=</span>Black</span><br><span class="line">hi Type <span class="variable">ctermfg=</span>LightYellow <span class="variable">ctermbg=</span>Black <span class="variable">cterm=</span>bold</span><br><span class="line">hi Constant <span class="variable">ctermfg=</span>Blue <span class="variable">ctermbg=</span>Black <span class="variable">cterm=</span>bold</span><br><span class="line">hi Statement <span class="variable">ctermfg=</span>LightYellow <span class="variable">ctermbg=</span>Black <span class="variable">cterm=</span>bold</span><br><span class="line">hi Special <span class="variable">ctermfg=</span>Red <span class="variable">ctermbg=</span>Black <span class="variable">cterm=</span>bold</span><br><span class="line">hi SpecialKey <span class="variable">ctermfg=</span>Red <span class="variable">ctermbg=</span>Black <span class="variable">cterm=</span>bold</span><br><span class="line">hi Number <span class="variable">ctermfg=</span>Blue <span class="variable">ctermbg=</span>Black</span><br><span class="line">hi cCppString <span class="variable">ctermfg=</span>Red <span class="variable">ctermbg=</span>Black</span><br><span class="line">hi String <span class="variable">ctermfg=</span>Red <span class="variable">ctermbg=</span>Black</span><br><span class="line">hi Identifier <span class="variable">ctermfg=</span>Red <span class="variable">ctermbg=</span>Black <span class="variable">cterm=</span>bold</span><br><span class="line">hi Todo <span class="variable">ctermfg=</span>Black <span class="variable">ctermbg=</span>Gray <span class="variable">cterm=</span>bold</span><br><span class="line">hi NonText <span class="variable">ctermfg=</span>LightBlue <span class="variable">ctermbg=</span>Black</span><br><span class="line">hi Directory <span class="variable">ctermfg=</span>Blue <span class="variable">ctermbg=</span>Black</span><br><span class="line">hi Folded <span class="variable">ctermfg=</span>DarkBlue <span class="variable">ctermbg=</span>Black <span class="variable">cterm=</span>bold</span><br><span class="line">hi FoldColumn <span class="variable">ctermfg=</span>LightBlue <span class="variable">ctermbg=</span>Black</span><br><span class="line">hi Underlined <span class="variable">ctermfg=</span>LightBlue <span class="variable">ctermbg=</span>Black <span class="variable">cterm=</span>underline</span><br><span class="line">hi Title <span class="variable">ctermfg=</span>LightBlue <span class="variable">ctermbg=</span>Black</span><br><span class="line">hi Ignore <span class="variable">ctermfg=</span>LightBlue <span class="variable">ctermbg=</span>Black</span><br><span class="line"></span><br><span class="line">hi Directory <span class="variable">ctermfg=</span>LightBlue <span class="variable">ctermbg=</span>Black</span><br><span class="line">hi browseSynopsis <span class="variable">ctermfg=</span>LightBlue <span class="variable">ctermbg=</span>Black</span><br><span class="line">hi browseCurDir <span class="variable">ctermfg=</span>LightBlue <span class="variable">ctermbg=</span>Black</span><br><span class="line">hi favoriteDirectory <span class="variable">ctermfg=</span>LightBlue <span class="variable">ctermbg=</span>Black</span><br><span class="line">hi browseDirectory <span class="variable">ctermfg=</span>LightBlue <span class="variable">ctermbg=</span>Black</span><br><span class="line">hi browseSuffixInfo <span class="variable">ctermfg=</span>LightBlue <span class="variable">ctermbg=</span>Black</span><br><span class="line">hi browseSortBy <span class="variable">ctermfg=</span>LightBlue <span class="variable">ctermbg=</span>Black</span><br><span class="line">hi browseFilter <span class="variable">ctermfg=</span>LightBlue <span class="variable">ctermbg=</span>Black</span><br><span class="line">hi browseFiletime <span class="variable">ctermfg=</span>LightBlue <span class="variable">ctermbg=</span>Black</span><br><span class="line">hi browseSuffixes <span class="variable">ctermfg=</span>LightBlue <span class="variable">ctermbg=</span>Black</span><br><span class="line"></span><br><span class="line">hi TagListComment <span class="variable">ctermfg=</span>LightBlue <span class="variable">ctermbg=</span>Black</span><br><span class="line">hi TagListFileName <span class="variable">ctermfg=</span>LightBlue <span class="variable">ctermbg=</span>Black</span><br><span class="line">hi TagListTitle <span class="variable">ctermfg=</span>LightBlue <span class="variable">ctermbg=</span>Black</span><br><span class="line">hi TagListTagScope <span class="variable">ctermfg=</span>LightBlue <span class="variable">ctermbg=</span>Black</span><br><span class="line">hi TagListTagName <span class="variable">ctermfg=</span>LightBlue <span class="variable">ctermbg=</span>Black</span><br><span class="line">hi Tag <span class="variable">ctermfg=</span>LightBlue <span class="variable">ctermbg=</span>Black</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<p>在vimcolorschemetest站点上，有数以千计的vim主题插件，然而每款主题或多或少都有我们不满意的地方，这就需要我们自己动手来进行扩展。</p>
<hr>
<h2 id="基础知识">基础知识</h2><p>在vim中，主题也是以插件形式存在的。其中系统自带的主题，存放在$VIMRUNTIME/colors文件夹下，以*.vim命名。（注：查看$VIMRUNTIME请在vim中执行 :echo $VIMRUNTIME）<br>用户自定义的主题一般不放在系统目录下，而是放在<code>~/.vim/colors</code>目录下，这样不会干扰到其他用户，同时也方便备份自己的vim配置。<br>更换vim主题的命令为：<br><code>:colorscheme 主题插件名称</code><br>但是这样只能临时改变vim主题，退出后又会恢复原样，如果想永久改变，请在~/.vimrc中添加：<br><code>colorscheme 主题插件名称</code></p>
<p>由于我不使用Windows下的gvim，而是在linux下或远程ssh使用终端下的vim，因此首先需要在~/.vimrc中添加开启256颜色支持：<br><code>set t_Co=256</code><br>为了能在编辑程序时高亮显示关键字，还需要在~/.vimrc中开启语法高亮显示：<br><code>syntax enable</code><br><code>syntax on</code><br>做完上述的准备工作后，让我们正式开始定制主题之旅吧！</p>
<h3 id="主题色调">主题色调</h3><p>在配置其他属性前，首先要配置主题整体的色调，只有两个选择：dark和light（暗色调和亮色调）。对于经常阅读和编写代码的程序员来说，暗色调是更好的选择：</p>
<p><code>set background=dark</code><br><strong><span style="color: #ff00ff;">接下来，需要重新设置一下语法高亮，否则设置不会生效：</span></strong><br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">version</span> &gt; <span class="number">580</span></span><br><span class="line"><span class="keyword">hi</span> clear</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">exists</span>(<span class="string">"syntax_on"</span>)</span><br><span class="line"><span class="keyword">syntax</span> reset</span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure></p>
<h3 id="主题名称">主题名称</h3><p>主题名称是无参数调用 :colorscheme 时返回的信息，用于分辨不同主题，其设置如下：</p>
<p><code>let g:colors_name=&quot;nslib_color256&quot;</code></p>
<h4 id="基础属性">基础属性</h4><p>由于vim可以在黑白终端、彩色终端、GUI界面下运行，所以需要对其分贝进行配置，下面给出一个简要的文档说明：</p>
<blockquote>
<p>term 黑白终端的属性<br>cterm  彩色终端的属性<br>ctermfg 彩色终端前景色<br>ctermbg 彩色终端背景色<br>gui GUI属性<br>guifg GUI前景色<br>guibg GUI背景色</p>
</blockquote>
<p>对于黑白终端，我们没有配置的必要，因此主要的配置工作集中在彩色终端与GUI界面上，又由于彩色终端与GUI界面的配置只是关键字不同，因此这里只选取彩色终端进行说明。</p>]]>
    
    </summary>
    
      <category term="vim" scheme="http://donahue-ldz.github.io/tags/vim/"/>
    
  </entry>
  
</feed>